{"pages":[{"title":"关于","date":"2025-10-16T16:00:00.000Z","path":"about/index.html","text":"渣渣熊窝"},{"title":"项目","date":"2025-10-16T16:00:00.000Z","path":"repository/index.html","text":"仓库列表暂未公开。"},{"title":"分类","date":"2025-10-16T16:00:00.000Z","path":"categories/index.html","text":""},{"title":"标签","date":"2025-10-16T16:00:00.000Z","path":"tags/index.html","text":""},{"title":"","date":"2025-10-18T14:18:00.595Z","path":"downloads/OllamaStreamGenerateInterface.html","text":"AI Chatbot :root { color-scheme: light; } body.web-page { font-family: 'Inter', 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif; background: radial-gradient(circle at 15% 20%, rgba(151, 190, 255, 0.22), transparent 55%), radial-gradient(circle at 85% 10%, rgba(120, 180, 255, 0.18), transparent 50%), linear-gradient(180deg, #F4F7FB 0%, #E3F0FF 100%); min-height: 100vh; color: #1F2430; } .glass-card { backdrop-filter: blur(10px); background: rgba(243, 248, 255, 0.9); border: 1px solid rgba(138, 163, 210, 0.2); box-shadow: 0 16px 36px -24px rgba(34, 61, 120, 0.28); } .signal-gradient { background: linear-gradient(90deg, #5A8DEE 0%, #7AD1F8 100%); } #conversation { max-height: 60vh; } /* Markdown 样式 */ .ai-message pre { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; font-size: 13px; line-height: 1.4; } .ai-message code { background: #f1f3f4; color: #d73a49; padding: 2px 6px; border-radius: 3px; font-size: 12px; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; } .ai-message pre code { background: transparent; color: inherit; padding: 0; border-radius: 0; } .ai-message h1, .ai-message h2, .ai-message h3 { color: #1f2937; margin: 16px 0 8px 0; font-weight: 600; } .ai-message h1 { font-size: 1.5em; } .ai-message h2 { font-size: 1.25em; } .ai-message h3 { font-size: 1.125em; } .ai-message p { margin: 8px 0; line-height: 1.6; } .ai-message ul, .ai-message ol { margin: 8px 0; padding-left: 24px; } .ai-message li { margin: 4px 0; } .ai-message blockquote { border-left: 4px solid #e5e7eb; padding-left: 16px; margin: 12px 0; color: #6b7280; font-style: italic; } .ai-message table { border-collapse: collapse; margin: 12px 0; width: 100%; } .ai-message th, .ai-message td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; } .ai-message th { background: #f9fafb; font-weight: 600; } AI Chatbot Deepseek R1:1.5B 当前模式 普通请求 一次性返回完整消息。 点击底部按钮可切换至流式模式。 查看日志 对话区 用于展示实时的模型回复与用户消息。 还没有消息，输入内容开始对话吧。 切换到流式请求 请求日志 最近活动 清空日志 const DEFAULT_MODEL = 'deepseek-r1:1.5b'; const modeToggle = document.getElementById('modeToggle'); const modeToggleLabel = document.getElementById('modeToggleLabel'); const modeLabel = document.getElementById('modeLabel'); const modeDescription = document.getElementById('modeDescription'); const modeHint = document.getElementById('modeHint'); const logToggle = document.getElementById('logToggle'); const logPanel = document.getElementById('logPanel'); const logClose = document.getElementById('logClose'); const logClear = document.getElementById('logClear'); const logList = document.getElementById('logList'); const messageInput = document.getElementById('messageInput'); const conversation = document.getElementById('conversation'); const chatForm = document.getElementById('chatForm'); const submitButton = chatForm.querySelector('button[type=\"submit\"]'); const modes = { standard: { name: '普通请求', description: '一次性返回完整消息。', hint: '点击底部按钮可切换至流式模式。', toggleText: '切换到流式请求', next: 'stream' }, stream: { name: '流式请求', description: '逐段返回，适合实时展示。', hint: '点击底部按钮可切换至普通模式。', toggleText: '切换到普通请求', next: 'standard' } }; let currentMode = 'standard'; let isRequestPending = false; const logs = []; const sentMessages = []; // 用于存储用户发送的消息 let historyIndex = -1; // 用于追踪历史记录的位置 function updateModeUI() { const { name, description, hint, toggleText } = modes[currentMode]; modeLabel.textContent = name; modeDescription.textContent = description; modeHint.textContent = hint; modeToggleLabel.textContent = toggleText; modeToggle.dataset.mode = currentMode; modeToggle.setAttribute('aria-pressed', currentMode === 'stream'); modeToggle.title = `${name} · ${description}`; } function createMessagePreview(text) { const trimmed = text.replace(/\\s+/g, ' ').trim(); return trimmed.length > 60 ? `${trimmed.slice(0, 60)}…` : trimmed; } function removeEmptyState() { const emptyState = conversation.querySelector('[data-empty-state]'); if (emptyState) { emptyState.remove(); } } function appendUserMessage(text) { const wrapper = document.createElement('div'); wrapper.className = 'flex justify-end'; const bubble = document.createElement('div'); bubble.className = 'max-w-[70%] rounded-3xl bg-sky-100/80 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words'; bubble.textContent = text; wrapper.appendChild(bubble); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; } function appendAssistantMessage(initialText = '模型生成中…') { const wrapper = document.createElement('div'); wrapper.className = 'flex gap-3'; const avatar = document.createElement('div'); avatar.className = 'w-9 h-9 rounded-full signal-gradient text-white flex items-center justify-center shadow-md'; avatar.innerHTML = ''; const body = document.createElement('div'); body.className = 'max-w-[72%] rounded-3xl bg-white/90 border border-slate-200/60 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words ai-message'; const thinkDiv = document.createElement('div'); thinkDiv.className = 'mb-2 text-xs text-slate-400 bg-slate-50/50 px-2 py-1 rounded-lg border-l-2 border-slate-300'; thinkDiv.style.display = 'none'; thinkDiv.innerHTML = '深度思考...'; const contentDiv = document.createElement('div'); contentDiv.textContent = initialText; body.appendChild(thinkDiv); body.appendChild(contentDiv); wrapper.append(avatar, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; return { bubble: body, thinkDiv, contentDiv }; } function appendSystemMessage(text) { const wrapper = document.createElement('div'); wrapper.className = 'flex gap-3'; const badge = document.createElement('div'); badge.className = 'w-9 h-9 rounded-full bg-rose-100 text-rose-500 flex items-center justify-center shadow-sm'; badge.innerHTML = ''; const body = document.createElement('div'); const bubble = document.createElement('div'); bubble.className = 'max-w-[72%] rounded-3xl bg-white border border-rose-200 px-4 py-3 text-sm text-rose-600 leading-relaxed whitespace-pre-wrap break-words'; bubble.textContent = text; body.appendChild(bubble); wrapper.append(badge, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; } function addLog(text) { logs.unshift({ text, timestamp: new Date().toLocaleTimeString() }); if (logs.length > 120) { logs.pop(); } renderLogs(); } function renderLogs() { logList.innerHTML = ''; if (!logs.length) { const emptyItem = document.createElement('li'); emptyItem.className = 'text-slate-400 text-center py-4'; emptyItem.textContent = '暂无日志'; logList.appendChild(emptyItem); return; } logs.forEach(({ text, timestamp }) => { const item = document.createElement('li'); item.className = 'rounded-2xl border border-slate-200/60 bg-white/80 px-3 py-2.5 shadow-sm'; item.innerHTML = ` ${timestamp} ${text} `; logList.appendChild(item); }); } function toggleFormDisabled(disabled) { submitButton.disabled = disabled; messageInput.disabled = disabled; modeToggle.disabled = disabled; submitButton.classList.toggle('opacity-60', disabled); submitButton.classList.toggle('cursor-not-allowed', disabled); messageInput.classList.toggle('opacity-70', disabled); } modeToggle.addEventListener('click', () => { if (isRequestPending) return; currentMode = modes[currentMode].next; updateModeUI(); }); logToggle.addEventListener('click', () => { logPanel.classList.toggle('hidden'); if (!logPanel.classList.contains('hidden')) { renderLogs(); } }); logClose.addEventListener('click', () => { logPanel.classList.add('hidden'); }); logClear.addEventListener('click', () => { logs.length = 0; renderLogs(); }); chatForm.addEventListener('submit', async (event) => { event.preventDefault(); const text = messageInput.value.trim(); if (!text || isRequestPending) { return; } // 添加到历史记录 if (sentMessages[0] !== text) { sentMessages.unshift(text); } historyIndex = -1; // 重置历史记录索引 removeEmptyState(); appendUserMessage(text); messageInput.value = ''; messageInput.focus(); const preview = createMessagePreview(text); addLog(`准备发送 ${modes[currentMode].name}：${preview}`); const aiBubble = appendAssistantMessage(); isRequestPending = true; toggleFormDisabled(true); try { await dispatchRequest(text, aiBubble); } catch (error) { console.error(error); addLog(`${modes[currentMode].name} 请求失败：${error.message}`); appendSystemMessage(`请求失败：${error.message}`); } finally { isRequestPending = false; toggleFormDisabled(false); } }); async function dispatchRequest(message, aiBubble) { const endpoint = currentMode === 'standard' ? 'generate' : 'generate_stream'; const url = `/api/v1/ollama/${endpoint}?model=${encodeURIComponent(DEFAULT_MODEL)}&message=${encodeURIComponent(message)}`; addLog(`请求 URL：${url}`); try { if (currentMode === 'standard') { const { status } = await handleStandardRequest(url, aiBubble); addLog(`普通请求成功 · HTTP ${status}`); } else { const { status } = await handleStreamRequest(url, aiBubble); addLog(`流式请求成功 · HTTP ${status}`); } } catch (error) { aiBubble.contentDiv.innerHTML = marked.parse(`请求失败：${error.message}`); throw error; } } async function handleStandardRequest(url, aiBubble) { const response = await fetch(url); const status = response.status; if (!response.ok) { const errorText = await response.text().catch(() => ''); throw new Error(`HTTP ${status}${errorText ? ` · ${errorText}` : ''}`); } const contentType = response.headers.get('content-type') || ''; let fullText; if (contentType.includes('application/json')) { const data = await response.json(); fullText = extractContent(data); } else { fullText = await response.text(); } // 解析 think 和正文 const thinkMatch = fullText.match(/([\\s\\S]*?)/); const thinkContent = thinkMatch ? thinkMatch[1].trim() : '正在思考中...'; const mainContent = fullText.replace(/[\\s\\S]*?\\s*/, '').trim(); aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考完毕' + thinkContent.replace(/\\n/g, ''); aiBubble.contentDiv.innerHTML = marked.parse(mainContent || '（模型没有返回内容）'); conversation.scrollTop = conversation.scrollHeight; return { status }; } async function handleStreamRequest(url, aiBubble) { const response = await fetch(url); const status = response.status; if (!response.ok) { const errorText = await response.text().catch(() => ''); throw new Error(`HTTP ${status}${errorText ? ` · ${errorText}` : ''}`); } // 重置内容 aiBubble.contentDiv.textContent = ''; aiBubble.thinkDiv.style.display = 'none'; const data = await response.json(); if (Array.isArray(data)) { // 后端返回的是一个完整的JSON数组 let fullText = ''; for (const item of data) { const content = extractContent(item); if (content) { fullText += content; // 直接更新文本内容，不再调用会重新渲染的函数 updateStreamDisplay(fullText, aiBubble, true); } // 添加延迟，模拟流式效果 await new Promise(resolve => setTimeout(resolve, 100)); } } else { // 处理其他可能的JSON结构或错误 const content = extractContent(data); if (content) { updateStreamDisplay(content, aiBubble, false); } else { aiBubble.contentDiv.innerHTML = marked.parse('（模型没有返回有效内容）'); } } return { status }; } // 从单行数据中提取内容 // function extractContentFromLine(line) { ... } // 此函数已不再需要 // 更新流式显示 function updateStreamDisplay(fullText, aiBubble, isStreaming) { // 处理 think 标签 const thinkMatch = fullText.match(/([\\s\\S]*?)(|$)/); if (thinkMatch) { if (!thinkMatch[2]) { // 思考中 const thinkContent = thinkMatch[1]; aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考中...' + thinkContent.replace(/\\n/g, ''); aiBubble.contentDiv.textContent = ''; } else { // 思考完成 const thinkContent = thinkMatch[1].trim(); aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考完毕' + thinkContent.replace(/\\n/g, ''); // 提取并显示主要内容 const mainContent = fullText.replace(/[\\s\\S]*?\\s*/, '').trim(); aiBubble.contentDiv.innerHTML = marked.parse(mainContent); } } else { // 直接显示主要内容 aiBubble.contentDiv.innerHTML = marked.parse(fullText); } conversation.scrollTop = conversation.scrollHeight; } // 逐字显示内容 // displayContentGradually 函数已完全删除，不再需要 // 处理非流式响应 // async function processCompleteResponse(text, aiBubble) { ... } // 此函数已不再需要 function extractContent(data) { if (!data) return ''; if (typeof data === 'string') return data; const maybeContent = data?.result?.output?.content ?? data?.result?.output?.text ?? data?.output?.content ?? data?.message ?? data?.choices?.[0]?.message?.content ?? data?.results?.[0]?.output?.content; if (Array.isArray(maybeContent)) { return maybeContent.map((item) => { if (typeof item === 'string') return item; if (item?.text) return item.text; return ''; }).join('\\n'); } if (typeof maybeContent === 'object' && maybeContent !== null) { if (maybeContent.text) return maybeContent.text; return ''; } if (maybeContent) { return String(maybeContent); } return ''; } // 初始化界面 updateModeUI(); renderLogs(); messageInput.addEventListener('keydown', (event) => { if (event.key === 'ArrowUp') { event.preventDefault(); if (sentMessages.length > 0 && historyIndex < sentMessages.length - 1) { historyIndex++; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); } } else if (event.key === 'ArrowDown') { event.preventDefault(); if (historyIndex > 0) { historyIndex--; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); } else if (historyIndex"},{"title":"友链","date":"2025-10-16T16:00:00.000Z","path":"links/index.html","text":""},{"title":"","date":"2025-10-18T14:17:41.739Z","path":"downloads/OllamaRAGInterface.html","text":"DeepSeek AI 助手 tailwind.config = { theme: { extend: { colors: { primary: { 50: '#f5f9ff', 100: '#eaf0ff', 200: '#d7e1ff', 300: '#b9c9ff', 400: '#94a6ff', 500: '#6c7fff', 600: '#4a5bff', 700: '#373fe5', 800: '#2b31b4', 900: '#252c8d' } }, boxShadow: { soft: '0 20px 45px -24px rgba(15,23,42,0.35)' } } } } html, body { height: 100%; } .markdown-body { font-size: 15px; line-height: 1.75; color: inherit; } .markdown-body>*:last-child { margin-bottom: 0; } .markdown-body p { margin: 0 0 0.75em; } .markdown-body ul, .markdown-body ol { margin: 0 0 0.75em; padding-left: 1.25em; } .markdown-body li { margin: 0.25em 0; } .markdown-body pre { margin: 0.75em 0; padding: 0.9em 1rem; border-radius: 1rem; background: #0f172a; color: #e2e8f0; overflow-x: auto; } .markdown-body code { padding: 0.15em 0.4em; border-radius: 0.5em; background: rgba(15, 23, 42, 0.12); font-size: 0.9em; } .user-bubble .markdown-body code { background: rgba(255, 255, 255, 0.25); color: #f8fafc; } .user-bubble .markdown-body pre { background: rgba(15, 23, 42, 0.18); color: #f8fafc; } .markdown-body table { width: 100%; border-collapse: collapse; margin: 0.75em 0; } .markdown-body th, .markdown-body td { border: 1px solid rgba(15, 23, 42, 0.1); padding: 0.5em 0.75em; text-align: left; } .markdown-body blockquote { border-left: 4px solid rgba(99, 102, 241, 0.3); margin: 0.75em 0; padding-left: 1em; color: #64748b; font-style: italic; } .markdown-body a { color: #4a5bff; text-decoration: underline; text-underline-offset: 3px; } .think-block { background: rgba(148, 163, 184, 0.15); border: 1px dashed rgba(148, 163, 184, 0.45); } .think-block code { background: rgba(148, 163, 184, 0.25); color: #475569; } 会话 DeepSeek AI 助手 新建聊天 推理模型 deepseek-r1:1.5b 当前部署固定使用 deepseek-r1:1.5b，如需调整请联系运维。 暂无聊天，会话列表会展示最近的对话 知识标签 刷新 默认知识库 知识库上传 点击打开上传面板 上传文档可以丰富知识库，支持 PDF、Word、Markdown 等常见格式。 当前会话 加载中... 默认知识库 开始新的对话吧 输入问题或上传资料，DeepSeek 将实时生成答案。 按 Ctrl / ⌘ + Enter 发送 生成中... 发送 知识库 上传文档 知识库名称 选择文件 点击选择文件或将文件拖拽到此区域 支持格式：pdf, docx, doc, xls, xlsx, ppt, pptx, md, txt, sql 等 取消 开始上传 document.addEventListener('DOMContentLoaded', () => { const state = { chats: [], activeChatId: null, streaming: false, eventSource: null, chatIndex: 1, openMenuChatId: null, uploadFiles: [], inputHistory: [], historyIndex: -1, autoScroll: true }; const selectors = { chatList: document.getElementById('chatList'), emptyChatHint: document.getElementById('emptyChatHint'), newChatBtn: document.getElementById('newChatBtn'), chatListSection: document.getElementById('chatListSection'), chatListToggle: document.getElementById('chatListToggle'), chatListToggleIcon: document.getElementById('chatListToggleIcon'), modelSelect: document.getElementById('modelSelect'), ragTagBadge: document.getElementById('ragTagBadge'), ragTagSelect: document.getElementById('ragTagSelect'), refreshTagsBtn: document.getElementById('refreshTagsBtn'), activeChatTitle: document.getElementById('activeChatTitle'), messageList: document.getElementById('messageList'), messageTemplate: document.getElementById('messageTemplate'), messageInput: document.getElementById('messageInput'), sendBtn: document.getElementById('sendBtn'), conversationEmptyState: document.getElementById('conversationEmptyState'), messagesContainer: document.getElementById('messagesContainer'), streamStatus: document.getElementById('streamStatus'), toastContainer: document.getElementById('toastContainer'), openUploadModalBtn: document.getElementById('openUploadModalBtn'), uploadModal: document.getElementById('uploadModal'), closeUploadModalBtn: document.getElementById('closeUploadModalBtn'), cancelUploadBtn: document.getElementById('cancelUploadBtn'), uploadTagInput: document.getElementById('uploadTagInput'), uploadFileInput: document.getElementById('uploadFileInput'), uploadDropzone: document.getElementById('uploadDropzone'), uploadFileList: document.getElementById('uploadFileList'), startUploadBtn: document.getElementById('startUploadBtn') }; const API_BASE = 'http://localhost:8080/api/v1'; if (window.marked) { marked.setOptions({ breaks: true, gfm: true }); } function renderMarkdown(content) { const source = typeof content === 'string' ? content : ''; if (!source.trim()) { return ''; } try { const html = marked.parse(source); return window.DOMPurify ? DOMPurify.sanitize(html) : html; } catch (error) { console.error('Markdown render error:', error); return window.DOMPurify ? DOMPurify.sanitize(source) : source; } } function enhanceMarkdown(container, role) { if (!container) return; container.querySelectorAll('pre').forEach((pre) => { pre.classList.add('rounded-2xl', 'bg-slate-900', 'text-slate-100', 'px-4', 'py-3', 'overflow-x-auto', 'text-sm'); }); container.querySelectorAll('code').forEach((code) => { if (code.parentElement && code.parentElement.tagName === 'PRE') { return; } if (role === 'user') { code.classList.add('bg-white/20', 'text-white'); } else { code.classList.add('bg-slate-200/70', 'text-slate-900'); } code.classList.add('px-2', 'py-0.5', 'rounded', 'text-[13px]'); }); container.querySelectorAll('p').forEach((p) => p.classList.add('leading-7')); container.querySelectorAll('ul,ol').forEach((list) => { list.classList.add('leading-7', 'pl-5', 'space-y-1'); }); container.querySelectorAll('li').forEach((li) => li.classList.add('leading-7')); container.querySelectorAll('a').forEach((anchor) => { anchor.classList.add('text-primary-500', 'underline', 'underline-offset-4'); anchor.setAttribute('target', '_blank'); anchor.setAttribute('rel', 'noopener noreferrer'); }); container.querySelectorAll('table').forEach((table) => { table.classList.add('mt-3', 'rounded-xl', 'overflow-hidden'); }); container.querySelectorAll('th,td').forEach((cell) => { cell.classList.add('border', 'border-slate-200/70', 'px-3', 'py-2', 'text-sm'); }); container.querySelectorAll('blockquote').forEach((quote) => { quote.classList.add('border-l-4', 'border-primary-200', 'pl-4', 'text-slate-500', 'italic'); }); } function splitAssistantSegments(text) { const source = typeof text === 'string' ? text : ''; const segments = []; const openTag = ''; const closeTag = ''; let cursor = 0; let inThink = false; while (cursor < source.length) { if (!inThink) { const start = source.indexOf(openTag, cursor); if (start === -1) { segments.push({ type: 'text', content: source.slice(cursor) }); break; } if (start > cursor) { segments.push({ type: 'text', content: source.slice(cursor, start) }); } cursor = start + openTag.length; inThink = true; } else { const end = source.indexOf(closeTag, cursor); if (end === -1) { segments.push({ type: 'think', content: source.slice(cursor) }); cursor = source.length; } else { segments.push({ type: 'think', content: source.slice(cursor, end) }); cursor = end + closeTag.length; inThink = false; } } } return segments.filter((segment) => segment.content && segment.content.length); } function renderMessageContent(message) { const container = message.element; if (!container) return; container.innerHTML = ''; if (message.role === 'assistant') { const segments = splitAssistantSegments(message.rawContent); let displayText = ''; if (!segments.length) { const placeholder = document.createElement('p'); placeholder.className = 'text-sm text-slate-400'; placeholder.textContent = '思考中…'; container.appendChild(placeholder); message.displayText = ''; return; } segments.forEach((segment) => { const trimmed = (segment.content || '').trim(); if (!trimmed) return; if (segment.type === 'think') { const thinkBlock = document.createElement('div'); thinkBlock.className = 'think-block markdown-body rounded-2xl px-3 py-2 text-xs leading-6 text-slate-500 space-y-2'; thinkBlock.innerHTML = renderMarkdown(trimmed); enhanceMarkdown(thinkBlock, 'assistant'); const thinkHeader = document.createElement('div'); thinkHeader.className = 'mb-1 flex items-center gap-2 text-[11px] font-semibold uppercase tracking-[0.2em] text-slate-400'; thinkHeader.innerHTML = '深度思考'; thinkBlock.prepend(thinkHeader); container.appendChild(thinkBlock); } else { const textBlock = document.createElement('div'); textBlock.className = 'markdown-body text-[15px] leading-7 text-slate-700 space-y-3'; const html = renderMarkdown(segment.content); if (html) { textBlock.innerHTML = html; enhanceMarkdown(textBlock, 'assistant'); } else { textBlock.textContent = segment.content; } container.appendChild(textBlock); displayText += `${segment.content} `; } }); if (!container.childElementCount) { const placeholder = document.createElement('p'); placeholder.className = 'text-sm text-slate-400'; placeholder.textContent = '思考中…'; container.appendChild(placeholder); } const normalized = displayText.replace(/\\s+/g, ' ').trim(); message.displayText = normalized || '生成中…'; } else { const textBlock = document.createElement('div'); textBlock.className = 'markdown-body text-[15px] leading-7 space-y-3'; const html = renderMarkdown(message.rawContent); if (html) { textBlock.innerHTML = html; enhanceMarkdown(textBlock, 'user'); } else { textBlock.textContent = message.rawContent || ''; } container.appendChild(textBlock); message.displayText = (message.rawContent || '').replace(/\\s+/g, ' ').trim(); } } function navigateHistory(direction) { if (!state.inputHistory.length) { return; } if (direction === -1) { if (state.historyIndex === -1) { state.historyIndex = state.inputHistory.length - 1; } else { state.historyIndex = Math.max(0, state.historyIndex - 1); } } else if (direction === 1) { if (state.historyIndex === -1) { return; } state.historyIndex = Math.min(state.inputHistory.length, state.historyIndex + 1); if (state.historyIndex === state.inputHistory.length) { state.historyIndex = -1; } } let value = ''; if (state.historyIndex >= 0) { value = state.inputHistory[state.historyIndex] || ''; } selectors.messageInput.value = value; autoResizeTextarea(); requestAnimationFrame(() => { const length = value.length; selectors.messageInput.setSelectionRange(length, length); }); } function createMessage(role, content = '') { const normalized = typeof content === 'string' ? content : ''; return { id: `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`, role, rawContent: normalized, displayText: normalized.replace(/\\s+/g, ' ').trim(), timestamp: new Date(), element: null }; } function getActiveChat() { return state.chats.find((chat) => chat.id === state.activeChatId) || null; } function formatTimestamp(date) { return new Intl.DateTimeFormat('zh-CN', { hour: '2-digit', minute: '2-digit' }).format(date); } function formatSidePreview(chat) { if (!chat.messages.length) return '暂无对话'; const latestUserMessage = [...chat.messages].reverse().find((msg) => msg.role === 'user'); const sourceMessage = latestUserMessage || chat.messages[chat.messages.length - 1]; const baseText = (sourceMessage.displayText || sourceMessage.rawContent || '') .replace(/\\s+/g, ' ') .trim(); if (!baseText) { return sourceMessage.role === 'assistant' ? '生成中…' : '草稿'; } return baseText.slice(0, 26) + (baseText.length > 26 ? '…' : ''); } function showToast(message, tone = 'info') { const colors = { info: 'bg-white border-slate-200 text-slate-600', success: 'bg-green-50 border-green-200 text-green-600', warning: 'bg-amber-50 border-amber-200 text-amber-600', error: 'bg-red-50 border-red-200 text-red-600' }; const toast = document.createElement('div'); toast.className = `border rounded-xl px-4 py-3 shadow-soft text-sm flex items-center gap-2 ${colors[tone] || colors.info}`; toast.innerHTML = `${message}`; selectors.toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => toast.remove(), 300); }, 2600); } function renderChatList() { state.openMenuChatId = null; selectors.chatList.innerHTML = ''; if (!state.chats.length) { selectors.emptyChatHint.classList.remove('hidden'); return; } selectors.emptyChatHint.classList.add('hidden'); state.chats.forEach((chat) => { const item = document.createElement('li'); item.className = 'relative chat-item list-none'; const selectButton = document.createElement('button'); selectButton.type = 'button'; selectButton.className = `w-full text-left rounded-xl border border-transparent px-3 py-2.5 pr-10 transition flex flex-col gap-1 ${chat.id === state.activeChatId ? 'bg-primary-50 border-primary-200 shadow-inner shadow-primary-200/40' : 'bg-white hover:border-slate-200 hover:bg-slate-50'}`; const timestamp = chat.messages.length ? formatTimestamp(chat.messages[chat.messages.length - 1].timestamp) : '--:--'; selectButton.innerHTML = ` ${chat.pinned ? '置顶' : ''} ${chat.title} ${formatSidePreview(chat)} ${timestamp} `; selectButton.addEventListener('click', () => { if (state.activeChatId !== chat.id) { state.activeChatId = chat.id; closeAllMenus(); renderChatList(); renderActiveChat(); } }); const menuButton = document.createElement('button'); menuButton.type = 'button'; menuButton.className = 'absolute top-2.5 right-2.5 rounded-lg p-1.5 text-slate-400 hover:text-slate-600 hover:bg-slate-100'; menuButton.innerHTML = ` `; const menu = document.createElement('div'); menu.dataset.menuFor = chat.id; menu.className = 'chat-menu hidden absolute top-11 right-2 z-30 w-36 rounded-2xl border border-slate-100 bg-white py-1.5 text-sm text-slate-600 shadow-soft/80'; menu.innerHTML = ` 重命名 ${chat.pinned ? '取消置顶' : '置顶'} 删除 `; menuButton.addEventListener('click', (event) => { event.stopPropagation(); toggleChatMenu(chat.id, menu); }); menu.querySelector('[data-action=\"rename\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); renameChat(chat.id); }); menu.querySelector('[data-action=\"pin\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); togglePinChat(chat.id); }); menu.querySelector('[data-action=\"delete\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); deleteChat(chat.id); }); item.appendChild(selectButton); item.appendChild(menuButton); item.appendChild(menu); selectors.chatList.appendChild(item); }); } function closeAllMenus() { selectors.chatList.querySelectorAll('[data-menu-for]').forEach((menu) => menu.classList.add('hidden')); state.openMenuChatId = null; } function toggleChatMenu(chatId, menuElement) { if (state.openMenuChatId === chatId) { closeAllMenus(); } else { closeAllMenus(); menuElement.classList.remove('hidden'); state.openMenuChatId = chatId; } } function reorderChats() { state.chats.sort((a, b) => { if (a.pinned === b.pinned) { return b.createdAt - a.createdAt; } return a.pinned ? -1 : 1; }); } function appendMessageToView(message) { selectors.conversationEmptyState.classList.add('hidden'); const shouldScroll = state.autoScroll || isNearBottom(); const wrapper = document.createElement('div'); wrapper.className = `flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`; const bubble = document.createElement('div'); bubble.className = message.role === 'user' ? 'user-bubble max-w-[85%] rounded-2xl bg-primary-500 text-white px-4 py-3 text-sm leading-7 shadow-soft' : 'assistant-bubble max-w-[85%] rounded-2xl border border-slate-200 bg-white px-4 py-3 text-sm leading-7 text-slate-700 shadow-soft/60'; const meta = document.createElement('div'); meta.className = 'flex items-center gap-2 mb-1 text-[11px] text-slate-400'; meta.innerHTML = `${message.role === 'assistant' ? 'DeepSeek' : '我'}${formatTimestamp(message.timestamp)}`; if (message.role === 'assistant') { meta.querySelector('span').classList.add('text-primary-500'); } const content = document.createElement('div'); content.className = 'message-content space-y-3 text-[15px] leading-7'; message.element = content; bubble.appendChild(meta); bubble.appendChild(content); wrapper.appendChild(bubble); selectors.messageList.appendChild(wrapper); renderMessageContent(message); scrollMessageToBottom(shouldScroll); } function updateActiveBadge(chat) { if (state.activeChatId !== chat.id) return; if (chat.ragTag) { selectors.ragTagBadge.textContent = chat.ragTag; selectors.ragTagBadge.classList.remove('hidden'); } else { selectors.ragTagBadge.classList.add('hidden'); } } function refreshMessageView(chat) { selectors.messageList.innerHTML = ''; if (!chat.messages.length) { selectors.conversationEmptyState.classList.remove('hidden'); return; } selectors.conversationEmptyState.classList.add('hidden'); chat.messages.forEach((msg) => appendMessageToView(msg)); state.autoScroll = true; scrollMessageToBottom(true); } function isNearBottom(threshold = 120) { const el = selectors.messagesContainer; return el.scrollHeight - el.scrollTop - el.clientHeight { selectors.messagesContainer.scrollTop = selectors.messagesContainer.scrollHeight; }); } function renderActiveChat() { const chat = getActiveChat(); if (!chat) { selectors.activeChatTitle.textContent = '暂无会话'; selectors.ragTagBadge.classList.add('hidden'); selectors.conversationEmptyState.classList.remove('hidden'); return; } selectors.activeChatTitle.textContent = chat.title; updateActiveBadge(chat); refreshMessageView(chat); } function setStreaming(isStreaming) { state.streaming = isStreaming; selectors.sendBtn.disabled = isStreaming; selectors.streamStatus.classList.toggle('hidden', !isStreaming); } function buildStreamUrl(message) { const base = API_BASE.replace(/\\/$/, ''); const params = new URLSearchParams({ model: selectors.modelSelect.value, message, ragTag: selectors.ragTagSelect.value || '' }); return `${base}/ollama/generate_stream_rag?${params.toString()}`; } function closeStream() { if (state.eventSource) { state.eventSource.close(); state.eventSource = null; } setStreaming(false); } function updateAssistantMessage(message, delta) { message.rawContent += delta; renderMessageContent(message); const shouldScroll = state.autoScroll || isNearBottom(); scrollMessageToBottom(shouldScroll); } function handleStreamResponse(assistantMessage, data) { let payload; try { payload = JSON.parse(data); } catch (error) { if (data === '[DONE]' || data === '[done]') { closeStream(); } return; } const chunks = Array.isArray(payload) ? payload : [payload]; let needsRefresh = false; let shouldClose = false; chunks.forEach((chunk) => { const result = chunk?.result || chunk?.results?.[0]; if (!result) return; const content = result.output?.content; const finish = result.metadata?.finishReason; if (typeof content === 'string' && content.length) { updateAssistantMessage(assistantMessage, content); needsRefresh = true; } if (finish && finish.toUpperCase() === 'STOP') { shouldClose = true; } }); if (shouldClose) { closeStream(); } if (needsRefresh || shouldClose) { renderChatList(); } } function handleSendMessage() { const text = selectors.messageInput.value.trim(); if (!text || state.streaming) { return; } const chat = getActiveChat(); if (!chat) { showToast('请先创建一个会话', 'warning'); return; } closeStream(); if (!state.inputHistory.length || state.inputHistory[state.inputHistory.length - 1] !== text) { state.inputHistory.push(text); } state.historyIndex = -1; chat.ragTag = selectors.ragTagSelect.value || ''; updateActiveBadge(chat); const userMessage = createMessage('user', text); chat.messages.push(userMessage); state.autoScroll = true; appendMessageToView(userMessage); renderChatList(); selectors.messageInput.value = ''; autoResizeTextarea(); const assistantMessage = createMessage('assistant', ''); chat.messages.push(assistantMessage); appendMessageToView(assistantMessage); renderChatList(); const streamUrl = buildStreamUrl(text); try { const eventSource = new EventSource(streamUrl); state.eventSource = eventSource; setStreaming(true); eventSource.onmessage = (event) => { if (!event.data) return; handleStreamResponse(assistantMessage, event.data); }; eventSource.onerror = () => { console.warn('Stream interrupted, closing connection'); closeStream(); }; } catch (error) { showToast('连接服务失败，请检查接口配置', 'error'); closeStream(); console.error(error); } } function createNewChat() { const chat = { id: `chat-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`, title: `新建聊天 ${state.chatIndex++}`, messages: [], ragTag: selectors.ragTagSelect.value || '', pinned: false, createdAt: Date.now() }; state.chats.unshift(chat); reorderChats(); state.activeChatId = chat.id; renderChatList(); renderActiveChat(); showToast('已创建新的会话', 'success'); } function renameChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; const value = prompt('请输入新的会话名称', chat.title); if (value && value.trim().length) { chat.title = value.trim(); renderChatList(); renderActiveChat(); showToast('会话已重命名', 'success'); } } function togglePinChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; closeAllMenus(); chat.pinned = !chat.pinned; reorderChats(); renderChatList(); renderActiveChat(); showToast(chat.pinned ? '会话已置顶' : '已取消置顶', 'info'); } function deleteChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; if (!confirm(`确认删除会话「${chat.title}」吗？`)) return; closeAllMenus(); const index = state.chats.findIndex((item) => item.id === chat.id); if (index > -1) { state.chats.splice(index, 1); } if (state.chats.length) { state.activeChatId = state.chats[Math.min(index, state.chats.length - 1)].id; } else { state.activeChatId = null; selectors.messageList.innerHTML = ''; selectors.conversationEmptyState.classList.remove('hidden'); } renderChatList(); renderActiveChat(); showToast('会话已删除', 'info'); } function autoResizeTextarea() { const textarea = selectors.messageInput; textarea.style.height = 'auto'; textarea.style.height = Math.min(textarea.scrollHeight, 240) + 'px'; } function fetchRagTags() { const base = API_BASE.replace(/\\/$/, ''); fetch(`${base}/rag/query_rag_tag_list`) .then((res) => res.json()) .then((data) => { if (!data || !Array.isArray(data.data)) return; selectors.ragTagSelect.innerHTML = '默认知识库'; data.data.forEach((tag) => { const option = document.createElement('option'); option.value = tag; option.textContent = tag; selectors.ragTagSelect.appendChild(option); }); }) .catch(() => { showToast('无法获取知识标签，请确认服务可用', 'warning'); }); } function uploadFiles() { const ragTag = selectors.uploadTagInput.value.trim(); if (!state.uploadFiles.length) { showToast('请选择需要上传的文件', 'warning'); return; } if (!ragTag) { showToast('请先填写知识库名称', 'warning'); return; } const formData = new FormData(); formData.append('ragTag', ragTag); state.uploadFiles.forEach((file) => formData.append('file', file)); selectors.startUploadBtn.disabled = true; const originalText = selectors.startUploadBtn.textContent; selectors.startUploadBtn.textContent = '上传中...'; fetch(`${API_BASE.replace(/\\/$/, '')}/rag/file/upload`, { method: 'POST', body: formData }) .then((res) => res.json()) .then((data) => { showToast(data?.info || '上传完成', 'success'); fetchRagTags(); closeUploadModal(); resetUploadModal(); }) .catch(() => { showToast('上传失败，请稍后重试', 'error'); }) .finally(() => { selectors.startUploadBtn.disabled = false; selectors.startUploadBtn.textContent = originalText; }); } function formatFileSize(size) { if (size < 1024) return `${size} B`; if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`; if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`; return `${(size / 1024 / 1024 / 1024).toFixed(1)} GB`; } function updateUploadButtonState() { const valid = selectors.uploadTagInput.value.trim().length > 0 && state.uploadFiles.length > 0; selectors.startUploadBtn.disabled = !valid; } function renderUploadFileList() { selectors.uploadFileList.innerHTML = ''; if (!state.uploadFiles.length) { const placeholder = document.createElement('li'); placeholder.className = 'rounded-xl border border-dashed border-slate-200 bg-white px-4 py-3 text-center text-xs text-slate-400'; placeholder.textContent = '尚未选择文件'; selectors.uploadFileList.appendChild(placeholder); updateUploadButtonState(); return; } state.uploadFiles.forEach((file) => { const item = document.createElement('li'); item.className = 'flex items-center justify-between gap-3 rounded-xl border border-slate-200 bg-slate-50 px-4 py-2 text-sm text-slate-600'; item.innerHTML = ` ${file.name} ${formatFileSize(file.size)} `; selectors.uploadFileList.appendChild(item); }); updateUploadButtonState(); } function handleFilesSelected(fileList) { state.uploadFiles = Array.from(fileList || []); renderUploadFileList(); } function resetUploadModal() { selectors.uploadTagInput.value = ''; selectors.uploadFileInput.value = ''; state.uploadFiles = []; renderUploadFileList(); } function openUploadModal() { resetUploadModal(); selectors.uploadModal.classList.remove('hidden'); document.body.classList.add('overflow-hidden'); } function closeUploadModal() { selectors.uploadModal.classList.add('hidden'); document.body.classList.remove('overflow-hidden'); } selectors.newChatBtn.addEventListener('click', createNewChat); selectors.sendBtn.addEventListener('click', handleSendMessage); selectors.refreshTagsBtn.addEventListener('click', fetchRagTags); selectors.openUploadModalBtn.addEventListener('click', openUploadModal); selectors.closeUploadModalBtn.addEventListener('click', () => { closeUploadModal(); resetUploadModal(); }); selectors.cancelUploadBtn.addEventListener('click', (event) => { event.preventDefault(); closeUploadModal(); resetUploadModal(); }); selectors.uploadModal.addEventListener('click', (event) => { if (event.target === selectors.uploadModal) { closeUploadModal(); resetUploadModal(); } }); selectors.uploadTagInput.addEventListener('input', updateUploadButtonState); selectors.uploadDropzone.addEventListener('click', () => selectors.uploadFileInput.click()); selectors.uploadFileInput.addEventListener('change', (event) => handleFilesSelected(event.target.files)); selectors.uploadDropzone.addEventListener('dragover', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.add('border-primary-400', 'bg-primary-50'); }); selectors.uploadDropzone.addEventListener('dragleave', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.remove('border-primary-400', 'bg-primary-50'); }); selectors.uploadDropzone.addEventListener('drop', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.remove('border-primary-400', 'bg-primary-50'); const incomingFiles = Array.from(event.dataTransfer?.files || []); if (!incomingFiles.length) return; if (typeof DataTransfer !== 'undefined') { const dataTransfer = new DataTransfer(); incomingFiles.forEach((file) => dataTransfer.items.add(file)); selectors.uploadFileInput.files = dataTransfer.files; } handleFilesSelected(selectors.uploadFileInput.files?.length ? selectors.uploadFileInput.files : incomingFiles); }); selectors.startUploadBtn.addEventListener('click', uploadFiles); selectors.chatListToggle.addEventListener('click', () => { const hidden = selectors.chatListSection.classList.toggle('hidden'); selectors.chatListToggleIcon.style.transform = hidden ? 'rotate(180deg)' : 'rotate(0deg)'; }); selectors.messageInput.addEventListener('keydown', (event) => { if (event.key === 'ArrowUp') { if (event.target.selectionStart === 0 && event.target.selectionEnd === 0) { event.preventDefault(); navigateHistory(-1); } return; } if (event.key === 'ArrowDown') { const value = event.target.value || ''; if (event.target.selectionStart === value.length && event.target.selectionEnd === value.length) { event.preventDefault(); navigateHistory(1); } return; } if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') { event.preventDefault(); handleSendMessage(); } else if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.metaKey) { event.preventDefault(); handleSendMessage(); } }); selectors.messageInput.addEventListener('input', autoResizeTextarea); selectors.messagesContainer.addEventListener('scroll', () => { state.autoScroll = isNearBottom(); }); window.addEventListener('beforeunload', () => closeStream()); document.addEventListener('click', (event) => { if (!event.target.closest('.chat-item')) { closeAllMenus(); } }); document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && !selectors.uploadModal.classList.contains('hidden')) { closeUploadModal(); resetUploadModal(); } }); fetchRagTags(); createNewChat(); autoResizeTextarea(); renderUploadFileList(); });"}],"posts":[{"title":"小红书日常实习后端一面记录","date":"2025-11-24T16:00:00.000Z","path":"2025/11/25/小红书日常实习一面/","text":"没有自我介绍环节 1. 写了多少算法题？ 2. 手撕，力扣25. K 个一组翻转链表变题 3. 了解instanceof吗？ instanseof是Java的二元运算符，用于测试一个对象是否是一个特定类（或其子类、实现接口）的实例。他与class.isInstanse()方法的功能类似。如果对象是null，会直接返回false。 4. DTO是Integer，VO是int，VO直接dto.getId()有没有问题 可能会出现NPE，也就是著名的NullPointerException。因为Integer是引用类型，有可能为null，给int类型的字段赋值的时候会发生自动拆箱，抛出NullPointerException。 5. 怎么把对象交给IoC管理(就想到了@Bean，面试官有没有不用注解的) 注解 @Component：加到类上，包括@Controller、@Service、@Repository、@Configuration XML applicationContext.xml中通过标签定义Bean。 配置类注册 使用@Configuration配合@Bean，@Bean标记方法 使用 FactoryBean 接口 使用 BeanDefinitionRegistryPostProcessor 通过编程方式动态注册Bean定义 6. 数据库ACID的I是怎么实现的 锁：行锁、间隙锁、临键锁 MVCC：隐藏字段事务ID和回滚指针，ReadView决定可见性 当前读走锁，快照读走MVCC 7. 给个数据表，查找第九万条数据，怎么查 有自增主键且连续：SELECT * FROM t WHERE id &gt;= 90000 ORDER BY id LIMIT 1; 有自增主键：select * from page where id &gt;=(select id from page order by id limit 89999, 1) order by id limit 1; 通用：SELECT * FROM t LIMIT 89999,1; 8. select怎么使用排他锁 1SELECT ... FOR UPDATE 9. select * 查询普通索引的过程 在普通索引的B+树上找到满足条件的索引项。 从索引项中获取主键值。 如果整个记录就包含主键和普通索引的字段，也就是索引覆盖，就可以直接返回结果了，否则会发生回表 回表：根据主键值，回到主键索引（聚簇索引）的B+树上，查找完整的行记录。 10. InnoDB索引的数据结构 B+树 11. 是否了解聚簇索引 聚簇索引就是主键索引，叶子节点是数据页，存放了完整的行记录。 12. 聚簇索引B+树的树高 通常为 2 - 4 层，一页是 16KB。 非叶子节点：一个主键（BigInt）8B + 一个指针 6B，一页可以存放 1170 个索引 叶子节点：假设一行1KB，一页可以放16条记录 两层B+树可以存 1170 * 16 = 18720条 三层B+树可以存 1170 * 1170 * 16 约为 2000w 四层B+树可以存 1170 * 1170 * 1170 * 16 = 250亿 13. in和exists的区别 IN 用于检查左边的表达式是否存在于右边的列表或子查询的结果集中。如果存在，则返回TRUE，否则返回FALSE。 语法结构： 1234567SELECT column_name(s)FROM table_nameWHERE column_name IN (value1, value2, ...);SELECT column_name(s)FROM table_nameWHERE column_name IN (SELECT column_name FROM another_table WHERE condition); EXISTS 用于判断子查询是否至少能返回一行数据。它不关心子查询返回什么数据，只关心是否有结果。如果子查询有结果，则返回TRUE，否则返回FALSE。 语法结构： 123SELECT column_name(s)FROM table_nameWHERE EXISTS (SELECT column_name FROM another_table WHERE condition); 性能差异：在很多情况下，EXISTS 的性能优于 IN，特别是当子查询的表很大时。这是因为EXISTS 一旦找到匹配项就会立即停止查询，而IN可能会扫描整个子查询结果集。 使用场景：如果子查询结果集较小且不频繁变动，IN 可能更直观易懂。而当子查询涉及外部查询的每一行判断，并且子查询的效率较高时，EXISTS 更为合适。 NULL值处理：IN 能够正确处理子查询中包含NULL值的情况，而EXISTS 不受子查询结果中NULL值的影响，因为它关注的是行的存在性，而不是具体值。 大表驱动小表用 exists，小表驱动大表用 in；MySQL 优化器 8.0 后趋于自动转换。 14. update语句在数据库引擎层的执行过程 从Buffer Pool中找到数据页，如果不在则从磁盘加载。 写undo log，用于事务回滚和MVCC。 修改Buffer Pool中的数据页（此时为脏页）。 写redo log（prepare状态），用于崩溃恢复。 写binlog，用于主从复制和数据恢复。 提交事务，将redo log置为commit状态。 后续由后台线程将脏页刷回磁盘。 刷盘时机： redo log日志即将覆盖 buffer pool内存不足或者脏页比例过高，按照LRU刷盘 后台线程定时刷新 服务器空闲时期 数据库正常关闭 15. 索引失效的场景 对索引列进行函数计算、表达式计算、类型转换。 使用!=、&lt;&gt;、NOT IN、IS NOT NULL，优化器看“过滤比例”，大于阈值就全表。 以通配符开头的LIKE查询，如’%abc’。 复合索引不满足最左前缀原则。 在索引列上使用OR，如果OR的每个条件列都有索引可能会走union，否则容易全表扫描。 数据分布极度不均匀，优化器认为全表扫描更快。 16. 如何看select有没有使用索引，使用什么索引 使用EXPLAIN命令。看key字段显示使用了哪个索引，rows字段表示扫描行数，type字段表示连接类型。 17. explain结果的type字段是什么 type字段：表示访问/连接类型，从好到坏常见的有： null &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL null：查询语句没有表 system：访问系统表 const：通过主键或唯一索引一次就找到。 ref：使用普通索引。 index：用了索引，但还是遍历了全索引树。 ALL：全表扫描，需要优化。 18. 手写一个简单的Result类，用于封装统一返回结果 1234567891011121314151617181920public class Result&lt;T&gt; &#123; private int code; private String msg; private T data; public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; result = new Result&lt;&gt;(); result.setCode(200); result.setMsg(&quot;success&quot;); result.setData(data); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; error( String msg) &#123; Result&lt;T&gt; result = new Result&lt;&gt;(); result.setCode(500); result.setMsg(msg); return result; &#125;&#125; 19. 自己有没有建过表，项目中最熟悉哪张表？ 20. 手写建表语句 1234567891011CREATE TABLE t_order ( id BIGINT PRIMARY KEY AUTO_INCREMENT, order_no VARCHAR(32) NOT NULL UNIQUE, user_id BIGINT NOT NULL, amount DECIMAL(10,2) NOT NULL, status TINYINT NOT NULL DEFAULT 1, create_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, update_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, version INT NOT NULL DEFAULT 1, KEY idx_user (user_id)); 21. 怎么快速给上万个Controller加出参入参的日志 使用Spring AOP，可以定义一个切面，拦截所有Controller方法的调用，并记录入参和出参。 连接点：程序执行过程中能够拦截到的任何一个点，在Spring AOP中指一次方法的执行 切点：大量连接点的表达式筛选 通知：拦截到方法后，代码在何时机被执行 @Before：前置通知 @Around：环绕通知 @AfterReturning：返回通知 @AfterThrowing：异常通知 @After：最终通知 仅需记录/校验入参 → @Before 仅关心成功结果 → @AfterReturning 仅关心异常 → @AfterThrowing 必须同时拿到入参、返回值、异常，或需要改参/改返/重试 → @Around 只做资源清理 → @After 切面：切点+通知打包为一个类 织入：把切面代码混合到原有的业务代码，使用动态代理 22. 了解AOP吗 面向切面编程，将横切关注点（如日志、事务、安全）与核心业务逻辑分离。核心概念有：切面(Aspect)、连接点(Join Point)、通知(Advice)、切点(Pointcut)、织入(Weaving)。 23. 缓存穿透和缓存击穿 穿透：查询一个不存在的数据，缓存和数据库都没有，导致每次请求都打到数据库。解决方案：布隆过滤器、缓存空值。 击穿：一个热点key过期瞬间，大量请求击穿到DB。解决方案：互斥锁（Redis SETNX）、永不过期（逻辑过期）。 雪崩：大量 key 在同一时间集中过期，导致缓存瞬间失效，大量请求全部打到数据库。解决方案：随机过期、多级缓存。 24. 非核心业务场景怎么解决缓存穿透 缓存空对象，并设置一个较短的过期时间（如1-5分钟），防止数据后续被真实写入后仍返回空值。 这里的空对象并非是null，可以是使用包装对象，给业务对象创建包装类，增加标志位。 25. 有一个key的QPS是20万，瓶颈在哪，如何解决 这里的核心瓶颈就是单台Redis服务器的性能瓶颈：CPU（单线程）&gt; 网络瓶颈 &gt; 内存瓶颈 解决方案： 本地缓存：使用Guava Cache 或者 Caffeine，将最热的数据存在JVM Redis集群分片：将这个热点Key分散到不同的Redis节点上 26. 有个评论系统，要求相同的用户短时间内无法发送相同的信息，假如有用户持续发送相同的几万字的文本，如何防止 后端： 对评论使用SHA-256或者MD5求哈希值 以用户ID为key，在Redis中维护一个Set 如果评论已经存在，就拒绝发送，否则就将评论的哈希值存入redis，根据业务需要设置过期时间 27. redis的key的维度，是用户维度还是业务维度 这题是刚刚题的追问，用户维度，同上 28. 数据库和缓存的一致性（这里答了延迟双删，追问，答监听binlog，说生产不用，继续追问） 延迟双删：先删缓存，再更新数据库，延迟后再删缓存 先更新数据库，然后监听binlog-&gt;异步消息-&gt;删缓存 先更新数据库，然后发送mq消息，mq接收到消息后，异步删除缓存，删除失败可重试 先更新数据库，再删除缓存的问题就是：如果A线程更新数据库的时候，缓存恰好过期了，B线程进入数据库读取数据。 这样会产生短暂的不一致：A更新完数据库，还未更新缓存。 如果B在A删除缓存后，又写入了缓存，又会产生短暂的不一致。但是一般读操作比写操作快，发生概率很低。 但是，如果更新数据库成功，但是删除缓存失败了，就会导致不一致，就需要用mq或者监听binlog的方式重试。 29. redis宕机了怎么办（答了个有日志，面试官说生产不用，不知道这里是不是答RDB） 持久化：RDB快照 + AOF日志 高可用：主从复制 + 哨兵模式 30. 反问","tags":[{"name":"小红书","slug":"小红书","permalink":"https://www.zhazhabear.site/tags/%E5%B0%8F%E7%BA%A2%E4%B9%A6/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"面经","slug":"面经","permalink":"https://www.zhazhabear.site/tags/%E9%9D%A2%E7%BB%8F/"}],"categories":[{"name":"面经","slug":"面经","permalink":"https://www.zhazhabear.site/categories/%E9%9D%A2%E7%BB%8F/"}]}],"categories":[{"name":"面经","slug":"面经","permalink":"https://www.zhazhabear.site/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"小红书","slug":"小红书","permalink":"https://www.zhazhabear.site/tags/%E5%B0%8F%E7%BA%A2%E4%B9%A6/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"面经","slug":"面经","permalink":"https://www.zhazhabear.site/tags/%E9%9D%A2%E7%BB%8F/"}]}