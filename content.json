{"pages":[{"title":"分类","date":"2025-10-16T16:00:00.000Z","path":"categories/index.html","text":""},{"title":"","date":"2025-10-18T14:17:41.739Z","path":"downloads/OllamaRAGInterface.html","text":"DeepSeek AI 助手 tailwind.config = { theme: { extend: { colors: { primary: { 50: '#f5f9ff', 100: '#eaf0ff', 200: '#d7e1ff', 300: '#b9c9ff', 400: '#94a6ff', 500: '#6c7fff', 600: '#4a5bff', 700: '#373fe5', 800: '#2b31b4', 900: '#252c8d' } }, boxShadow: { soft: '0 20px 45px -24px rgba(15,23,42,0.35)' } } } } html, body { height: 100%; } .markdown-body { font-size: 15px; line-height: 1.75; color: inherit; } .markdown-body>*:last-child { margin-bottom: 0; } .markdown-body p { margin: 0 0 0.75em; } .markdown-body ul, .markdown-body ol { margin: 0 0 0.75em; padding-left: 1.25em; } .markdown-body li { margin: 0.25em 0; } .markdown-body pre { margin: 0.75em 0; padding: 0.9em 1rem; border-radius: 1rem; background: #0f172a; color: #e2e8f0; overflow-x: auto; } .markdown-body code { padding: 0.15em 0.4em; border-radius: 0.5em; background: rgba(15, 23, 42, 0.12); font-size: 0.9em; } .user-bubble .markdown-body code { background: rgba(255, 255, 255, 0.25); color: #f8fafc; } .user-bubble .markdown-body pre { background: rgba(15, 23, 42, 0.18); color: #f8fafc; } .markdown-body table { width: 100%; border-collapse: collapse; margin: 0.75em 0; } .markdown-body th, .markdown-body td { border: 1px solid rgba(15, 23, 42, 0.1); padding: 0.5em 0.75em; text-align: left; } .markdown-body blockquote { border-left: 4px solid rgba(99, 102, 241, 0.3); margin: 0.75em 0; padding-left: 1em; color: #64748b; font-style: italic; } .markdown-body a { color: #4a5bff; text-decoration: underline; text-underline-offset: 3px; } .think-block { background: rgba(148, 163, 184, 0.15); border: 1px dashed rgba(148, 163, 184, 0.45); } .think-block code { background: rgba(148, 163, 184, 0.25); color: #475569; } 会话 DeepSeek AI 助手 新建聊天 推理模型 deepseek-r1:1.5b 当前部署固定使用 deepseek-r1:1.5b，如需调整请联系运维。 暂无聊天，会话列表会展示最近的对话 知识标签 刷新 默认知识库 知识库上传 点击打开上传面板 上传文档可以丰富知识库，支持 PDF、Word、Markdown 等常见格式。 当前会话 加载中... 默认知识库 开始新的对话吧 输入问题或上传资料，DeepSeek 将实时生成答案。 按 Ctrl / ⌘ + Enter 发送 生成中... 发送 知识库 上传文档 知识库名称 选择文件 点击选择文件或将文件拖拽到此区域 支持格式：pdf, docx, doc, xls, xlsx, ppt, pptx, md, txt, sql 等 取消 开始上传 document.addEventListener('DOMContentLoaded', () => { const state = { chats: [], activeChatId: null, streaming: false, eventSource: null, chatIndex: 1, openMenuChatId: null, uploadFiles: [], inputHistory: [], historyIndex: -1, autoScroll: true }; const selectors = { chatList: document.getElementById('chatList'), emptyChatHint: document.getElementById('emptyChatHint'), newChatBtn: document.getElementById('newChatBtn'), chatListSection: document.getElementById('chatListSection'), chatListToggle: document.getElementById('chatListToggle'), chatListToggleIcon: document.getElementById('chatListToggleIcon'), modelSelect: document.getElementById('modelSelect'), ragTagBadge: document.getElementById('ragTagBadge'), ragTagSelect: document.getElementById('ragTagSelect'), refreshTagsBtn: document.getElementById('refreshTagsBtn'), activeChatTitle: document.getElementById('activeChatTitle'), messageList: document.getElementById('messageList'), messageTemplate: document.getElementById('messageTemplate'), messageInput: document.getElementById('messageInput'), sendBtn: document.getElementById('sendBtn'), conversationEmptyState: document.getElementById('conversationEmptyState'), messagesContainer: document.getElementById('messagesContainer'), streamStatus: document.getElementById('streamStatus'), toastContainer: document.getElementById('toastContainer'), openUploadModalBtn: document.getElementById('openUploadModalBtn'), uploadModal: document.getElementById('uploadModal'), closeUploadModalBtn: document.getElementById('closeUploadModalBtn'), cancelUploadBtn: document.getElementById('cancelUploadBtn'), uploadTagInput: document.getElementById('uploadTagInput'), uploadFileInput: document.getElementById('uploadFileInput'), uploadDropzone: document.getElementById('uploadDropzone'), uploadFileList: document.getElementById('uploadFileList'), startUploadBtn: document.getElementById('startUploadBtn') }; const API_BASE = 'http://localhost:8080/api/v1'; if (window.marked) { marked.setOptions({ breaks: true, gfm: true }); } function renderMarkdown(content) { const source = typeof content === 'string' ? content : ''; if (!source.trim()) { return ''; } try { const html = marked.parse(source); return window.DOMPurify ? DOMPurify.sanitize(html) : html; } catch (error) { console.error('Markdown render error:', error); return window.DOMPurify ? DOMPurify.sanitize(source) : source; } } function enhanceMarkdown(container, role) { if (!container) return; container.querySelectorAll('pre').forEach((pre) => { pre.classList.add('rounded-2xl', 'bg-slate-900', 'text-slate-100', 'px-4', 'py-3', 'overflow-x-auto', 'text-sm'); }); container.querySelectorAll('code').forEach((code) => { if (code.parentElement && code.parentElement.tagName === 'PRE') { return; } if (role === 'user') { code.classList.add('bg-white/20', 'text-white'); } else { code.classList.add('bg-slate-200/70', 'text-slate-900'); } code.classList.add('px-2', 'py-0.5', 'rounded', 'text-[13px]'); }); container.querySelectorAll('p').forEach((p) => p.classList.add('leading-7')); container.querySelectorAll('ul,ol').forEach((list) => { list.classList.add('leading-7', 'pl-5', 'space-y-1'); }); container.querySelectorAll('li').forEach((li) => li.classList.add('leading-7')); container.querySelectorAll('a').forEach((anchor) => { anchor.classList.add('text-primary-500', 'underline', 'underline-offset-4'); anchor.setAttribute('target', '_blank'); anchor.setAttribute('rel', 'noopener noreferrer'); }); container.querySelectorAll('table').forEach((table) => { table.classList.add('mt-3', 'rounded-xl', 'overflow-hidden'); }); container.querySelectorAll('th,td').forEach((cell) => { cell.classList.add('border', 'border-slate-200/70', 'px-3', 'py-2', 'text-sm'); }); container.querySelectorAll('blockquote').forEach((quote) => { quote.classList.add('border-l-4', 'border-primary-200', 'pl-4', 'text-slate-500', 'italic'); }); } function splitAssistantSegments(text) { const source = typeof text === 'string' ? text : ''; const segments = []; const openTag = ''; const closeTag = ''; let cursor = 0; let inThink = false; while (cursor < source.length) { if (!inThink) { const start = source.indexOf(openTag, cursor); if (start === -1) { segments.push({ type: 'text', content: source.slice(cursor) }); break; } if (start > cursor) { segments.push({ type: 'text', content: source.slice(cursor, start) }); } cursor = start + openTag.length; inThink = true; } else { const end = source.indexOf(closeTag, cursor); if (end === -1) { segments.push({ type: 'think', content: source.slice(cursor) }); cursor = source.length; } else { segments.push({ type: 'think', content: source.slice(cursor, end) }); cursor = end + closeTag.length; inThink = false; } } } return segments.filter((segment) => segment.content && segment.content.length); } function renderMessageContent(message) { const container = message.element; if (!container) return; container.innerHTML = ''; if (message.role === 'assistant') { const segments = splitAssistantSegments(message.rawContent); let displayText = ''; if (!segments.length) { const placeholder = document.createElement('p'); placeholder.className = 'text-sm text-slate-400'; placeholder.textContent = '思考中…'; container.appendChild(placeholder); message.displayText = ''; return; } segments.forEach((segment) => { const trimmed = (segment.content || '').trim(); if (!trimmed) return; if (segment.type === 'think') { const thinkBlock = document.createElement('div'); thinkBlock.className = 'think-block markdown-body rounded-2xl px-3 py-2 text-xs leading-6 text-slate-500 space-y-2'; thinkBlock.innerHTML = renderMarkdown(trimmed); enhanceMarkdown(thinkBlock, 'assistant'); const thinkHeader = document.createElement('div'); thinkHeader.className = 'mb-1 flex items-center gap-2 text-[11px] font-semibold uppercase tracking-[0.2em] text-slate-400'; thinkHeader.innerHTML = '深度思考'; thinkBlock.prepend(thinkHeader); container.appendChild(thinkBlock); } else { const textBlock = document.createElement('div'); textBlock.className = 'markdown-body text-[15px] leading-7 text-slate-700 space-y-3'; const html = renderMarkdown(segment.content); if (html) { textBlock.innerHTML = html; enhanceMarkdown(textBlock, 'assistant'); } else { textBlock.textContent = segment.content; } container.appendChild(textBlock); displayText += `${segment.content} `; } }); if (!container.childElementCount) { const placeholder = document.createElement('p'); placeholder.className = 'text-sm text-slate-400'; placeholder.textContent = '思考中…'; container.appendChild(placeholder); } const normalized = displayText.replace(/\\s+/g, ' ').trim(); message.displayText = normalized || '生成中…'; } else { const textBlock = document.createElement('div'); textBlock.className = 'markdown-body text-[15px] leading-7 space-y-3'; const html = renderMarkdown(message.rawContent); if (html) { textBlock.innerHTML = html; enhanceMarkdown(textBlock, 'user'); } else { textBlock.textContent = message.rawContent || ''; } container.appendChild(textBlock); message.displayText = (message.rawContent || '').replace(/\\s+/g, ' ').trim(); } } function navigateHistory(direction) { if (!state.inputHistory.length) { return; } if (direction === -1) { if (state.historyIndex === -1) { state.historyIndex = state.inputHistory.length - 1; } else { state.historyIndex = Math.max(0, state.historyIndex - 1); } } else if (direction === 1) { if (state.historyIndex === -1) { return; } state.historyIndex = Math.min(state.inputHistory.length, state.historyIndex + 1); if (state.historyIndex === state.inputHistory.length) { state.historyIndex = -1; } } let value = ''; if (state.historyIndex >= 0) { value = state.inputHistory[state.historyIndex] || ''; } selectors.messageInput.value = value; autoResizeTextarea(); requestAnimationFrame(() => { const length = value.length; selectors.messageInput.setSelectionRange(length, length); }); } function createMessage(role, content = '') { const normalized = typeof content === 'string' ? content : ''; return { id: `msg-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`, role, rawContent: normalized, displayText: normalized.replace(/\\s+/g, ' ').trim(), timestamp: new Date(), element: null }; } function getActiveChat() { return state.chats.find((chat) => chat.id === state.activeChatId) || null; } function formatTimestamp(date) { return new Intl.DateTimeFormat('zh-CN', { hour: '2-digit', minute: '2-digit' }).format(date); } function formatSidePreview(chat) { if (!chat.messages.length) return '暂无对话'; const latestUserMessage = [...chat.messages].reverse().find((msg) => msg.role === 'user'); const sourceMessage = latestUserMessage || chat.messages[chat.messages.length - 1]; const baseText = (sourceMessage.displayText || sourceMessage.rawContent || '') .replace(/\\s+/g, ' ') .trim(); if (!baseText) { return sourceMessage.role === 'assistant' ? '生成中…' : '草稿'; } return baseText.slice(0, 26) + (baseText.length > 26 ? '…' : ''); } function showToast(message, tone = 'info') { const colors = { info: 'bg-white border-slate-200 text-slate-600', success: 'bg-green-50 border-green-200 text-green-600', warning: 'bg-amber-50 border-amber-200 text-amber-600', error: 'bg-red-50 border-red-200 text-red-600' }; const toast = document.createElement('div'); toast.className = `border rounded-xl px-4 py-3 shadow-soft text-sm flex items-center gap-2 ${colors[tone] || colors.info}`; toast.innerHTML = `${message}`; selectors.toastContainer.appendChild(toast); setTimeout(() => { toast.classList.add('opacity-0', 'translate-y-2'); setTimeout(() => toast.remove(), 300); }, 2600); } function renderChatList() { state.openMenuChatId = null; selectors.chatList.innerHTML = ''; if (!state.chats.length) { selectors.emptyChatHint.classList.remove('hidden'); return; } selectors.emptyChatHint.classList.add('hidden'); state.chats.forEach((chat) => { const item = document.createElement('li'); item.className = 'relative chat-item list-none'; const selectButton = document.createElement('button'); selectButton.type = 'button'; selectButton.className = `w-full text-left rounded-xl border border-transparent px-3 py-2.5 pr-10 transition flex flex-col gap-1 ${chat.id === state.activeChatId ? 'bg-primary-50 border-primary-200 shadow-inner shadow-primary-200/40' : 'bg-white hover:border-slate-200 hover:bg-slate-50'}`; const timestamp = chat.messages.length ? formatTimestamp(chat.messages[chat.messages.length - 1].timestamp) : '--:--'; selectButton.innerHTML = ` ${chat.pinned ? '置顶' : ''} ${chat.title} ${formatSidePreview(chat)} ${timestamp} `; selectButton.addEventListener('click', () => { if (state.activeChatId !== chat.id) { state.activeChatId = chat.id; closeAllMenus(); renderChatList(); renderActiveChat(); } }); const menuButton = document.createElement('button'); menuButton.type = 'button'; menuButton.className = 'absolute top-2.5 right-2.5 rounded-lg p-1.5 text-slate-400 hover:text-slate-600 hover:bg-slate-100'; menuButton.innerHTML = ` `; const menu = document.createElement('div'); menu.dataset.menuFor = chat.id; menu.className = 'chat-menu hidden absolute top-11 right-2 z-30 w-36 rounded-2xl border border-slate-100 bg-white py-1.5 text-sm text-slate-600 shadow-soft/80'; menu.innerHTML = ` 重命名 ${chat.pinned ? '取消置顶' : '置顶'} 删除 `; menuButton.addEventListener('click', (event) => { event.stopPropagation(); toggleChatMenu(chat.id, menu); }); menu.querySelector('[data-action=\"rename\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); renameChat(chat.id); }); menu.querySelector('[data-action=\"pin\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); togglePinChat(chat.id); }); menu.querySelector('[data-action=\"delete\"]').addEventListener('click', (event) => { event.stopPropagation(); closeAllMenus(); deleteChat(chat.id); }); item.appendChild(selectButton); item.appendChild(menuButton); item.appendChild(menu); selectors.chatList.appendChild(item); }); } function closeAllMenus() { selectors.chatList.querySelectorAll('[data-menu-for]').forEach((menu) => menu.classList.add('hidden')); state.openMenuChatId = null; } function toggleChatMenu(chatId, menuElement) { if (state.openMenuChatId === chatId) { closeAllMenus(); } else { closeAllMenus(); menuElement.classList.remove('hidden'); state.openMenuChatId = chatId; } } function reorderChats() { state.chats.sort((a, b) => { if (a.pinned === b.pinned) { return b.createdAt - a.createdAt; } return a.pinned ? -1 : 1; }); } function appendMessageToView(message) { selectors.conversationEmptyState.classList.add('hidden'); const shouldScroll = state.autoScroll || isNearBottom(); const wrapper = document.createElement('div'); wrapper.className = `flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`; const bubble = document.createElement('div'); bubble.className = message.role === 'user' ? 'user-bubble max-w-[85%] rounded-2xl bg-primary-500 text-white px-4 py-3 text-sm leading-7 shadow-soft' : 'assistant-bubble max-w-[85%] rounded-2xl border border-slate-200 bg-white px-4 py-3 text-sm leading-7 text-slate-700 shadow-soft/60'; const meta = document.createElement('div'); meta.className = 'flex items-center gap-2 mb-1 text-[11px] text-slate-400'; meta.innerHTML = `${message.role === 'assistant' ? 'DeepSeek' : '我'}${formatTimestamp(message.timestamp)}`; if (message.role === 'assistant') { meta.querySelector('span').classList.add('text-primary-500'); } const content = document.createElement('div'); content.className = 'message-content space-y-3 text-[15px] leading-7'; message.element = content; bubble.appendChild(meta); bubble.appendChild(content); wrapper.appendChild(bubble); selectors.messageList.appendChild(wrapper); renderMessageContent(message); scrollMessageToBottom(shouldScroll); } function updateActiveBadge(chat) { if (state.activeChatId !== chat.id) return; if (chat.ragTag) { selectors.ragTagBadge.textContent = chat.ragTag; selectors.ragTagBadge.classList.remove('hidden'); } else { selectors.ragTagBadge.classList.add('hidden'); } } function refreshMessageView(chat) { selectors.messageList.innerHTML = ''; if (!chat.messages.length) { selectors.conversationEmptyState.classList.remove('hidden'); return; } selectors.conversationEmptyState.classList.add('hidden'); chat.messages.forEach((msg) => appendMessageToView(msg)); state.autoScroll = true; scrollMessageToBottom(true); } function isNearBottom(threshold = 120) { const el = selectors.messagesContainer; return el.scrollHeight - el.scrollTop - el.clientHeight { selectors.messagesContainer.scrollTop = selectors.messagesContainer.scrollHeight; }); } function renderActiveChat() { const chat = getActiveChat(); if (!chat) { selectors.activeChatTitle.textContent = '暂无会话'; selectors.ragTagBadge.classList.add('hidden'); selectors.conversationEmptyState.classList.remove('hidden'); return; } selectors.activeChatTitle.textContent = chat.title; updateActiveBadge(chat); refreshMessageView(chat); } function setStreaming(isStreaming) { state.streaming = isStreaming; selectors.sendBtn.disabled = isStreaming; selectors.streamStatus.classList.toggle('hidden', !isStreaming); } function buildStreamUrl(message) { const base = API_BASE.replace(/\\/$/, ''); const params = new URLSearchParams({ model: selectors.modelSelect.value, message, ragTag: selectors.ragTagSelect.value || '' }); return `${base}/ollama/generate_stream_rag?${params.toString()}`; } function closeStream() { if (state.eventSource) { state.eventSource.close(); state.eventSource = null; } setStreaming(false); } function updateAssistantMessage(message, delta) { message.rawContent += delta; renderMessageContent(message); const shouldScroll = state.autoScroll || isNearBottom(); scrollMessageToBottom(shouldScroll); } function handleStreamResponse(assistantMessage, data) { let payload; try { payload = JSON.parse(data); } catch (error) { if (data === '[DONE]' || data === '[done]') { closeStream(); } return; } const chunks = Array.isArray(payload) ? payload : [payload]; let needsRefresh = false; let shouldClose = false; chunks.forEach((chunk) => { const result = chunk?.result || chunk?.results?.[0]; if (!result) return; const content = result.output?.content; const finish = result.metadata?.finishReason; if (typeof content === 'string' && content.length) { updateAssistantMessage(assistantMessage, content); needsRefresh = true; } if (finish && finish.toUpperCase() === 'STOP') { shouldClose = true; } }); if (shouldClose) { closeStream(); } if (needsRefresh || shouldClose) { renderChatList(); } } function handleSendMessage() { const text = selectors.messageInput.value.trim(); if (!text || state.streaming) { return; } const chat = getActiveChat(); if (!chat) { showToast('请先创建一个会话', 'warning'); return; } closeStream(); if (!state.inputHistory.length || state.inputHistory[state.inputHistory.length - 1] !== text) { state.inputHistory.push(text); } state.historyIndex = -1; chat.ragTag = selectors.ragTagSelect.value || ''; updateActiveBadge(chat); const userMessage = createMessage('user', text); chat.messages.push(userMessage); state.autoScroll = true; appendMessageToView(userMessage); renderChatList(); selectors.messageInput.value = ''; autoResizeTextarea(); const assistantMessage = createMessage('assistant', ''); chat.messages.push(assistantMessage); appendMessageToView(assistantMessage); renderChatList(); const streamUrl = buildStreamUrl(text); try { const eventSource = new EventSource(streamUrl); state.eventSource = eventSource; setStreaming(true); eventSource.onmessage = (event) => { if (!event.data) return; handleStreamResponse(assistantMessage, event.data); }; eventSource.onerror = () => { console.warn('Stream interrupted, closing connection'); closeStream(); }; } catch (error) { showToast('连接服务失败，请检查接口配置', 'error'); closeStream(); console.error(error); } } function createNewChat() { const chat = { id: `chat-${Date.now()}-${Math.random().toString(36).slice(2, 6)}`, title: `新建聊天 ${state.chatIndex++}`, messages: [], ragTag: selectors.ragTagSelect.value || '', pinned: false, createdAt: Date.now() }; state.chats.unshift(chat); reorderChats(); state.activeChatId = chat.id; renderChatList(); renderActiveChat(); showToast('已创建新的会话', 'success'); } function renameChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; const value = prompt('请输入新的会话名称', chat.title); if (value && value.trim().length) { chat.title = value.trim(); renderChatList(); renderActiveChat(); showToast('会话已重命名', 'success'); } } function togglePinChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; closeAllMenus(); chat.pinned = !chat.pinned; reorderChats(); renderChatList(); renderActiveChat(); showToast(chat.pinned ? '会话已置顶' : '已取消置顶', 'info'); } function deleteChat(chatId) { const chat = state.chats.find((item) => item.id === chatId); if (!chat) return; if (!confirm(`确认删除会话「${chat.title}」吗？`)) return; closeAllMenus(); const index = state.chats.findIndex((item) => item.id === chat.id); if (index > -1) { state.chats.splice(index, 1); } if (state.chats.length) { state.activeChatId = state.chats[Math.min(index, state.chats.length - 1)].id; } else { state.activeChatId = null; selectors.messageList.innerHTML = ''; selectors.conversationEmptyState.classList.remove('hidden'); } renderChatList(); renderActiveChat(); showToast('会话已删除', 'info'); } function autoResizeTextarea() { const textarea = selectors.messageInput; textarea.style.height = 'auto'; textarea.style.height = Math.min(textarea.scrollHeight, 240) + 'px'; } function fetchRagTags() { const base = API_BASE.replace(/\\/$/, ''); fetch(`${base}/rag/query_rag_tag_list`) .then((res) => res.json()) .then((data) => { if (!data || !Array.isArray(data.data)) return; selectors.ragTagSelect.innerHTML = '默认知识库'; data.data.forEach((tag) => { const option = document.createElement('option'); option.value = tag; option.textContent = tag; selectors.ragTagSelect.appendChild(option); }); }) .catch(() => { showToast('无法获取知识标签，请确认服务可用', 'warning'); }); } function uploadFiles() { const ragTag = selectors.uploadTagInput.value.trim(); if (!state.uploadFiles.length) { showToast('请选择需要上传的文件', 'warning'); return; } if (!ragTag) { showToast('请先填写知识库名称', 'warning'); return; } const formData = new FormData(); formData.append('ragTag', ragTag); state.uploadFiles.forEach((file) => formData.append('file', file)); selectors.startUploadBtn.disabled = true; const originalText = selectors.startUploadBtn.textContent; selectors.startUploadBtn.textContent = '上传中...'; fetch(`${API_BASE.replace(/\\/$/, '')}/rag/file/upload`, { method: 'POST', body: formData }) .then((res) => res.json()) .then((data) => { showToast(data?.info || '上传完成', 'success'); fetchRagTags(); closeUploadModal(); resetUploadModal(); }) .catch(() => { showToast('上传失败，请稍后重试', 'error'); }) .finally(() => { selectors.startUploadBtn.disabled = false; selectors.startUploadBtn.textContent = originalText; }); } function formatFileSize(size) { if (size < 1024) return `${size} B`; if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`; if (size < 1024 * 1024 * 1024) return `${(size / 1024 / 1024).toFixed(1)} MB`; return `${(size / 1024 / 1024 / 1024).toFixed(1)} GB`; } function updateUploadButtonState() { const valid = selectors.uploadTagInput.value.trim().length > 0 && state.uploadFiles.length > 0; selectors.startUploadBtn.disabled = !valid; } function renderUploadFileList() { selectors.uploadFileList.innerHTML = ''; if (!state.uploadFiles.length) { const placeholder = document.createElement('li'); placeholder.className = 'rounded-xl border border-dashed border-slate-200 bg-white px-4 py-3 text-center text-xs text-slate-400'; placeholder.textContent = '尚未选择文件'; selectors.uploadFileList.appendChild(placeholder); updateUploadButtonState(); return; } state.uploadFiles.forEach((file) => { const item = document.createElement('li'); item.className = 'flex items-center justify-between gap-3 rounded-xl border border-slate-200 bg-slate-50 px-4 py-2 text-sm text-slate-600'; item.innerHTML = ` ${file.name} ${formatFileSize(file.size)} `; selectors.uploadFileList.appendChild(item); }); updateUploadButtonState(); } function handleFilesSelected(fileList) { state.uploadFiles = Array.from(fileList || []); renderUploadFileList(); } function resetUploadModal() { selectors.uploadTagInput.value = ''; selectors.uploadFileInput.value = ''; state.uploadFiles = []; renderUploadFileList(); } function openUploadModal() { resetUploadModal(); selectors.uploadModal.classList.remove('hidden'); document.body.classList.add('overflow-hidden'); } function closeUploadModal() { selectors.uploadModal.classList.add('hidden'); document.body.classList.remove('overflow-hidden'); } selectors.newChatBtn.addEventListener('click', createNewChat); selectors.sendBtn.addEventListener('click', handleSendMessage); selectors.refreshTagsBtn.addEventListener('click', fetchRagTags); selectors.openUploadModalBtn.addEventListener('click', openUploadModal); selectors.closeUploadModalBtn.addEventListener('click', () => { closeUploadModal(); resetUploadModal(); }); selectors.cancelUploadBtn.addEventListener('click', (event) => { event.preventDefault(); closeUploadModal(); resetUploadModal(); }); selectors.uploadModal.addEventListener('click', (event) => { if (event.target === selectors.uploadModal) { closeUploadModal(); resetUploadModal(); } }); selectors.uploadTagInput.addEventListener('input', updateUploadButtonState); selectors.uploadDropzone.addEventListener('click', () => selectors.uploadFileInput.click()); selectors.uploadFileInput.addEventListener('change', (event) => handleFilesSelected(event.target.files)); selectors.uploadDropzone.addEventListener('dragover', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.add('border-primary-400', 'bg-primary-50'); }); selectors.uploadDropzone.addEventListener('dragleave', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.remove('border-primary-400', 'bg-primary-50'); }); selectors.uploadDropzone.addEventListener('drop', (event) => { event.preventDefault(); selectors.uploadDropzone.classList.remove('border-primary-400', 'bg-primary-50'); const incomingFiles = Array.from(event.dataTransfer?.files || []); if (!incomingFiles.length) return; if (typeof DataTransfer !== 'undefined') { const dataTransfer = new DataTransfer(); incomingFiles.forEach((file) => dataTransfer.items.add(file)); selectors.uploadFileInput.files = dataTransfer.files; } handleFilesSelected(selectors.uploadFileInput.files?.length ? selectors.uploadFileInput.files : incomingFiles); }); selectors.startUploadBtn.addEventListener('click', uploadFiles); selectors.chatListToggle.addEventListener('click', () => { const hidden = selectors.chatListSection.classList.toggle('hidden'); selectors.chatListToggleIcon.style.transform = hidden ? 'rotate(180deg)' : 'rotate(0deg)'; }); selectors.messageInput.addEventListener('keydown', (event) => { if (event.key === 'ArrowUp') { if (event.target.selectionStart === 0 && event.target.selectionEnd === 0) { event.preventDefault(); navigateHistory(-1); } return; } if (event.key === 'ArrowDown') { const value = event.target.value || ''; if (event.target.selectionStart === value.length && event.target.selectionEnd === value.length) { event.preventDefault(); navigateHistory(1); } return; } if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') { event.preventDefault(); handleSendMessage(); } else if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.metaKey) { event.preventDefault(); handleSendMessage(); } }); selectors.messageInput.addEventListener('input', autoResizeTextarea); selectors.messagesContainer.addEventListener('scroll', () => { state.autoScroll = isNearBottom(); }); window.addEventListener('beforeunload', () => closeStream()); document.addEventListener('click', (event) => { if (!event.target.closest('.chat-item')) { closeAllMenus(); } }); document.addEventListener('keydown', (event) => { if (event.key === 'Escape' && !selectors.uploadModal.classList.contains('hidden')) { closeUploadModal(); resetUploadModal(); } }); fetchRagTags(); createNewChat(); autoResizeTextarea(); renderUploadFileList(); });"},{"title":"关于","date":"2025-10-16T16:00:00.000Z","path":"about/index.html","text":"渣渣熊窝"},{"title":"","date":"2025-10-18T14:18:00.595Z","path":"downloads/OllamaStreamGenerateInterface.html","text":"AI Chatbot :root { color-scheme: light; } body.web-page { font-family: 'Inter', 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Microsoft YaHei', sans-serif; background: radial-gradient(circle at 15% 20%, rgba(151, 190, 255, 0.22), transparent 55%), radial-gradient(circle at 85% 10%, rgba(120, 180, 255, 0.18), transparent 50%), linear-gradient(180deg, #F4F7FB 0%, #E3F0FF 100%); min-height: 100vh; color: #1F2430; } .glass-card { backdrop-filter: blur(10px); background: rgba(243, 248, 255, 0.9); border: 1px solid rgba(138, 163, 210, 0.2); box-shadow: 0 16px 36px -24px rgba(34, 61, 120, 0.28); } .signal-gradient { background: linear-gradient(90deg, #5A8DEE 0%, #7AD1F8 100%); } #conversation { max-height: 60vh; } /* Markdown 样式 */ .ai-message pre { background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; font-size: 13px; line-height: 1.4; } .ai-message code { background: #f1f3f4; color: #d73a49; padding: 2px 6px; border-radius: 3px; font-size: 12px; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; } .ai-message pre code { background: transparent; color: inherit; padding: 0; border-radius: 0; } .ai-message h1, .ai-message h2, .ai-message h3 { color: #1f2937; margin: 16px 0 8px 0; font-weight: 600; } .ai-message h1 { font-size: 1.5em; } .ai-message h2 { font-size: 1.25em; } .ai-message h3 { font-size: 1.125em; } .ai-message p { margin: 8px 0; line-height: 1.6; } .ai-message ul, .ai-message ol { margin: 8px 0; padding-left: 24px; } .ai-message li { margin: 4px 0; } .ai-message blockquote { border-left: 4px solid #e5e7eb; padding-left: 16px; margin: 12px 0; color: #6b7280; font-style: italic; } .ai-message table { border-collapse: collapse; margin: 12px 0; width: 100%; } .ai-message th, .ai-message td { border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; } .ai-message th { background: #f9fafb; font-weight: 600; } AI Chatbot Deepseek R1:1.5B 当前模式 普通请求 一次性返回完整消息。 点击底部按钮可切换至流式模式。 查看日志 对话区 用于展示实时的模型回复与用户消息。 还没有消息，输入内容开始对话吧。 切换到流式请求 请求日志 最近活动 清空日志 const DEFAULT_MODEL = 'deepseek-r1:1.5b'; const modeToggle = document.getElementById('modeToggle'); const modeToggleLabel = document.getElementById('modeToggleLabel'); const modeLabel = document.getElementById('modeLabel'); const modeDescription = document.getElementById('modeDescription'); const modeHint = document.getElementById('modeHint'); const logToggle = document.getElementById('logToggle'); const logPanel = document.getElementById('logPanel'); const logClose = document.getElementById('logClose'); const logClear = document.getElementById('logClear'); const logList = document.getElementById('logList'); const messageInput = document.getElementById('messageInput'); const conversation = document.getElementById('conversation'); const chatForm = document.getElementById('chatForm'); const submitButton = chatForm.querySelector('button[type=\"submit\"]'); const modes = { standard: { name: '普通请求', description: '一次性返回完整消息。', hint: '点击底部按钮可切换至流式模式。', toggleText: '切换到流式请求', next: 'stream' }, stream: { name: '流式请求', description: '逐段返回，适合实时展示。', hint: '点击底部按钮可切换至普通模式。', toggleText: '切换到普通请求', next: 'standard' } }; let currentMode = 'standard'; let isRequestPending = false; const logs = []; const sentMessages = []; // 用于存储用户发送的消息 let historyIndex = -1; // 用于追踪历史记录的位置 function updateModeUI() { const { name, description, hint, toggleText } = modes[currentMode]; modeLabel.textContent = name; modeDescription.textContent = description; modeHint.textContent = hint; modeToggleLabel.textContent = toggleText; modeToggle.dataset.mode = currentMode; modeToggle.setAttribute('aria-pressed', currentMode === 'stream'); modeToggle.title = `${name} · ${description}`; } function createMessagePreview(text) { const trimmed = text.replace(/\\s+/g, ' ').trim(); return trimmed.length > 60 ? `${trimmed.slice(0, 60)}…` : trimmed; } function removeEmptyState() { const emptyState = conversation.querySelector('[data-empty-state]'); if (emptyState) { emptyState.remove(); } } function appendUserMessage(text) { const wrapper = document.createElement('div'); wrapper.className = 'flex justify-end'; const bubble = document.createElement('div'); bubble.className = 'max-w-[70%] rounded-3xl bg-sky-100/80 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words'; bubble.textContent = text; wrapper.appendChild(bubble); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; } function appendAssistantMessage(initialText = '模型生成中…') { const wrapper = document.createElement('div'); wrapper.className = 'flex gap-3'; const avatar = document.createElement('div'); avatar.className = 'w-9 h-9 rounded-full signal-gradient text-white flex items-center justify-center shadow-md'; avatar.innerHTML = ''; const body = document.createElement('div'); body.className = 'max-w-[72%] rounded-3xl bg-white/90 border border-slate-200/60 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words ai-message'; const thinkDiv = document.createElement('div'); thinkDiv.className = 'mb-2 text-xs text-slate-400 bg-slate-50/50 px-2 py-1 rounded-lg border-l-2 border-slate-300'; thinkDiv.style.display = 'none'; thinkDiv.innerHTML = '深度思考...'; const contentDiv = document.createElement('div'); contentDiv.textContent = initialText; body.appendChild(thinkDiv); body.appendChild(contentDiv); wrapper.append(avatar, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; return { bubble: body, thinkDiv, contentDiv }; } function appendSystemMessage(text) { const wrapper = document.createElement('div'); wrapper.className = 'flex gap-3'; const badge = document.createElement('div'); badge.className = 'w-9 h-9 rounded-full bg-rose-100 text-rose-500 flex items-center justify-center shadow-sm'; badge.innerHTML = ''; const body = document.createElement('div'); const bubble = document.createElement('div'); bubble.className = 'max-w-[72%] rounded-3xl bg-white border border-rose-200 px-4 py-3 text-sm text-rose-600 leading-relaxed whitespace-pre-wrap break-words'; bubble.textContent = text; body.appendChild(bubble); wrapper.append(badge, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; } function addLog(text) { logs.unshift({ text, timestamp: new Date().toLocaleTimeString() }); if (logs.length > 120) { logs.pop(); } renderLogs(); } function renderLogs() { logList.innerHTML = ''; if (!logs.length) { const emptyItem = document.createElement('li'); emptyItem.className = 'text-slate-400 text-center py-4'; emptyItem.textContent = '暂无日志'; logList.appendChild(emptyItem); return; } logs.forEach(({ text, timestamp }) => { const item = document.createElement('li'); item.className = 'rounded-2xl border border-slate-200/60 bg-white/80 px-3 py-2.5 shadow-sm'; item.innerHTML = ` ${timestamp} ${text} `; logList.appendChild(item); }); } function toggleFormDisabled(disabled) { submitButton.disabled = disabled; messageInput.disabled = disabled; modeToggle.disabled = disabled; submitButton.classList.toggle('opacity-60', disabled); submitButton.classList.toggle('cursor-not-allowed', disabled); messageInput.classList.toggle('opacity-70', disabled); } modeToggle.addEventListener('click', () => { if (isRequestPending) return; currentMode = modes[currentMode].next; updateModeUI(); }); logToggle.addEventListener('click', () => { logPanel.classList.toggle('hidden'); if (!logPanel.classList.contains('hidden')) { renderLogs(); } }); logClose.addEventListener('click', () => { logPanel.classList.add('hidden'); }); logClear.addEventListener('click', () => { logs.length = 0; renderLogs(); }); chatForm.addEventListener('submit', async (event) => { event.preventDefault(); const text = messageInput.value.trim(); if (!text || isRequestPending) { return; } // 添加到历史记录 if (sentMessages[0] !== text) { sentMessages.unshift(text); } historyIndex = -1; // 重置历史记录索引 removeEmptyState(); appendUserMessage(text); messageInput.value = ''; messageInput.focus(); const preview = createMessagePreview(text); addLog(`准备发送 ${modes[currentMode].name}：${preview}`); const aiBubble = appendAssistantMessage(); isRequestPending = true; toggleFormDisabled(true); try { await dispatchRequest(text, aiBubble); } catch (error) { console.error(error); addLog(`${modes[currentMode].name} 请求失败：${error.message}`); appendSystemMessage(`请求失败：${error.message}`); } finally { isRequestPending = false; toggleFormDisabled(false); } }); async function dispatchRequest(message, aiBubble) { const endpoint = currentMode === 'standard' ? 'generate' : 'generate_stream'; const url = `/api/v1/ollama/${endpoint}?model=${encodeURIComponent(DEFAULT_MODEL)}&message=${encodeURIComponent(message)}`; addLog(`请求 URL：${url}`); try { if (currentMode === 'standard') { const { status } = await handleStandardRequest(url, aiBubble); addLog(`普通请求成功 · HTTP ${status}`); } else { const { status } = await handleStreamRequest(url, aiBubble); addLog(`流式请求成功 · HTTP ${status}`); } } catch (error) { aiBubble.contentDiv.innerHTML = marked.parse(`请求失败：${error.message}`); throw error; } } async function handleStandardRequest(url, aiBubble) { const response = await fetch(url); const status = response.status; if (!response.ok) { const errorText = await response.text().catch(() => ''); throw new Error(`HTTP ${status}${errorText ? ` · ${errorText}` : ''}`); } const contentType = response.headers.get('content-type') || ''; let fullText; if (contentType.includes('application/json')) { const data = await response.json(); fullText = extractContent(data); } else { fullText = await response.text(); } // 解析 think 和正文 const thinkMatch = fullText.match(/([\\s\\S]*?)/); const thinkContent = thinkMatch ? thinkMatch[1].trim() : '正在思考中...'; const mainContent = fullText.replace(/[\\s\\S]*?\\s*/, '').trim(); aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考完毕' + thinkContent.replace(/\\n/g, ''); aiBubble.contentDiv.innerHTML = marked.parse(mainContent || '（模型没有返回内容）'); conversation.scrollTop = conversation.scrollHeight; return { status }; } async function handleStreamRequest(url, aiBubble) { const response = await fetch(url); const status = response.status; if (!response.ok) { const errorText = await response.text().catch(() => ''); throw new Error(`HTTP ${status}${errorText ? ` · ${errorText}` : ''}`); } // 重置内容 aiBubble.contentDiv.textContent = ''; aiBubble.thinkDiv.style.display = 'none'; const data = await response.json(); if (Array.isArray(data)) { // 后端返回的是一个完整的JSON数组 let fullText = ''; for (const item of data) { const content = extractContent(item); if (content) { fullText += content; // 直接更新文本内容，不再调用会重新渲染的函数 updateStreamDisplay(fullText, aiBubble, true); } // 添加延迟，模拟流式效果 await new Promise(resolve => setTimeout(resolve, 100)); } } else { // 处理其他可能的JSON结构或错误 const content = extractContent(data); if (content) { updateStreamDisplay(content, aiBubble, false); } else { aiBubble.contentDiv.innerHTML = marked.parse('（模型没有返回有效内容）'); } } return { status }; } // 从单行数据中提取内容 // function extractContentFromLine(line) { ... } // 此函数已不再需要 // 更新流式显示 function updateStreamDisplay(fullText, aiBubble, isStreaming) { // 处理 think 标签 const thinkMatch = fullText.match(/([\\s\\S]*?)(|$)/); if (thinkMatch) { if (!thinkMatch[2]) { // 思考中 const thinkContent = thinkMatch[1]; aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考中...' + thinkContent.replace(/\\n/g, ''); aiBubble.contentDiv.textContent = ''; } else { // 思考完成 const thinkContent = thinkMatch[1].trim(); aiBubble.thinkDiv.style.display = 'block'; aiBubble.thinkDiv.innerHTML = '深度思考完毕' + thinkContent.replace(/\\n/g, ''); // 提取并显示主要内容 const mainContent = fullText.replace(/[\\s\\S]*?\\s*/, '').trim(); aiBubble.contentDiv.innerHTML = marked.parse(mainContent); } } else { // 直接显示主要内容 aiBubble.contentDiv.innerHTML = marked.parse(fullText); } conversation.scrollTop = conversation.scrollHeight; } // 逐字显示内容 // displayContentGradually 函数已完全删除，不再需要 // 处理非流式响应 // async function processCompleteResponse(text, aiBubble) { ... } // 此函数已不再需要 function extractContent(data) { if (!data) return ''; if (typeof data === 'string') return data; const maybeContent = data?.result?.output?.content ?? data?.result?.output?.text ?? data?.output?.content ?? data?.message ?? data?.choices?.[0]?.message?.content ?? data?.results?.[0]?.output?.content; if (Array.isArray(maybeContent)) { return maybeContent.map((item) => { if (typeof item === 'string') return item; if (item?.text) return item.text; return ''; }).join('\\n'); } if (typeof maybeContent === 'object' && maybeContent !== null) { if (maybeContent.text) return maybeContent.text; return ''; } if (maybeContent) { return String(maybeContent); } return ''; } // 初始化界面 updateModeUI(); renderLogs(); messageInput.addEventListener('keydown', (event) => { if (event.key === 'ArrowUp') { event.preventDefault(); if (sentMessages.length > 0 && historyIndex < sentMessages.length - 1) { historyIndex++; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); } } else if (event.key === 'ArrowDown') { event.preventDefault(); if (historyIndex > 0) { historyIndex--; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); } else if (historyIndex"},{"title":"友链","date":"2025-10-16T16:00:00.000Z","path":"links/index.html","text":""},{"title":"标签","date":"2025-10-16T16:00:00.000Z","path":"tags/index.html","text":""},{"title":"项目","date":"2025-10-16T16:00:00.000Z","path":"repository/index.html","text":"仓库列表暂未公开。"}],"posts":[{"title":"Ollama RAG 知识库接口页面对接","date":"2025-10-18T11:23:00.000Z","path":"2025/10/18/OllamaRAG知识库接口页面对接/","text":"本节需求 基于我们要实现对话和知识的上传使用，使用AI工具完成UI页面的实现 效果展示 注意到左下角我们有切换知识库的功能，默认知识库就是普通的流式请求，不会使用rag功能。目前小傅哥的项目中并没有携带rag参数的流式请求接口，因此我们可以自己实现一个： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@RequestMapping(value = &quot;generate_stream_rag&quot;, method = RequestMethod.GET) @Override public Flux&lt;ChatResponse&gt; generateStreamRag(@RequestParam String model, @RequestParam String message, @RequestParam String ragTag) &#123; // 参数验证 if (ragTag == null || ragTag.trim().isEmpty()) &#123; return chatClient.stream(new Prompt(message, OllamaOptions.create().withModel(model))); &#125; String SYSTEM_PROMPT = &quot;&quot;&quot; Use the information from the DOCUMENTS section to provide accurate answers but act as if you knew this information innately. If unsure, simply state that you don&#x27;t know. Another thing you need to note is that your reply must be in Chinese! DOCUMENTS: &#123;documents&#125; &quot;&quot;&quot;; SearchRequest request = SearchRequest.query(message).withTopK(5).withFilterExpression(&quot;knowledge == &#x27;&quot; + ragTag.replace(&quot;&#x27;&quot;, &quot;&#x27;&#x27;&quot;) + &quot;&#x27;&quot;); List&lt;Document&gt; documents = pgVectorStore.similaritySearch(request); // 添加空值检查 String documentsCollectors = documents.stream() .map(Document::getContent) .filter(content -&gt; content != null &amp;&amp; !content.trim().isEmpty()) .collect(Collectors.joining()); // 如果没有找到相关文档，可以调整提示词 if (documentsCollectors.isEmpty()) &#123; SYSTEM_PROMPT = &quot;&quot;&quot; Please answer the user&#x27;s question based on your general knowledge. If you don&#x27;t know the answer, simply state that you don&#x27;t know. Your reply must be in Chinese! &quot;&quot;&quot;; &#125; Message ragMessage = new SystemPromptTemplate(SYSTEM_PROMPT).createMessage(Map.of(&quot;documents&quot;, documentsCollectors)); ArrayList&lt;Message&gt; messages = new ArrayList&lt;&gt;(); messages.add(new UserMessage(message)); messages.add(ragMessage); ChatResponse chatResponse = chatClient.call(new Prompt(messages, OllamaOptions.create().withModel(&quot;deepseek-r1:1.5b&quot;))); return chatClient.stream(new Prompt(messages, OllamaOptions.create().withModel(model))); &#125; 这样就可以灵活切换不同的知识库了！ 下面是一个案例： 使用默认知识库： 他对于大连理工大学软件学院的地址没有一个准确的认知，也有一定的信息错乱。 上传文件： 文件内容包括：大连理工大学软件学院位于图强路321号 使用大连理工大学知识库： 准确回答了大连理工大学软件学院的地址！我们的测试顺利通过！ 完整前端代码 点击这里下载完整 HTML 文件 我们将完整的 HTML 文件提供为下载链接，您可以点击上方链接获取。","tags":[{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama RAG 知识库接口服务实现","date":"2025-10-18T06:33:00.000Z","path":"2025/10/18/OllamaRAG知识库接口服务实现/","text":"本节需求 将 RAG 知识库上传、选择和使用以接口方式提供 功能实现 1. 工程结构 123456789101112131415ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层（服务契约）│ ├── IRAGService.java # RAG 服务接口定义│ └── IAiService.java # AI 服务接口定义├── xfg-dev-tech-app/ # 应用层（启动 + 基础设施装配）│ ├── Application.java # Spring Boot 启动类│ ├── config/│ │ ├── OllamaConfig.java│ │ ├── RedisClientConfig.java│ │ └── RedisClientConfigProperties.java│ └── test/│ └── RagPipelineTest.java # 单元测试└── xfg-dev-tech-trigger/ # 触发器层（对外接口） ├── OllamaController.java # Ollama HTTP控制器 └── RAGController.java # RAG HTTP控制器 2. 依赖管理 trigger模块下引入： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-tika-document-reader&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-pgvector-store&lt;/artifactId&gt;&lt;/dependency&gt; 从这里开始就需要使用Redisson了，需要检查根pom，trigger以及app模块都引入了redisson： 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.44.0&lt;/version&gt;&lt;/dependency&gt; 3. 配置管理 这里需要配置redis的链接地址，IP、端口等信息： 本地： 123456789101112131415# Redis 配置redis: sdk: config: host: localhost port: 6379 password: &lt;你的密码&gt; # 没有就删除这一行 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: true 云服务器： 1234567891011121314# Redis 配置redis: sdk: config: host: &lt;部署了redis的公网IP&gt; port: 16379 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: true 4. 代码实现 Redisson配置(RedisClientConfig.java,RedisClientConfigProperties.java) 如果设置了密码，就把.setPassword(properties.getPassword())的注释取消 12345678910111213141516171819202122232425262728293031323334353637383940package cn.bugstack.xfg.dev.tech.config;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.codec.JsonJacksonCodec;import org.redisson.config.Config;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Redis 客户端，使用 Redisson &lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;Redisson&lt;/a&gt; */@Configuration@EnableConfigurationProperties(RedisClientConfigProperties.class)public class RedisClientConfig &#123; @Bean(&quot;redissonClient&quot;) public RedissonClient redissonClient(ConfigurableApplicationContext applicationContext, RedisClientConfigProperties properties) &#123; Config config = new Config(); config.setCodec(JsonJacksonCodec.INSTANCE); config.useSingleServer() .setAddress(&quot;redis://&quot; + properties.getHost() + &quot;:&quot; + properties.getPort())// .setPassword(properties.getPassword()) .setConnectionPoolSize(properties.getPoolSize()) .setConnectionMinimumIdleSize(properties.getMinIdleSize()) .setIdleConnectionTimeout(properties.getIdleTimeout()) .setConnectTimeout(properties.getConnectTimeout()) .setRetryAttempts(properties.getRetryAttempts()) .setRetryInterval(properties.getRetryInterval()) .setPingConnectionInterval(properties.getPingInterval()) .setKeepAlive(properties.isKeepAlive()) ; return Redisson.create(config); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package cn.bugstack.xfg.dev.tech.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;/** * Redis 连接配置 &lt;a href=&quot;https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter&quot;&gt;redisson-spring-boot-starter&lt;/a&gt; */@Data@ConfigurationProperties(prefix = &quot;redis.sdk.config&quot;, ignoreInvalidFields = true)public class RedisClientConfigProperties &#123; /** host:ip */ private String host; /** 端口 */ private int port; /** 账密 */ private String password; /** 设置连接池的大小，默认为64 */ private int poolSize = 64; /** 设置连接池的最小空闲连接数，默认为10 */ private int minIdleSize = 10; /** 设置连接的最大空闲时间（单位：毫秒），超过该时间的空闲连接将被关闭，默认为10000 */ private int idleTimeout = 10000; /** 设置连接超时时间（单位：毫秒），默认为10000 */ private int connectTimeout = 10000; /** 设置连接重试次数，默认为3 */ private int retryAttempts = 3; /** 设置连接重试的间隔时间（单位：毫秒），默认为1000 */ private int retryInterval = 1000; /** 设置定期检查连接是否可用的时间间隔（单位：毫秒），默认为0，表示不进行定期检查 */ private int pingInterval = 0; /** 设置是否保持长连接，默认为true */ private boolean keepAlive = true;&#125; 统一响应类实现(Response.java) 1234567891011121314151617181920212223242526package cn.bugstack.xfg.dev.tech.api.response;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;/** * @author 渣渣熊 * @description 统一响应类 * @create 2025-10-18 15:25 */@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Response&lt;T&gt; implements Serializable &#123; private String code; private String info; private T data;&#125; RAG服务接口定义(IRAGService.java) 123456789101112131415161718package cn.bugstack.xfg.dev.tech.api;import cn.bugstack.xfg.dev.tech.api.response.Response;import org.springframework.web.multipart.MultipartFile;import java.util.List;/** * @author 渣渣熊 * @description RAG服务接口定义 * @create 2025-10-18 15:24 */public interface IRAGService &#123; Response&lt;List&lt;String&gt;&gt; queryRagTagList(); Response&lt;String&gt; uploadFile(String ragTag, List&lt;MultipartFile&gt; files);&#125; RAG HTTP控制器(RAGController) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package cn.bugstack.xfg.dev.tech.trigger.http;import cn.bugstack.xfg.dev.tech.api.IRAGService;import cn.bugstack.xfg.dev.tech.api.response.Response;import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.redisson.api.RList;import org.redisson.api.RedissonClient;import org.springframework.ai.document.Document;import org.springframework.ai.reader.tika.TikaDocumentReader;import org.springframework.ai.transformer.splitter.TokenTextSplitter;import org.springframework.ai.vectorstore.PgVectorStore;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import java.util.List;/** * @author 渣渣熊 * @description RAG HTTP控制器 * @create 2025-10-18 15:23 */@Slf4j@RestController()@CrossOrigin(&quot;*&quot;)@RequestMapping(&quot;/api/v1/rag/&quot;)public class RAGController implements IRAGService &#123; @Resource private TokenTextSplitter tokenTextSplitter; @Resource private PgVectorStore pgVectorStore; @Resource private RedissonClient redissonClient; @RequestMapping(value = &quot;query_rag_tag_list&quot;, method = RequestMethod.GET) @Override // 从Redis获取所有知识库标签 public Response&lt;List&lt;String&gt;&gt; queryRagTagList() &#123; RList&lt;String&gt; elements = redissonClient.getList(&quot;ragTag&quot;); return Response.&lt;List&lt;String&gt;&gt;builder() .code(&quot;0000&quot;) .info(&quot;调用成功&quot;) .data(elements) .build(); &#125; @RequestMapping(value = &quot;file/upload&quot;, method = RequestMethod.POST, headers = &quot;content-type=multipart/form-data&quot;) @Override public Response&lt;String&gt; uploadFile(@RequestParam String ragTag, @RequestParam(&quot;file&quot;) List&lt;MultipartFile&gt; files) &#123; log.info(&quot;上传知识库开始 &#123;&#125;&quot;, ragTag); for (MultipartFile file : files) &#123; // 1. 文档读取 TikaDocumentReader documentReader = new TikaDocumentReader(file.getResource()); List&lt;Document&gt; documents = documentReader.get(); // 2. 文本分割 List&lt;Document&gt; documentSplitterList = tokenTextSplitter.apply(documents); // 3. 添加知识库标签元数据 documents.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, ragTag)); documentSplitterList.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, ragTag)); // 4. 向量化存储到PostgreSQL pgVectorStore.accept(documentSplitterList); // 5. 更新标签列表 RList&lt;String&gt; elements = redissonClient.getList(&quot;ragTag&quot;); if (!elements.contains(ragTag))&#123; elements.add(ragTag); &#125; &#125; log.info(&quot;上传知识库完成 &#123;&#125;&quot;, ragTag); return Response.&lt;String&gt;builder().code(&quot;0000&quot;).info(&quot;调用成功&quot;).build(); &#125;&#125; 功能测试 1. 文件上传测试 请求路径：http://localhost:8080/api/v1/rag/file/upload Headers Content-Type:multipart/form-data Body: ragTag:&lt;标签名&gt; file:&lt;文件&gt;（这里要将参数类型也改成file，然后上传文件），这里我写了个test.txt： 显示调用成功！ 2. 获取知识库标签测试 请求路径：http://localhost:8080/api/v1/rag/query_rag_tag_list 可以看到我们刚刚上传的&quot;测试&quot;标签！ redis中也可以查看到标签！","tags":[{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"redis","slug":"redis","permalink":"https://www.zhazhabear.site/tags/redis/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama RAG 知识库上传、解析和验证","date":"2025-10-18T06:16:00.000Z","path":"2025/10/18/OllamaRAG知识库上传、解析和验证/","text":"本节需求 以大模型向量存储的方式，提交本地文件到知识库。并在 AI 对话中增强检索知识库符合 AI 对话内容的资料，合并提交问题。 RAG端到端流程 文件上传与解析：前端/接口上传文件 → 用 TikaDocumentReader 解析为文档 Document。 文本拆分：TokenTextSplitter 拆分文本为片段（按 token/句子/段落等策略）。 文本标记：为每个 Document 片段写入 metadata，如 knowledge: &quot;知识库名称&quot;，用于多库隔离。 向量化存储： 使用 Ollama 的嵌入模型（nomic-embed-text）生成向量。 将片段内容 + metadata + 向量写入 PgVectorStore（PostgreSQL）。 检索增强对话： 问题来临时，基于向量相似度检索最相关的文档片段（TopK、Filter）。 把检索到的片段拼入 System Prompt，再交给聊天模型生成更准确的回答。 功能实现 1. 工程结构 12345678910111213141516171819ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层│ └── IAiService.java # 定义 AI 服务接口，供应用层调用├── xfg-dev-tech-app/ # 应用层│ ├── Application.java # Spring Boot 启动类，应用入口│ ├── config/ # 配置类目录│ │ ├── OllamaConfig.java # 配置 Ollama 嵌入模型与向量存储│ │ ├── RedisClientConfig.java # 配置 Redis 客户端连接│ │ └── RedisClientConfigProperties.java # Redis 客户端属性配置│ └── resources/ # 配置文件目录│ ├── application.yml # 通用配置文件│ ├── application-dev.yml # 开发环境配置文件│ └── logback-spring.xml # 日志配置文件├── xfg-dev-tech-trigger/ # 触发器层│ └── OllamaController.java # HTTP 控制器，处理 Ollama 相关请求└── docs/ # 文档目录 └── dev-ops/ # 运维相关 └── pgvector/sql/ # PostgreSQL 向量扩展脚本 └── init.sql # 初始化 pgvector 扩展 2. 依赖管理 给app模块加入: 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-tika-document-reader&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-pgvector-store-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 分别是用于解析用户上传的文件，提取纯文本内容，以及存储向量化后的文编片段及其元数据。 3. 配置管理 在application.yml种，添加了新的数据库相关配置，以及AI嵌入（Embedding）相关的参数: model: nomic-embed-text 指定使用的嵌入模型为 nomic-embed-text 这个模型专门用于将文本转换为向量表示（嵌入向量） 嵌入向量可以用于语义搜索、文本相似度计算、聚类等任务 options: num-batch: 512 设置批处理大小为 512 表示每次处理文本时，会将文本分成批次，每批包含 512 个token或文本片段 1234567891011121314151617181920212223242526272829303132spring: datasource: driver-class-name: org.postgresql.Driver username: postgres password: postgres url: jdbc:postgresql://&lt;部署了postgresql的公网IP&gt;:15432/ai-rag-knowledge type: com.zaxxer.hikari.HikariDataSource # hikari连接池配置 hikari: #连接池名 pool-name: HikariCP #最小空闲连接数 minimum-idle: 5 # 空闲连接存活最大时间，默认10分钟 idle-timeout: 600000 # 连接池最大连接数，默认是10 maximum-pool-size: 10 # 此属性控制从池返回的连接的默认自动提交行为,默认值：true auto-commit: true # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认30分钟 max-lifetime: 1800000 # 数据库连接超时时间,默认30秒 connection-timeout: 30000 # 连接测试query connection-test-query: SELECT 1 ai: ollama: base-url: http://&lt;部署了ollama的公网IP&gt;:11434 embedding: options: num-batch: 512 model: nomic-embed-text 4. pgvector配置 以下操作均在云服务器实现： 12345678# 进入 vector_db 容器docker exec -it vector_db bash# 连接到 ai-rag-knowledge 数据库psql -U postgres -d ai-rag-knowledge# 在 PostgreSQL 提示符下创建 vector 扩展CREATE EXTENSION IF NOT EXISTS vector; 退出容器： 12ai-rag-knowledge=# \\qroot@6a239908062e:/# exit 5. 代码实现 Ollama 配置类OllamaConfig.java 新增三项配置： TokenTextSplitter：文本分割器 SimpleVectorStore：基于内存的向量数据库 PgVectorStore：基于 PostgreSQL 的向量数据库 123456789101112131415161718@Beanpublic TokenTextSplitter tokenTextSplitter() &#123; return new TokenTextSplitter();&#125;@Beanpublic SimpleVectorStore simpleVectorStore(OllamaApi ollamaApi) &#123; OllamaEmbeddingClient embeddingClient = new OllamaEmbeddingClient(ollamaApi); embeddingClient.withDefaultOptions(OllamaOptions.create().withModel(&quot;nomic-embed-text&quot;)); return new SimpleVectorStore(embeddingClient);&#125;@Beanpublic PgVectorStore pgVectorStore(OllamaApi ollamaApi, JdbcTemplate jdbcTemplate) &#123; OllamaEmbeddingClient embeddingClient = new OllamaEmbeddingClient(ollamaApi); embeddingClient.withDefaultOptions(OllamaOptions.create().withModel(&quot;nomic-embed-text&quot;)); return new PgVectorStore(jdbcTemplate, embeddingClient);&#125; 6. 功能测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.bugstack.xfg.dev.tech.test;import com.alibaba.fastjson.JSON;import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.messages.Message;import org.springframework.ai.chat.messages.UserMessage;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.chat.prompt.SystemPromptTemplate;import org.springframework.ai.document.Document;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaOptions;import org.springframework.ai.reader.tika.TikaDocumentReader;import org.springframework.ai.transformer.splitter.TokenTextSplitter;import org.springframework.ai.vectorstore.PgVectorStore;import org.springframework.ai.vectorstore.SearchRequest;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.stream.Collectors;/** * @author 渣渣熊 * @description RAG功能测试 * @create 2025-10-18 13:32 */@Slf4j@ActiveProfiles(&quot;dev&quot;)@SpringBootTestpublic class RAGTest &#123; @Resource private OllamaChatClient ollamaChatClient; @Resource private TokenTextSplitter tokenTextSplitter; @Resource private PgVectorStore pgVectorStore; @Test public void upload() &#123; // 1. 文本上传并解析 TikaDocumentReader reader = new TikaDocumentReader(&quot;./data/file.text&quot;); List&lt;Document&gt; documents = reader.get(); // 2. 文本拆分 List&lt;Document&gt; documentSplitterList = tokenTextSplitter.apply(documents); // 3. 文本标记 documents.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, &quot;知识库名称&quot;)); documentSplitterList.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, &quot;知识库名称&quot;)); // 4. 向量化存储 pgVectorStore.accept(documentSplitterList); log.info(&quot;上传完成&quot;); &#125; @Test public void chat() &#123; String message = &quot;王大瓜，哪年出生&quot;; String SYSTEM_PROMPT = &quot;&quot;&quot; Use the information from the DOCUMENTS section to provide accurate answers but act as if you knew this information innately. If unsure, simply state that you don&#x27;t know. Another thing you need to note is that your reply must be in Chinese! DOCUMENTS: &#123;documents&#125; &quot;&quot;&quot;; SearchRequest request = SearchRequest.query(message).withTopK(5).withFilterExpression(&quot;knowledge == &#x27;知识库名称&#x27;&quot;); List&lt;Document&gt; documents = pgVectorStore.similaritySearch(request); String documentsCollectors = documents.stream().map(Document::getContent).collect(Collectors.joining()); Message ragMessage = new SystemPromptTemplate(SYSTEM_PROMPT).createMessage(Map.of(&quot;documents&quot;, documentsCollectors)); ArrayList&lt;Message&gt; messages = new ArrayList&lt;&gt;(); messages.add(new UserMessage(message)); messages.add(ragMessage); ChatResponse chatResponse = ollamaChatClient.call(new Prompt(messages, OllamaOptions.create().withModel(&quot;deepseek-r1:1.5b&quot;))); log.info(&quot;测试结果:&#123;&#125;&quot;, JSON.toJSONString(chatResponse)); &#125;&#125; 需要在resource目录下创建data/file.text将相关的资料存入：王大瓜 1990年出生 这时候运行测试，运行结果摘要： 123&quot;output&quot;: &#123; &quot;content&quot;: &quot;你好！根据你提供的信息，王大瓜是1990年出生的。如果你有其他问题或需要帮助，请随时告诉我！&quot;&#125; 可以看到，rag知识库按照预期运行了！","tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://www.zhazhabear.site/tags/PostgreSQL/"},{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama流式应答接口页面对接","date":"2025-10-15T11:31:00.000Z","path":"2025/10/15/Ollama流式应答接口页面对接/","text":"本节需求 实现一款简单的UI界面，与服务端 Ollama DeepSeek AI 进行对接 前端代码 这里直接贴一份我自己和AI多次对话得到的一个效果还不错的HTML 效果展示 支持的功能 普通请求/流式请求切换 用户可通过界面按钮在普通请求（一次性返回完整消息）与流式请求（逐段返回消息）之间切换。 当前模式会在界面顶部显示，并附带简要说明。 聊天记录快捷导航 支持通过键盘的 ↑/↓ 箭头快速切换上一条或下一条用户发言，方便重复发送或修改。 Markdown 格式渲染 服务端返回的消息支持 Markdown 格式，前端会自动解析并渲染，包括代码块、列表、表格等。 深度思考与普通输出区分 模型的“深度思考”状态会以特殊样式（如灰色背景提示框）显示，普通输出则以常规气泡样式展示。 日志功能 提供日志面板，记录用户请求与服务端响应的详细信息，便于调试与问题排查。 日志支持查看、清空等操作，提升开发与测试效率。 具体代码 点击这里下载完整 HTML 文件 我们将完整的 HTML 文件提供为下载链接，您可以点击上方链接获取。","tags":[{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama流式应答接口实现","date":"2025-10-15T07:45:00.000Z","path":"2025/10/15/Ollama流式应答接口实现/","text":"本节需求 引入 Spring AI 框架组件，对接 Ollama DeepSeek 提供服务接口。包括:普通应答接口和流式接口。 普通请求（同步请求） 普通请求是指客户端一次性发送请求，服务端处理完毕后一次性返回完整的结果。 例如： 流式请求 流式请求是指客户端发送请求后，服务端会将结果分批次，逐步推送给客户端，客户端可以边接收边处理。 例如： 功能实现 1. 工程结构 123456789101112131415ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层│ └── IAiService.java # AI 服务接口定义├── xfg-dev-tech-app/ # 应用层│ ├── Application.java # Spring Boot 启动类│ ├── config/ # 配置类│ │ ├── OllamaConfig.java│ │ ├── RedisClientConfig.java│ │ └── RedisClientConfigProperties.java│ └── resources/ # 配置文件│ ├── application.yml│ ├── application-dev.yml│ └── logback-spring.xml└── xfg-dev-tech-trigger/ # 触发器层 └── OllamaController.java # HTTP 控制器 2. 依赖管理 当前步骤需要ollama的依赖，在app模块的POM.xml文件添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama&lt;/artifactId&gt;&lt;/dependency&gt; 3. 配置管理 配置信息需根据开发与部署环境灵活调整。开发过程中，我在 Windows PC 上进行 Java 开发，Ollama 和 DeepSeek 部署于云服务器的 Docker 环境中，配置文件如下所示： application.yml: 123456spring: application: name: ai-rag-knowledge profiles: active: dev application-dev.yml: 12345678910111213141516171819202122232425262728293031server: port: 8080spring: ai: ollama: # 使用云服务器的 Ollama 服务，将 IP 更换为你自己云服务器的公网 IP # 本地部署的就改为localhost:11434 base-url: http://&lt;部署了Ollama的公网IP&gt;:11434# Redis 配置redis: sdk: config: host: localhost port: 6379 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: truelogging: level: root: debug cn.bugstack.xfg.dev.tech: debug config: classpath:logback-spring.xml 其他配置文件暂且不考虑 4. 代码实现 AI服务接口(IAiService.java) 12345678910111213package cn.bugstack.xfg.dev.tech.api;import org.springframework.ai.chat.ChatResponse;import reactor.core.publisher.Flux;public interface IAiService &#123; ChatResponse generate(String model, String message); Flux&lt;ChatResponse&gt; generateStream(String model, String message);&#125; Ollama 配置类 (OllamaConfig.java) 12345678910111213141516171819202122package cn.bugstack.xfg.dev.tech.config;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaApi;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class OllamaConfig &#123; @Bean public OllamaApi ollamaApi(@Value(&quot;$&#123;spring.ai.ollama.base-url&#125;&quot;) String baseUrl) &#123; return new OllamaApi(baseUrl); &#125; @Bean public OllamaChatClient ollamaChatClient(OllamaApi ollamaApi) &#123; return new OllamaChatClient(ollamaApi); &#125;&#125; HTTP 控制器 (OllamaController.java) 123456789101112131415161718192021222324252627282930313233343536373839package cn.bugstack.xfg.dev.tech.trigger.http;import cn.bugstack.xfg.dev.tech.api.IAiService;import jakarta.annotation.Resource;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaOptions;import org.springframework.web.bind.annotation.*;import reactor.core.publisher.Flux;@RestController()@CrossOrigin(&quot;*&quot;)@RequestMapping(&quot;/api/v1/ollama/&quot;)public class OllamaController implements IAiService &#123; @Resource private OllamaChatClient chatClient; /** * 同步调用接口 * curl http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1 */ @RequestMapping(value = &quot;generate&quot;, method = RequestMethod.GET) @Override public ChatResponse generate(@RequestParam String model, @RequestParam String message) &#123; return chatClient.call(new Prompt(message, OllamaOptions.create().withModel(model))); &#125; /** * 流式调用接口 * curl http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=hi */ @RequestMapping(value = &quot;generate_stream&quot;, method = RequestMethod.GET) @Override public Flux&lt;ChatResponse&gt; generateStream(@RequestParam String model, @RequestParam String message) &#123; return chatClient.stream(new Prompt(message, OllamaOptions.create().withModel(model))); &#125;&#125; 启动类 12345678910111213141516package cn.bugstack.xfg.dev.tech;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Configurablepublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 功能测试 1. 普通请求测试 启动项目，确保云服务器的ollama已经启动后，浏览器地址栏输入：http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1，得到结果： 2. 流式请求测试 地址栏输入http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=你好啊 将流式请求的文本拼凑得到的响应结果为： 12345&lt;think&gt;&lt;/think&gt;你好！很高兴见到你，有什么我可以帮忙的吗？无论是问题、建议还是闲聊，我都在这儿呢！😊 小结 本节基于 Spring AI 对接了 Ollama（以 DeepSeek 模型为例），分别实现了普通应答与流式应答两类接口： 如果不能出现最终的响应结果，请依次检查： 云服务器防火墙是否开放11434端口 云服务器中ollama是否成功运行 application-dev.yml中base-url是否更改为云服务器的公网IP application-dev.yml中port是否为8080","tags":[{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"云服务器配置","date":"2025-10-12T13:04:00.000Z","path":"2025/10/12/云服务器配置/","text":"本节需求 购买并初始化云服务器，完成端口放通与 Docker/Compose/Portainer 安装，使用 docker compose 部署 AI Agent 运行所需的组件（Ollama、Redis、向量库），配置 JDK 17 与 Maven，并拉取 DeepSeek R1 1.5B 模型完成联通验证。 云服务要求 AI Agent 至少需要 2C4G 的云服务器。阿里云学生优惠获取的2C2G服务器无法满足性能要求，因此建议购买新的实例以保证模型和服务的稳定运行。 腾讯云 4C4G 实例（79 元/年），性价比较高。参考：腾讯云服务器4C4G 选择Ubuntu 24.04-LTS即可，不需要额外的应用镜像 环境配置 1. 重置密码 这里需要给 root 用户重置密码。 2. 防火墙开放 至少确保下列端口的开放： 3. Termius 安装 Termius 4. Docker 安装 1234567891011121314151617181920212223242526272829# 下载并运行官方安装脚本curl -fsSL https://get.docker.com | sudo shsudo apt updatesudo apt install docker-compose-plugin -y# 检查 Docker 版本docker version# 检查 Docker Compose 版本docker compose version# 创建 Docker 配置目录sudo mkdir -p /etc/docker# 配置镜像加速器（使用腾讯云内网镜像）sudo tee /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;: [ &quot;https://mirror.ccs.tencentyun.com&quot; ]&#125;EOF# 重启 Dockersudo systemctl restart docker# 测试运行一个容器docker run hello-world 如果上述过程没有问题的话，则会显示： 5. AI-Agent 环境配置 创建并切换到 dev-ops 目录： 123cd /mkdir dev-opscd dev-ops 将项目中的 docs 目录下的内容移动至云服务器的 dev-ops 目录下（通过 Termius 的 SFTP）： 然后执行如下命令： 12# 使用 docker compose（注意：部分老命令为 docker-compose）docker compose -f docker-compose-environment-aliyun.yml up -d 即可完成下列组件的安装和配置： 1. Ollama - 大语言模型服务 作用：运行本地化的大语言模型（如 deepseek-r1:1.5b） 用途：提供对话 AI、文本生成、代码解释等 AI 能力 端口：11434 - 可以通过 API 调用模型服务 2. Redis - 缓存和消息队列 作用：高速内存数据库，用作缓存和会话存储 用途：存储用户会话、缓存 AI 响应、临时数据 管理界面：通过 redis-admin 在 8081 端口可视化管理 账密：admin/admin 3. Vector DB - 向量数据库 作用：专门存储和检索向量数据的数据库 用途：存储文档嵌入向量，实现语义搜索、RAG（检索增强生成） 数据库：ai-rag-knowledge 接下来需要完成 Maven，JDK 17 的配置： 1234567891011# 1. 安装 JDK 17 和 Mavensudo apt updatesudo apt install openjdk-17-jdk maven -y# 2. 验证安装java -version # 应该显示 JDK 17mvn -version # 应该显示 Maven 版本# 3. 设置 JAVA_HOMEecho &#x27;export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 6. DeepSeek R1 1.5B 模型安装 1. 安装 portainer 12345678910docker volume create portainer_datadocker run -d \\ -p 9000:9000 \\ -p 9443:9443 \\ --name portainer \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce:latest 防火墙开启 9000 端口 立即访问：&lt;公网IP:9000&gt; 进入 portainer 界面 首次登录需要设置管理员账号的用户名和密码 2. 安装 Deepseek R1 在 portainer 中完成如下操作： 然后 Connect，依次输入如下命令： 12345678# 拉取模型，推荐小一点，够做开发就可以ollama pull deepseek-r1:1.5b# （可选）运行模型，运行后关闭，继续安装模型。Ctrl/Command + Dollama run deepseek-r1:1.5b# 向量文本ollama pull nomic-embed-text 命令执行完毕后，即可与 AI 对话： 输入 /exit 退出对话 3. 通过其他途径访问 1. 可以像小傅哥项目中提到的用 sh 脚本： 1234567curl http://&lt;ipv4地址&gt;:11434/api/generate \\ -H &quot;Content-Type: application/json&quot; \\ -d &#x27;&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;1+1&quot;, &quot;stream&quot;: false &#125;&#x27; 5. 也可以用 apifox 发起请求 Body: 12345&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;你好&quot;, &quot;stream&quot;: false&#125; Headers: 成功响应！","tags":[{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城下单支付","date":"2025-09-15T16:00:00.000Z","path":"2025/09/16/下单支付/","text":"内容概述 下单功能以及支付功能的完整实现 流程图 流程分析 graph TB subgraph \"前端层\" A[用户界面] --> B[HTTP请求] end subgraph \"Web层 (s-pay-mall-web)\" B --> C[AliPayController] C --> D[参数验证] end subgraph \"业务层 (s-pay-mall-service)\" D --> E[OrderServiceImpl] E --> F[ProductRPC] E --> G[支付宝SDK] end subgraph \"数据层 (s-pay-mall-dao)\" E --> H[IOrderDao] H --> I[(MySQL数据库)] end subgraph \"外部系统\" G --> J[支付宝网关] J --> K[支付回调] K --> C end subgraph \"异步处理\" E --> L[EventBus事件总线] L --> M[OrderPaySuccessListener] N[定时任务] --> E end 第一阶段：用户下单请求 输入数据： 12345POST /api/v1/alipay/create_pay_order&#123; &quot;userId&quot;: &quot;10001&quot;, &quot;productId&quot;: &quot;100001&quot;&#125; 处理流程： 前端发送 HTTP POST 请求到AliPayController.createPayOrder() Controller 接收 ShopCartReq 对象，包含用户ID和商品ID 数据流向：前端请求 -&gt; AliPayController -&gt; 参数验证 第二阶段：重复订单检查 输入数据：ShopCartReq对象： 1234public class ShopCartReq &#123; private String userId; private String productId;&#125; 处理流程： OrderServiceImpl.createOrder() 被调用 构造查询条件：创建 PayOrder 对象设置 userId 和 productId 调用 IOrderDao.queryUnPayOrder() 查询数据库 1234567891011121314public class PayOrder &#123; private Long id; private String userId; private String productId; private String productName; private String orderId; private Date orderTime; private BigDecimal totalAmount; private String status; private String payUrl; private Date payTime; private Date createTime; private Date updateTime;&#125; 可能的情况： 返回状态为 PAY_WAIT 的未支付订单 直接返回现有的 PayOrderRes{orderId, payUrl} 流程结束，跳转到返回响应阶段 返回状态为 CREATE 的订单 需要重新创建支付单 调用 doPrepayOrder() 方法创建支付单 跳转到支付单创建阶段 返回 null（无相关订单） 继续执行后续流程 数据流向：OrderServiceImpl -&gt; IOrderDao -&gt; MySQL数据库 -&gt; 返回查询结果 第三阶段：商品信息查询 输入数据：productId（String 类型） 处理流程： 调用 ProductRPC.queryProductByProductId() 这是一个模拟的RPC调用，实际返回固定的商品信息 输出数据： 12345678910public class ProductVO &#123; /** 商品ID */ private String productId; /** 商品名称 */ private String productName; /** 商品描述 */ private String productDesc; /** 商品价格 */ private BigDecimal price;&#125; 数据流向：OrderServiceImpl -&gt; ProductRPC -&gt; 返回ProductVO对象 第四阶段：订单数据持久化 输入数据： userId：用户ID productId：商品ID productName：从ProductVO获取的商品名称 price：从ProductVO获取的商品价格 处理流程： 生成16位随机订单号：RandomStringUtils.randomNumeric(16) 构造 PayOrder 对象： 123456789PayOrder.builder() .userId(&quot;10001&quot;) .productId(&quot;100001&quot;) .productName(&quot;new product&quot;) .orderId(&quot;1234567890123456&quot;) // 16位随机数 .totalAmount(new BigDecimal(&quot;1.68&quot;)) .orderTime(new Date()) .status(&quot;CREATE&quot;) // 使用Constants.OrderStatusEnum.CREATE.getCode() .build() 调用 IOrderDao.insert() 插入数据库 执行SQL：INSERT INTO pay_order(...) VALUES(...) 输出数据： 数据库中新增一条订单记录，状态为 CREATE 数据流向：OrderServiceImpl -&gt; 构造PayOrder对象 -&gt; IOrderDao -&gt; MySQL数据库 第五阶段：支付单创建 输入数据： productId：商品ID productName：商品名称 orderId：订单号 totalAmount：订单金额 处理流程： 调用 doPrepayOrder() 方法 创建支付宝请求对象： 123AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();request.setNotifyUrl(notifyUrl); // 异步回调地址request.setReturnUrl(returnUrl); // 同步跳转地址 构造业务参数： 123456&#123; &quot;out_trade_no&quot;: &quot;1234567890123456&quot;, // 商户订单号 &quot;total_amount&quot;: &quot;1.68&quot;, // 订单金额 &quot;subject&quot;: &quot;new product&quot;, // 订单标题 &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;&#125; 调用支付宝SDK：alipayClient.pageExecute(request).getBody() 输出数据： 支付宝返回HTML表单字符串，包含支付页面的完整HTML代码 数据流向：OrderServiceImpl -&gt; 构造支付宝请求 -&gt; 支付宝SDK -&gt; 支付宝服务器 -&gt; 返回支付表单 第六阶段：更新订单支付信息 输入数据： orderId：订单号 payUrl：支付宝返回的HTML表单 status：新状态 PAY_WAIT 处理流程： 构造更新对象： 1234PayOrder payOrder = new PayOrder();payOrder.setOrderId(&quot;1234567890123456&quot;);payOrder.setPayUrl(&quot;&lt;html&gt;支付表单内容&lt;/html&gt;&quot;);payOrder.setStatus(&quot;PAY_WAIT&quot;); 调用 IOrderDao.updateOrderPayInfo() 执行SQL：UPDATE pay_order SET pay_url = ?, status = ?, update_time = now() WHERE order_id = ? 输出数据： 数据库订单记录更新完成，状态变为 PAY_WAIT，包含支付链接 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第七阶段：返回支付响应 输入数据： orderId：订单号 payUrl：支付链接 处理流程： 构造响应对象： 1234PayOrderRes.builder() .orderId(&quot;1234567890123456&quot;) .payUrl(&quot;&lt;html&gt;支付表单&lt;/html&gt;&quot;) .build() 在Controller层包装成统一响应格式： 12345Response.&lt;String&gt;builder() .code(&quot;0000&quot;) // Constants.ResponseCode.SUCCESS.getCode() .info(&quot;调用成功&quot;) // Constants.ResponseCode.SUCCESS.getInfo() .data(payOrderRes.getPayUrl()) .build() 记录成功日志：“商品下单，根据商品ID创建支付单完成” 输出数据（返回给前端）： 12345&#123; &quot;code&quot;: &quot;0000&quot;, &quot;info&quot;: &quot;调用成功&quot;, &quot;data&quot;: &quot;&lt;html&gt;支付宝支付表单HTML代码&lt;/html&gt;&quot;&#125; 数据流向：OrderServiceImpl -&gt; PayOrderRes -&gt; AliPayController -&gt; Response对象 -&gt; 前端页面 第八阶段：用户支付操作 处理流程： 前端接收到支付表单HTML 用户浏览器渲染支付页面 用户在支付宝页面完成付款操作 支付宝处理支付请求并扣款 数据流向：前端页面 -&gt; 用户操作 -&gt; 支付宝支付页面 -&gt; 支付宝服务器处理 第九阶段：支付回调处理 输入数据（支付宝异步回调）： 1POST /api/v1/alipay/pay_notify 参数包括： trade_status: “TRADE_SUCCESS” out_trade_no: “1234567890123456” (商户订单号) trade_no: “2021081622001234567890123456” (支付宝交易号) total_amount: “1.68” sign: “支付宝RSA256签名” 其他支付宝回调参数… 处理流程： AliPayController.payNotify() 接收回调 交易状态验证：检查 trade_status 是否为 “TRADE_SUCCESS” 签名验证： 123String sign = params.get(&quot;sign&quot;);String content = AlipaySignature.getSignCheckContentV1(params);boolean checkSignature = AlipaySignature.rsa256CheckContent(content, sign, alipayPublicKey, &quot;UTF-8&quot;); 记录回调日志：记录交易名称、状态、支付宝交易号、金额等信息 验证失败的输出： 返回字符串 “false” 给支付宝（拒绝回调） 验证成功继续处理… 数据流向：支付宝服务器 -&gt; AliPayController.payNotify() -&gt; 参数解析和验证 第十阶段：订单状态更新 输入数据： orderId：从回调参数 out_trade_no 获取 处理流程： 调用 OrderServiceImpl.changeOrderPaySuccess() 构造更新对象： 123PayOrder payOrderReq = new PayOrder();payOrderReq.setOrderId(&quot;1234567890123456&quot;);payOrderReq.setStatus(&quot;PAY_SUCCESS&quot;); // Constants.OrderStatusEnum.PAY_SUCCESS.getCode() 调用 IOrderDao.changeOrderPaySuccess() 执行SQL：UPDATE pay_order SET status = ?, pay_time = now(), update_time = now() WHERE order_id = ? 输出数据： 数据库订单状态更新为 PAY_SUCCESS 设置支付时间为当前时间 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第十一阶段：异步事件发布 输入数据： 更新后的 PayOrder 对象 处理流程： 将订单对象序列化为JSON：JSON.toJSONString(payOrderReq) 通过EventBus发布事件：eventBus.post(jsonString) OrderPaySuccessListener.handleEvent() 监听并处理事件 输出数据： 123456&#123; &quot;orderId&quot;: &quot;1234567890123456&quot;, &quot;status&quot;: &quot;PAY_SUCCESS&quot;, &quot;payTime&quot;: &quot;2025-09-16 10:30:00&quot;, &quot;updateTime&quot;: &quot;2025-09-16 10:30:00&quot;&#125; 后续处理： 商品发货逻辑 积分奖励计算 用户通知推送 返利处理等 数据流向：OrderServiceImpl -&gt; EventBus -&gt; OrderPaySuccessListener -&gt; 后续业务处理 第十二阶段：回调响应返回 输出数据： 向支付宝返回字符串 “success”（表示回调处理成功） 记录日志：“支付回调，支付回调，更新订单 {}” 数据流向：AliPayController -&gt; 支付宝服务器（确认回调处理完成） 异步处理机制 定时任务处理 超时关单： TimeoutCloseOrderJob 每10分钟执行一次 查询超过30分钟未支付的订单：queryTimeoutCloseOrderList() 将订单状态更新为 CLOSE 支付状态主动查询： NoPayNotifyOrderJob 每3秒执行一次 查询超过1分钟未支付且未收到回调的订单：queryNoPayNotifyOrder() 主动调用支付宝接口查询订单实际支付状态 若支付成功则更新订单状态为 PAY_SUCCESS 事件监听器 支付成功事件监听： OrderPaySuccessListener 基于Guava EventBus实现 通过@Subscribe注解订阅支付成功事件 接收JSON格式的订单信息 负责处理支付成功后的异步业务逻辑（如商品发货、积分奖励等）","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城前期准备","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/前期准备/","text":"注意：该项目基于jdk1.8 (java8)，务必确认项目的jdk版本 内容概述 小傅哥项目7-11集的内容，包含类设计与流程分析 1.1. Natapp 内网穿透 内网穿透教程 注意事项：Windows端natapp文件夹内一定要有natapp.exe，下图中没有后缀的版本无法运行 1.2. 微信公众号测试平台 微信公众号测试平台申请教程 对接工程项目地址 1.3. 支付宝沙箱 支付宝沙箱申请使用教程 直接看好像并没有找到“沙箱”选项，往下滑动，即可看到“沙箱” 2.1 MVC 工程框架搭建 + 基础配置 + Git 使用 1. 新建项目 使用IDEA新建Spring Boot项目，发现没有Java 8的选项。 原因可以参考这篇博客解决IDEA创建SpringBoot项目没有Java版本8 省流解决方案：将最上方服务器URL改为start.aliyun.com即可解决问题 其他过程略过，如果觉得上述过程麻烦的话，也可以直接clone仓库 s-pay-mall-mvc 注意：不要直接在idea中通过版本控制新建项目 应该用命令行git clone &lt;链接&gt;的方式clone，然后用idea打开文件夹 然后用git将项目还原回历史版本： 2.2 微信公众号鉴权 本节内容：在 mvc 分层框架结构下添加微信公众号鉴权所需的接口，并通过 natapp 内网穿透组件，暴漏本地接口，让微信公众号平台可以配置使用。 1. common模块部分 MessageTextEntity.java 微信消息实体类 严格按照微信公众平台消息格式规范实现 主要用途 ：封装微信公众号消息的数据结构，支持XML与Java对象的相互转换 关键特性 ： 使用@XStreamAlias注解映射微信消息的XML标签 包含微信消息的标准字段：ToUserName、FromUserName、CreateTime、 MsgType、Event、EventKey等 支持文本消息和事件消息的数据结构 微信模板消息文档 在上面7个字段的基础上加上生成带参的二维码所需要的ticket字段，构成了MessageTextEntity 关于@XStreamAlias注解 SignatureUtil.java 微信签名验证工具 按照微信公众平台提供的签名算法实现 主要用途 ：验证请求是否来源于微信服务器，确保通信安全 关键特性 ： 实现了微信要求的SHA-1加密算法 包含字典序排序、字节数组转十六进制字符串等辅助方法 提供 check 方法进行签名验证 什么时候微信服务器会往你的服务器发请求？ 当您在微信公众平台（公众号或小程序）的后台配置了“服务器地址”（URL）并启用后，以下几种典型场景下，微信服务器都会向您的服务器发送请求： 首次验证服务器 场景：您在后台提交您的服务器地址和Token时，微信会立即向该地址发送一个GET请求，包含signature, timestamp, nonce, echostr参数。 目的：就是为了验证“您提供的这个URL背后确实是一个有效的、理解微信协议的服务”。您服务器上的SignatureUtil.check()方法就是用来处理这个请求的。验证通过后，您需要将接收到的echostr参数原样返回给微信。这样，微信才相信您拥有这个服务器，后续才会把重要消息推送给您。 接收用户消息（消息推送） 场景：当用户在您的公众号里发送文字、图片、语音、位置等消息时，微信服务器会将这些消息打包成一个XML格式的POST请求，发送到您的服务器。 目的：让您的服务器能够处理用户消息，实现自动回复、客服等功能。在处理这些POST请求之前，同样需要先用SignatureUtil.check()验证这个POST请求确实来自微信，而不是黑客伪造的。 接收事件推送（事件推送） 场景：当发生某些事件时，微信也会通知您的服务器。例如： 关注/取关：用户关注您的公众号或取消关注。 菜单点击：用户点击了您自定义的菜单按钮。 支付成功：用户在小程序或公众号内完成了支付。 模板消息发送结果：您发送的模板消息是否成功送达。 目的：让您的服务器能够响应这些重要事件，更新用户状态、触发积分发放、更新订单状态等。同样，这些请求也需要验证签名。 XmlUtil.java XML数据处理工具类 根据微信公众平台对XML消息格式的要求实现 主要用途：处理与微信服务器之间的XML数据交互 关键特性 ： 提供 xmlToMap 方法解析微信请求XML 提供 mapToXML 方法构建响应XML 提供 beanToXml 和 xmlToBean 方法实现对象与XML的相互转换 使用XStream和dom4j库进行XML处理 支持CDATA标记的添加，符合微信消息规范 2. web模块部分 WeixinPortalController 微信公众号后台接口控制器，主要用于与微信服务器进行对接，处理微信公众号的消息接收和事件响应。 同时需要在resources/application-dev.yml下修改配置： 12345# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token 如果遇到natapp显示离线状态的情况，也要在web包下的resources/application-dev.yml将port修改为8080","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城登录功能","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/登录功能/","text":"内容概述 登录功能设计实现，以及涉及到的类设计与流程分析 流程分析 小傅哥版本流程图： 简略版本流程图： 核心流程： 用户点击登录，浏览器向服务器请求ticket 服务器检测是否缓存有有效的access token，如果没有则向微信服务器请求(请求需要appid和secret两个参数，这两个参数在微信公众平台可以查看)(生成access token：https://developers.weixin.qq.com/doc/service/guide/dev/api/#生成-Access-Token) 服务器使用access token作为参数调用微信服务器的API 微信服务器返回ticket至服务器 服务器将ticket传回给浏览器 浏览器通过ticket拼接出图片URL(https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=xxx) ，并显示二维码 用户扫描网页的二维码 微信服务器回调配置好的回调地址，通知扫码事件，并在请求中携带ticket与扫码用户的openid 浏览器持续向服务器查询登录状态，参数为ticket 服务器收到轮询后如果发现ticket已经绑定了openid，则生成token并返回给浏览器作为登录凭证 1. 用户点击登录，浏览器向服务器请求ticket 12345678fetch(&#x27;http://localhost:8091/api/v1/login/weixin_qrcode_ticket&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; const ticket = data.data; // ... &#125; &#125;) 2-5. 服务器获取access token并调用微信API获取ticket 12345678910111213141516171819202122232425262728293031@Overridepublic String createQrCodeTicket() throws Exception &#123; // 1. 检查缓存中是否有access token String accessToken = weixinAccessToken.getIfPresent(appid); if (null == accessToken) &#123; // 没有缓存则向微信服务器请求，需要appid和secret参数 Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); assert weixinTokenRes != null; accessToken = weixinTokenRes.getAccess_token(); weixinAccessToken.put(appid, accessToken); &#125; // 2. 使用access token调用微信API生成二维码 WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); // 3. 获取微信返回的ticket Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); assert null != weixinQrCodeRes; // 4. 返回ticket给前端 return weixinQrCodeRes.getTicket();&#125; 6. 浏览器显示二维码 1qrCodeImg.src = https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=$&#123;ticket&#125;; 7-8. 用户扫码与微信服务器回调 12345678910111213141516171819202122@PostMapping(value = &quot;receive&quot;, produces = &quot;application/xml; charset=UTF-8&quot;)public String post(@RequestBody String requestBody, @RequestParam(&quot;signature&quot;) String signature, @RequestParam(&quot;timestamp&quot;) String timestamp, @RequestParam(&quot;nonce&quot;) String nonce, @RequestParam(&quot;openid&quot;) String openid, @RequestParam(name = &quot;encrypt_type&quot;, required = false) String encType, @RequestParam(name = &quot;msg_signature&quot;, required = false) String msgSignature) &#123; try &#123; // 消息转换 MessageTextEntity message = XmlUtil.xmlToBean(requestBody, MessageTextEntity.class); // 处理扫码事件 if (&quot;event&quot;.equals(message.getMsgType()) &amp;&amp; &quot;SCAN&quot;.equals(message.getEvent())) &#123; // 保存登录状态（ticket与openid的绑定） loginService.saveLoginState(message.getTicket(), openid); return buildMessageTextEntity(openid, &quot;登录成功&quot;); &#125; // ... &#125; // ...&#125; 9-10. 浏览器轮询与登录状态验证 12345678910111213141516171819// 前端轮询检查登录状态const intervalId = setInterval(() =&gt; &#123; checkLoginStatus(ticket, intervalId);&#125;, 3000); // 每3秒检查一次function checkLoginStatus(ticket, intervalId) &#123; fetch(`http://localhost:8091/api/v1/login/check_login?ticket=$&#123;ticket&#125;`) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; console.info(&quot;login success&quot;); // 停止轮询 clearInterval(intervalId); // 保存登录 token 到 cookie // ... &#125; &#125;) // ...&#125; 类设计 common模块 Constants 类的作用 定义通用常量：如SPLIT常量用于字符串分割 统一响应码管理：通过ResponseCode枚举定义标准化的API响应码和信息 订单状态管理：通过OrderStatusEnum枚举定义标准化的订单状态流转 注解解析 @AllArgsConstructor 作用：自动生成包含所有字段的构造方法 @NoArgsConstructor 作用：自动生成无参构造方法 @Getter 作用：自动生成所有字段的getter方法 AppException 类的作用：AppException是项目中定义的自定义运行时异常类，主要用于统一管理和处理业务逻辑中的异常情况。定义了两个核心字段 code ：异常码，用于标识不同类型的异常 info ：异常描述信息，提供详细的错误说明 @EqualsAndHashCode(callSuper = true) 作用：主要用于自动生成Java对象的equals()和hashCode()方法，其参数callSuper的作用是：是否调用父类的equals和hashCode方法。默认情况下为 false，即不会调用父类的方法 参考文章 Reponse 类的作用：Response是项目中定义的标准API响应封装类，主要用于统一规范前后端交互的数据格式。包含三个核心字段： code ：响应状态码 info ：响应描述信息 data ：泛型数据字段 @Data 自动生成所有字段的getter和setter方法 自动生成toString()方法，格式化输出对象信息 自动生成equals()和hashCode()方法，支持对象比较 自动生成canEqual()方法，用于判断对象是否为同一类型 @Builder 提供建造者模式的实现，支持链式调用设置属性 生成静态的builder()方法，用于创建Builder实例 生成Builder内部类，包含各个字段的setter方法 特别适合创建属性较多的对象，使代码更简洁、可读性更高 domain模块 domain包包含了以下四类： po/WeixinTemplateMessageVO.java - 微信模板消息值对象 req/WeixinQrCodeReq.java - 微信二维码请求数据封装类 res/WeixinQrCodeRes.java - 微信二维码响应数据封装类 res/WeixinTokenRes.java - 微信AccessToken响应数据封装类 发送模板消息 获取AccessToken 生成带参的二维码 web模块 关于 @configuration：用该注解修饰的类本身也是一个Bean，但它的主要职责是生产其他Bean，里面包含了用于定义和组装Spring容器中Bean的配置信息。 @Configuration和@Component的区别： 关键在于@Configuration使用了CGLIB代理，保证了所有带有@Bean注解的方法都是单例的。 其中Guava在本项目的主要作用是作为本地缓存缓存AccessToken和OpenIdToken，这里也可以用Redis替代。 Retrofit2用于与微信API进行通信。 LoginController 类的作用：LoginController是项目中定义的登录控制器类，主要负责处理用户登录相关的请求。 内有两个方法weixinQrCodeTicket()生成微信二维码，以及checkLogin()用于检查登录状态。 service模块 注意事项 在web包下的application-dev.yml中，增加teplate_id字段： 12345678# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token app-id: #填写你的app-id app-secret: #填写你的app-secret template_id: #填写你的template_id 扩展 将本地缓存Guava修改为Redis 1. 在pom.xml中添加Redis的依赖 这里我们可以选择引入Redis或者直接引入Redisson，这里我们选择Redisson 在web模块下的pom.xml中添加redisson的依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 注意：这里不需要引入版本号，因为根pom已经定义了版本号 2. 在application-dev.yml中添加Redis的配置 注意：如果没有密码务必删除password这行，不然有可能出现连接问题 123456spring: redis: host: 127.0.0.1 port: 6379 password: #这里用你自己的密码，如果没有密码请删除此行 database: 0 3. 定义RedissonConfig配置类 因为我们引入了redisson-spring-boot-starter，Spring Boot会自动帮助我们配置redisson，可以选择不定义RedissonConfig 但是，如果发现在Redis中存的数据出现乱码的情况，可以选择定义RedissonConfig来避免这个问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.bugstack.config;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.codec.JsonJacksonCodec;import org.redisson.config.Config;import org.redisson.config.SingleServerConfig;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.StringUtils;/** * @author 渣渣熊 * @description Redisson配置类 * @create 2025-09-10 17:39 */@Configurationpublic class RedissonConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private String port; @Value(&quot;$&#123;spring.redis.password:&#125;&quot;) private String password; @Bean public RedissonClient redissonClient() &#123; Config config = new Config(); SingleServerConfig serverConfig = config.useSingleServer() .setAddress(&quot;redis://&quot; + host + &quot;:&quot; + port); // 1. 创建自定义 ObjectMapper ObjectMapper mapper = new ObjectMapper(); // 2. 注册Java 8时间模块 mapper.registerModule(new JavaTimeModule()); // 3. 禁用时间戳格式 mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 4. 使用自定义ObjectMapper创建编解码器 config.setCodec(new JsonJacksonCodec(mapper)); if (StringUtils.hasText(password)) &#123; serverConfig.setPassword(password); &#125; return Redisson.create(config); &#125;&#125; 4. 测试Redisson连接 如果前面部分都没有问题，这里的测试类应该也都能顺利通过，测试类应该位于web模块下的test文件夹中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.bugstack.test;import org.junit.jupiter.api.Test;import org.redisson.api.RBucket;import org.redisson.api.RMap;import org.redisson.api.RSet;import org.redisson.api.RedissonClient;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;import static org.junit.jupiter.api.Assertions.*;/** * @author 渣渣熊 * @description 测试 Redisson是否配置成功 * @create 2025-09-09 21：10 */@SpringBootTest@ActiveProfiles(&quot;dev&quot;)public class RedissonTest &#123; @Resource private RedissonClient redissonClient; /** * 测试Redisson连接是否正常 */ @Test public void testConnection() &#123; assertNotNull(redissonClient, &quot;RedissonClient should not be null&quot;); System.out.println(&quot;Redisson连接测试成功！&quot;); &#125; /** * 测试字符串操作 */ @Test public void testStringOperations() &#123; String key = &quot;test:string:key&quot;; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(&quot;Hello Redisson!&quot;); System.out.println(bucket.get()); bucket.delete(); assertNull(redissonClient.getBucket(key).get()); System.out.println(&quot;字符串操作测试成功，并已清理测试数据&quot;); &#125;&#125; 如果两个方法都通过，则可以认为Redisson配置没有问题 5. Redisson代替Guava后的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package cn.bugstack.service.impl;import cn.bugstack.domain.po.WeixinTemplateMessageVO;import cn.bugstack.domain.req.WeixinQrCodeReq;import cn.bugstack.domain.res.WeixinQrCodeRes;import cn.bugstack.domain.res.WeixinTokenRes;import cn.bugstack.service.ILoginService;import cn.bugstack.service.weixin.IWeixinApiService;import org.redisson.api.RBucket;import org.redisson.api.RedissonClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import retrofit2.Call;import javax.annotation.Resource;import java.io.IOException;import java.time.Duration;import java.util.HashMap;import java.util.Map;import static cn.bugstack.common.constants.RedisConstants.*;@Servicepublic class WeixinLoginServiceImpl implements ILoginService &#123; private static final Logger logger = LoggerFactory.getLogger(WeixinLoginServiceImpl.class); @Value(&quot;$&#123;weixin.config.app-id&#125;&quot;) private String appid; @Value(&quot;$&#123;weixin.config.app-secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;weixin.config.template_id&#125;&quot;) private String template_id; @Resource private IWeixinApiService weixinApiService; @Resource private RedissonClient redissonClient; @Override public String createQrCodeTicket() &#123; try &#123; logger.info(&quot;开始创建微信二维码ticket, appid: &#123;&#125;&quot;, appid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 生成 ticket WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); if (weixinQrCodeRes == null || weixinQrCodeRes.getTicket() == null) &#123; throw new RuntimeException(&quot;微信API返回空响应或缺少ticket&quot;); &#125; logger.info(&quot;成功创建微信二维码ticket: &#123;&#125;&quot;, weixinQrCodeRes.getTicket()); return weixinQrCodeRes.getTicket(); &#125; catch (Exception e) &#123; logger.error(&quot;创建微信二维码ticket失败&quot;, e); throw new RuntimeException(&quot;Failed to create QR code ticket&quot;, e); &#125; &#125; @Override public String checkLogin(String ticket) &#123; String key = OPENID_KEY_PREFIX + ticket; String result = redissonClient.&lt;String&gt;getBucket(key).get(); return result != null ? result : &quot;&quot;; &#125; @Override public void saveLoginState(String ticket, String openid) throws IOException &#123; try &#123; String key = OPENID_KEY_PREFIX + ticket; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(openid, Duration.ofHours(OPENID_TTL)); logger.info(&quot;已保存登录状态, ticket: &#123;&#125;, openid: &#123;&#125;&quot;, ticket, openid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 发送模板消息 Map&lt;String, Map&lt;String, String&gt;&gt; data = new HashMap&lt;&gt;(); WeixinTemplateMessageVO.put(data, WeixinTemplateMessageVO.TemplateKey.USER, openid); WeixinTemplateMessageVO templateMessageDTO = new WeixinTemplateMessageVO(openid, template_id); templateMessageDTO.setUrl(&quot;http://www.zhazhabear.site&quot;); templateMessageDTO.setData(data); Call&lt;Void&gt; call = weixinApiService.sendMessage(accessToken, templateMessageDTO); call.execute(); logger.info(&quot;已发送微信模板消息, openid: &#123;&#125;&quot;, openid); &#125; catch (Exception e) &#123; logger.error(&quot;保存登录状态或发送模板消息失败&quot;, e); throw e; // 重新抛出异常 &#125; &#125; private String getAccessToken() throws IOException &#123; String key = ACCESS_TOKEN_KEY_PREFIX + appid; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); String accessToken = bucket.get(); if (null == accessToken) &#123; logger.info(&quot;缓存中未找到accessToken，从微信API获取&quot;); Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); if (weixinTokenRes != null &amp;&amp; weixinTokenRes.getAccess_token() != null) &#123; accessToken = weixinTokenRes.getAccess_token(); bucket.set(accessToken, Duration.ofHours(ACCESS_TOKEN_TTL)); logger.info(&quot;成功获取并缓存accessToken&quot;); &#125; else &#123; throw new IOException(&quot;从微信API获取accessToken失败&quot;); &#125; &#125; else &#123; logger.debug(&quot;从缓存中获取accessToken&quot;); &#125; return accessToken; &#125;&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"},{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"Spring ai","slug":"Spring-ai","permalink":"https://www.zhazhabear.site/tags/Spring-ai/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"name":"redis","slug":"redis","permalink":"https://www.zhazhabear.site/tags/redis/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://www.zhazhabear.site/tags/PostgreSQL/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}]}