{"pages":[{"title":"友链","date":"2025-10-16T16:00:00.000Z","path":"links/index.html","text":""},{"title":"关于","date":"2025-10-16T16:00:00.000Z","path":"about/index.html","text":"渣渣熊窝"},{"title":"项目","date":"2025-10-16T16:00:00.000Z","path":"repository/index.html","text":"仓库列表暂未公开。"},{"title":"标签","date":"2025-10-16T16:00:00.000Z","path":"tags/index.html","text":""},{"title":"分类","date":"2025-10-16T16:00:00.000Z","path":"categories/index.html","text":""}],"posts":[{"title":"Ollama流式应答接口页面对接","date":"2025-10-15T11:31:00.000Z","path":"2025/10/15/Ollama流式应答接口页面对接/","text":"本节需求 实现一款简单的UI界面，与服务端 Ollama DeepSeek AI 进行对接 前端代码 这里直接贴一份我自己和AI多次对话得到的一个效果还不错的HTML 效果展示 支持的功能 普通请求&#x2F;流式请求切换 用户可通过界面按钮在普通请求（一次性返回完整消息）与流式请求（逐段返回消息）之间切换。 当前模式会在界面顶部显示，并附带简要说明。 聊天记录快捷导航 支持通过键盘的 ↑&#x2F;↓ 箭头快速切换上一条或下一条用户发言，方便重复发送或修改。 Markdown 格式渲染 服务端返回的消息支持 Markdown 格式，前端会自动解析并渲染，包括代码块、列表、表格等。 深度思考与普通输出区分 模型的“深度思考”状态会以特殊样式（如灰色背景提示框）显示，普通输出则以常规气泡样式展示。 日志功能 提供日志面板，记录用户请求与服务端响应的详细信息，便于调试与问题排查。 日志支持查看、清空等操作，提升开发与测试效率。 具体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;AI Chatbot&lt;/title&gt; &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/marked/marked.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css&quot; integrity=&quot;sha512-SnF4j8kH9Yp5VX1nA2nayJ9uj9Y6p9cHfGppRy5JyE2tdI9lbEKeosFVJeFt3PcTJS3BM4tiTqcK3wwD5cqvug==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; /&gt; &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;family=Poppins:wght@400;500;600&amp;display=swap&quot; rel=&quot;stylesheet&quot; /&gt; &lt;style&gt; :root &#123; color-scheme: light; &#125; body.web-page &#123; font-family: &#x27;Inter&#x27;, &#x27;Poppins&#x27;, -apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;PingFang SC&#x27;, &#x27;Microsoft YaHei&#x27;, sans-serif; background: radial-gradient(circle at 15% 20%, rgba(151, 190, 255, 0.22), transparent 55%), radial-gradient(circle at 85% 10%, rgba(120, 180, 255, 0.18), transparent 50%), linear-gradient(180deg, #F4F7FB 0%, #E3F0FF 100%); min-height: 100vh; color: #1F2430; &#125; .glass-card &#123; backdrop-filter: blur(10px); background: rgba(243, 248, 255, 0.9); border: 1px solid rgba(138, 163, 210, 0.2); box-shadow: 0 16px 36px -24px rgba(34, 61, 120, 0.28); &#125; .signal-gradient &#123; background: linear-gradient(90deg, #5A8DEE 0%, #7AD1F8 100%); &#125; #conversation &#123; max-height: 60vh; &#125; /* Markdown 样式 */ .ai-message pre &#123; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; font-size: 13px; line-height: 1.4; &#125; .ai-message code &#123; background: #f1f3f4; color: #d73a49; padding: 2px 6px; border-radius: 3px; font-size: 12px; font-family: &#x27;SFMono-Regular&#x27;, Consolas, &#x27;Liberation Mono&#x27;, Menlo, monospace; &#125; .ai-message pre code &#123; background: transparent; color: inherit; padding: 0; border-radius: 0; &#125; .ai-message h1, .ai-message h2, .ai-message h3 &#123; color: #1f2937; margin: 16px 0 8px 0; font-weight: 600; &#125; .ai-message h1 &#123; font-size: 1.5em; &#125; .ai-message h2 &#123; font-size: 1.25em; &#125; .ai-message h3 &#123; font-size: 1.125em; &#125; .ai-message p &#123; margin: 8px 0; line-height: 1.6; &#125; .ai-message ul, .ai-message ol &#123; margin: 8px 0; padding-left: 24px; &#125; .ai-message li &#123; margin: 4px 0; &#125; .ai-message blockquote &#123; border-left: 4px solid #e5e7eb; padding-left: 16px; margin: 12px 0; color: #6b7280; font-style: italic; &#125; .ai-message table &#123; border-collapse: collapse; margin: 12px 0; width: 100%; &#125; .ai-message th, .ai-message td &#123; border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; &#125; .ai-message th &#123; background: #f9fafb; font-weight: 600; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;web-page&quot;&gt; &lt;div class=&quot;max-w-screen-xl mx-auto h-screen px-6 md:px-10 pt-10 pb-16 flex flex-col&quot;&gt; &lt;header class=&quot;mb-10 flex flex-col md:flex-row md:items-center md:justify-between gap-5&quot;&gt; &lt;div class=&quot;flex items-center gap-3&quot;&gt; &lt;span class=&quot;w-12 h-12 rounded-2xl signal-gradient flex items-center justify-center text-white text-2xl font-semibold shadow-lg shadow-blue-100/60&quot;&gt;&lt;/span&gt; &lt;div&gt; &lt;h1 class=&quot;text-2xl font-semibold tracking-tight text-slate-800&quot;&gt;AI Chatbot&lt;/h1&gt; &lt;p class=&quot;text-sm text-slate-500&quot;&gt;Deepseek R1:1.5B&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;glass-card rounded-2xl px-6 py-4 flex items-center gap-4 max-w-2xl&quot;&gt; &lt;div class=&quot;min-w-[140px]&quot;&gt; &lt;p class=&quot;text-xs uppercase tracking-[0.18em] text-slate-500&quot;&gt;当前模式&lt;/p&gt; &lt;p id=&quot;modeLabel&quot; class=&quot;text-lg font-semibold text-slate-700&quot;&gt;普通请求&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 text-xs text-slate-500 leading-relaxed&quot;&gt; &lt;p id=&quot;modeDescription&quot;&gt;一次性返回完整消息。&lt;/p&gt; &lt;p id=&quot;modeHint&quot; class=&quot;mt-1&quot;&gt;点击底部按钮可切换至流式模式。&lt;/p&gt; &lt;/div&gt; &lt;button id=&quot;logToggle&quot; type=&quot;button&quot; class=&quot;shrink-0 h-11 px-4 rounded-xl border border-slate-200/80 text-sm font-medium text-slate-600 flex items-center gap-2 transition hover:border-sky-300 hover:text-sky-600&quot;&gt; &lt;i class=&quot;fa-regular fa-file-lines&quot;&gt;&lt;/i&gt; 查看日志 &lt;/button&gt; &lt;/div&gt; &lt;/header&gt; &lt;main class=&quot;flex-1 flex flex-col overflow-hidden&quot;&gt; &lt;section class=&quot;glass-card rounded-3xl flex-1 overflow-hidden flex flex-col&quot;&gt; &lt;div class=&quot;px-8 pt-8 pb-4 border-b border-slate-200/60&quot;&gt; &lt;h2 class=&quot;text-sm font-semibold text-slate-600 uppercase tracking-wide&quot;&gt;对话区&lt;/h2&gt; &lt;p class=&quot;text-xs text-slate-500 mt-1&quot;&gt;用于展示实时的模型回复与用户消息。&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;conversation&quot; class=&quot;flex-1 px-8 py-6 overflow-y-auto space-y-4&quot;&gt; &lt;div class=&quot;h-full flex flex-col items-center justify-center text-sm text-slate-400&quot; data-empty-state=&quot;true&quot;&gt; &lt;i class=&quot;fa-regular fa-comment-dots text-xl mb-2&quot;&gt;&lt;/i&gt; &lt;p&gt;还没有消息，输入内容开始对话吧。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;mt-8&quot;&gt; &lt;form class=&quot;glass-card rounded-3xl px-6 py-4 flex flex-col md:flex-row gap-4 md:items-center&quot; id=&quot;chatForm&quot;&gt; &lt;button type=&quot;button&quot; id=&quot;modeToggle&quot; class=&quot;w-full md:w-auto md:min-w-[160px] h-12 rounded-2xl border border-sky-200/70 text-sky-600 text-sm font-medium flex items-center justify-center gap-2 transition hover:border-sky-400 hover:text-sky-700&quot;&gt; &lt;i class=&quot;fa-solid fa-repeat&quot;&gt;&lt;/i&gt; &lt;span id=&quot;modeToggleLabel&quot;&gt;切换到流式请求&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;flex-1 flex items-center gap-3&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; class=&quot;flex-1 h-12 rounded-2xl border border-transparent bg-white/85 px-4 text-sm text-slate-700 placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-sky-200&quot; placeholder=&quot;直接输入内容即可，不需要命令&quot; autocomplete=&quot;off&quot; required /&gt; &lt;button type=&quot;submit&quot; class=&quot;w-12 h-12 rounded-2xl signal-gradient text-white flex items-center justify-center text-lg shadow-md shadow-blue-200/60 transition hover:shadow-lg hover:-translate-y-0.5&quot;&gt; &lt;i class=&quot;fa-solid fa-paper-plane&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/section&gt; &lt;/main&gt; &lt;/div&gt; &lt;aside id=&quot;logPanel&quot; class=&quot;hidden fixed bottom-6 right-6 w-[320px] max-h-[60vh] glass-card rounded-3xl p-5 flex flex-col shadow-2xl shadow-blue-200/50&quot;&gt; &lt;div class=&quot;flex items-center justify-between mb-3&quot;&gt; &lt;div&gt; &lt;p class=&quot;text-xs uppercase tracking-[0.2em] text-slate-500&quot;&gt;请求日志&lt;/p&gt; &lt;p class=&quot;text-sm font-semibold text-slate-700&quot;&gt;最近活动&lt;/p&gt; &lt;/div&gt; &lt;button id=&quot;logClose&quot; type=&quot;button&quot; class=&quot;w-9 h-9 rounded-lg border border-slate-200/80 text-slate-400 hover:text-slate-600 hover:border-sky-300 transition&quot;&gt; &lt;i class=&quot;fa-solid fa-xmark&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 overflow-y-auto pr-1&quot;&gt; &lt;ul id=&quot;logList&quot; class=&quot;space-y-3 text-xs text-slate-500&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;button id=&quot;logClear&quot; type=&quot;button&quot; class=&quot;mt-4 w-full h-10 rounded-xl border border-slate-200/80 text-[13px] text-slate-500 hover:border-sky-300 hover:text-sky-600 transition&quot;&gt;清空日志&lt;/button&gt; &lt;/aside&gt; &lt;script&gt; const DEFAULT_MODEL = &#x27;deepseek-r1:1.5b&#x27;; const modeToggle = document.getElementById(&#x27;modeToggle&#x27;); const modeToggleLabel = document.getElementById(&#x27;modeToggleLabel&#x27;); const modeLabel = document.getElementById(&#x27;modeLabel&#x27;); const modeDescription = document.getElementById(&#x27;modeDescription&#x27;); const modeHint = document.getElementById(&#x27;modeHint&#x27;); const logToggle = document.getElementById(&#x27;logToggle&#x27;); const logPanel = document.getElementById(&#x27;logPanel&#x27;); const logClose = document.getElementById(&#x27;logClose&#x27;); const logClear = document.getElementById(&#x27;logClear&#x27;); const logList = document.getElementById(&#x27;logList&#x27;); const messageInput = document.getElementById(&#x27;messageInput&#x27;); const conversation = document.getElementById(&#x27;conversation&#x27;); const chatForm = document.getElementById(&#x27;chatForm&#x27;); const submitButton = chatForm.querySelector(&#x27;button[type=&quot;submit&quot;]&#x27;); const modes = &#123; standard: &#123; name: &#x27;普通请求&#x27;, description: &#x27;一次性返回完整消息。&#x27;, hint: &#x27;点击底部按钮可切换至流式模式。&#x27;, toggleText: &#x27;切换到流式请求&#x27;, next: &#x27;stream&#x27; &#125;, stream: &#123; name: &#x27;流式请求&#x27;, description: &#x27;逐段返回，适合实时展示。&#x27;, hint: &#x27;点击底部按钮可切换至普通模式。&#x27;, toggleText: &#x27;切换到普通请求&#x27;, next: &#x27;standard&#x27; &#125; &#125;; let currentMode = &#x27;standard&#x27;; let isRequestPending = false; const logs = []; const sentMessages = []; // 用于存储用户发送的消息 let historyIndex = -1; // 用于追踪历史记录的位置 function updateModeUI() &#123; const &#123; name, description, hint, toggleText &#125; = modes[currentMode]; modeLabel.textContent = name; modeDescription.textContent = description; modeHint.textContent = hint; modeToggleLabel.textContent = toggleText; modeToggle.dataset.mode = currentMode; modeToggle.setAttribute(&#x27;aria-pressed&#x27;, currentMode === &#x27;stream&#x27;); modeToggle.title = `$&#123;name&#125; · $&#123;description&#125;`; &#125; function createMessagePreview(text) &#123; const trimmed = text.replace(/\\s+/g, &#x27; &#x27;).trim(); return trimmed.length &gt; 60 ? `$&#123;trimmed.slice(0, 60)&#125;…` : trimmed; &#125; function removeEmptyState() &#123; const emptyState = conversation.querySelector(&#x27;[data-empty-state]&#x27;); if (emptyState) &#123; emptyState.remove(); &#125; &#125; function appendUserMessage(text) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex justify-end&#x27;; const bubble = document.createElement(&#x27;div&#x27;); bubble.className = &#x27;max-w-[70%] rounded-3xl bg-sky-100/80 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words&#x27;; bubble.textContent = text; wrapper.appendChild(bubble); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; &#125; function appendAssistantMessage(initialText = &#x27;模型生成中…&#x27;) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex gap-3&#x27;; const avatar = document.createElement(&#x27;div&#x27;); avatar.className = &#x27;w-9 h-9 rounded-full signal-gradient text-white flex items-center justify-center shadow-md&#x27;; avatar.innerHTML = &#x27;&lt;i class=&quot;fa-solid fa-robot&quot;&gt;&lt;/i&gt;&#x27;; const body = document.createElement(&#x27;div&#x27;); body.className = &#x27;max-w-[72%] rounded-3xl bg-white/90 border border-slate-200/60 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words ai-message&#x27;; const thinkDiv = document.createElement(&#x27;div&#x27;); thinkDiv.className = &#x27;mb-2 text-xs text-slate-400 bg-slate-50/50 px-2 py-1 rounded-lg border-l-2 border-slate-300&#x27;; thinkDiv.style.display = &#x27;none&#x27;; thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考...&lt;/strong&gt;&lt;br&gt;&#x27;; const contentDiv = document.createElement(&#x27;div&#x27;); contentDiv.textContent = initialText; body.appendChild(thinkDiv); body.appendChild(contentDiv); wrapper.append(avatar, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; return &#123; bubble: body, thinkDiv, contentDiv &#125;; &#125; function appendSystemMessage(text) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex gap-3&#x27;; const badge = document.createElement(&#x27;div&#x27;); badge.className = &#x27;w-9 h-9 rounded-full bg-rose-100 text-rose-500 flex items-center justify-center shadow-sm&#x27;; badge.innerHTML = &#x27;&lt;i class=&quot;fa-solid fa-circle-exclamation&quot;&gt;&lt;/i&gt;&#x27;; const body = document.createElement(&#x27;div&#x27;); const bubble = document.createElement(&#x27;div&#x27;); bubble.className = &#x27;max-w-[72%] rounded-3xl bg-white border border-rose-200 px-4 py-3 text-sm text-rose-600 leading-relaxed whitespace-pre-wrap break-words&#x27;; bubble.textContent = text; body.appendChild(bubble); wrapper.append(badge, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; &#125; function addLog(text) &#123; logs.unshift(&#123; text, timestamp: new Date().toLocaleTimeString() &#125;); if (logs.length &gt; 120) &#123; logs.pop(); &#125; renderLogs(); &#125; function renderLogs() &#123; logList.innerHTML = &#x27;&#x27;; if (!logs.length) &#123; const emptyItem = document.createElement(&#x27;li&#x27;); emptyItem.className = &#x27;text-slate-400 text-center py-4&#x27;; emptyItem.textContent = &#x27;暂无日志&#x27;; logList.appendChild(emptyItem); return; &#125; logs.forEach((&#123; text, timestamp &#125;) =&gt; &#123; const item = document.createElement(&#x27;li&#x27;); item.className = &#x27;rounded-2xl border border-slate-200/60 bg-white/80 px-3 py-2.5 shadow-sm&#x27;; item.innerHTML = ` &lt;p class=&quot;text-[11px] text-slate-400&quot;&gt;$&#123;timestamp&#125;&lt;/p&gt; &lt;p class=&quot;mt-1 text-slate-600 leading-relaxed&quot;&gt;$&#123;text&#125;&lt;/p&gt; `; logList.appendChild(item); &#125;); &#125; function toggleFormDisabled(disabled) &#123; submitButton.disabled = disabled; messageInput.disabled = disabled; modeToggle.disabled = disabled; submitButton.classList.toggle(&#x27;opacity-60&#x27;, disabled); submitButton.classList.toggle(&#x27;cursor-not-allowed&#x27;, disabled); messageInput.classList.toggle(&#x27;opacity-70&#x27;, disabled); &#125; modeToggle.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (isRequestPending) return; currentMode = modes[currentMode].next; updateModeUI(); &#125;); logToggle.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logPanel.classList.toggle(&#x27;hidden&#x27;); if (!logPanel.classList.contains(&#x27;hidden&#x27;)) &#123; renderLogs(); &#125; &#125;); logClose.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logPanel.classList.add(&#x27;hidden&#x27;); &#125;); logClear.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logs.length = 0; renderLogs(); &#125;); chatForm.addEventListener(&#x27;submit&#x27;, async (event) =&gt; &#123; event.preventDefault(); const text = messageInput.value.trim(); if (!text || isRequestPending) &#123; return; &#125; // 添加到历史记录 if (sentMessages[0] !== text) &#123; sentMessages.unshift(text); &#125; historyIndex = -1; // 重置历史记录索引 removeEmptyState(); appendUserMessage(text); messageInput.value = &#x27;&#x27;; messageInput.focus(); const preview = createMessagePreview(text); addLog(`准备发送 $&#123;modes[currentMode].name&#125;：$&#123;preview&#125;`); const aiBubble = appendAssistantMessage(); isRequestPending = true; toggleFormDisabled(true); try &#123; await dispatchRequest(text, aiBubble); &#125; catch (error) &#123; console.error(error); addLog(`$&#123;modes[currentMode].name&#125; 请求失败：$&#123;error.message&#125;`); appendSystemMessage(`请求失败：$&#123;error.message&#125;`); &#125; finally &#123; isRequestPending = false; toggleFormDisabled(false); &#125; &#125;); async function dispatchRequest(message, aiBubble) &#123; const endpoint = currentMode === &#x27;standard&#x27; ? &#x27;generate&#x27; : &#x27;generate_stream&#x27;; const url = `/api/v1/ollama/$&#123;endpoint&#125;?model=$&#123;encodeURIComponent(DEFAULT_MODEL)&#125;&amp;message=$&#123;encodeURIComponent(message)&#125;`; addLog(`请求 URL：$&#123;url&#125;`); try &#123; if (currentMode === &#x27;standard&#x27;) &#123; const &#123; status &#125; = await handleStandardRequest(url, aiBubble); addLog(`普通请求成功 · HTTP $&#123;status&#125;`); &#125; else &#123; const &#123; status &#125; = await handleStreamRequest(url, aiBubble); addLog(`流式请求成功 · HTTP $&#123;status&#125;`); &#125; &#125; catch (error) &#123; aiBubble.contentDiv.innerHTML = marked.parse(`请求失败：$&#123;error.message&#125;`); throw error; &#125; &#125; async function handleStandardRequest(url, aiBubble) &#123; const response = await fetch(url); const status = response.status; if (!response.ok) &#123; const errorText = await response.text().catch(() =&gt; &#x27;&#x27;); throw new Error(`HTTP $&#123;status&#125;$&#123;errorText ? ` · $&#123;errorText&#125;` : &#x27;&#x27;&#125;`); &#125; const contentType = response.headers.get(&#x27;content-type&#x27;) || &#x27;&#x27;; let fullText; if (contentType.includes(&#x27;application/json&#x27;)) &#123; const data = await response.json(); fullText = extractContent(data); &#125; else &#123; fullText = await response.text(); &#125; // 解析 think 和正文 const thinkMatch = fullText.match(/&lt;think&gt;([\\s\\S]*?)&lt;\\/think&gt;/); const thinkContent = thinkMatch ? thinkMatch[1].trim() : &#x27;正在思考中...&#x27;; const mainContent = fullText.replace(/&lt;think&gt;[\\s\\S]*?&lt;\\/think&gt;\\s*/, &#x27;&#x27;).trim(); aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考完毕&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); aiBubble.contentDiv.innerHTML = marked.parse(mainContent || &#x27;（模型没有返回内容）&#x27;); conversation.scrollTop = conversation.scrollHeight; return &#123; status &#125;; &#125; async function handleStreamRequest(url, aiBubble) &#123; const response = await fetch(url); const status = response.status; if (!response.ok) &#123; const errorText = await response.text().catch(() =&gt; &#x27;&#x27;); throw new Error(`HTTP $&#123;status&#125;$&#123;errorText ? ` · $&#123;errorText&#125;` : &#x27;&#x27;&#125;`); &#125; // 重置内容 aiBubble.contentDiv.textContent = &#x27;&#x27;; aiBubble.thinkDiv.style.display = &#x27;none&#x27;; const data = await response.json(); if (Array.isArray(data)) &#123; // 后端返回的是一个完整的JSON数组 let fullText = &#x27;&#x27;; for (const item of data) &#123; const content = extractContent(item); if (content) &#123; fullText += content; // 直接更新文本内容，不再调用会重新渲染的函数 updateStreamDisplay(fullText, aiBubble, true); &#125; // 添加延迟，模拟流式效果 await new Promise(resolve =&gt; setTimeout(resolve, 100)); &#125; &#125; else &#123; // 处理其他可能的JSON结构或错误 const content = extractContent(data); if (content) &#123; updateStreamDisplay(content, aiBubble, false); &#125; else &#123; aiBubble.contentDiv.innerHTML = marked.parse(&#x27;（模型没有返回有效内容）&#x27;); &#125; &#125; return &#123; status &#125;; &#125; // 从单行数据中提取内容 // function extractContentFromLine(line) &#123; ... &#125; // 此函数已不再需要 // 更新流式显示 function updateStreamDisplay(fullText, aiBubble, isStreaming) &#123; // 处理 think 标签 const thinkMatch = fullText.match(/&lt;think&gt;([\\s\\S]*?)(&lt;\\/think&gt;|$)/); if (thinkMatch) &#123; if (!thinkMatch[2]) &#123; // 思考中 const thinkContent = thinkMatch[1]; aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考中...&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); aiBubble.contentDiv.textContent = &#x27;&#x27;; &#125; else &#123; // 思考完成 const thinkContent = thinkMatch[1].trim(); aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考完毕&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); // 提取并显示主要内容 const mainContent = fullText.replace(/&lt;think&gt;[\\s\\S]*?&lt;\\/think&gt;\\s*/, &#x27;&#x27;).trim(); aiBubble.contentDiv.innerHTML = marked.parse(mainContent); &#125; &#125; else &#123; // 直接显示主要内容 aiBubble.contentDiv.innerHTML = marked.parse(fullText); &#125; conversation.scrollTop = conversation.scrollHeight; &#125; // 逐字显示内容 // displayContentGradually 函数已完全删除，不再需要 // 处理非流式响应 // async function processCompleteResponse(text, aiBubble) &#123; ... &#125; // 此函数已不再需要 function extractContent(data) &#123; if (!data) return &#x27;&#x27;; if (typeof data === &#x27;string&#x27;) return data; const maybeContent = data?.result?.output?.content ?? data?.result?.output?.text ?? data?.output?.content ?? data?.message ?? data?.choices?.[0]?.message?.content ?? data?.results?.[0]?.output?.content; if (Array.isArray(maybeContent)) &#123; return maybeContent.map((item) =&gt; &#123; if (typeof item === &#x27;string&#x27;) return item; if (item?.text) return item.text; return &#x27;&#x27;; &#125;).join(&#x27;\\n&#x27;); &#125; if (typeof maybeContent === &#x27;object&#x27; &amp;&amp; maybeContent !== null) &#123; if (maybeContent.text) return maybeContent.text; return &#x27;&#x27;; &#125; if (maybeContent) &#123; return String(maybeContent); &#125; return &#x27;&#x27;; &#125; // 初始化界面 updateModeUI(); renderLogs(); messageInput.addEventListener(&#x27;keydown&#x27;, (event) =&gt; &#123; if (event.key === &#x27;ArrowUp&#x27;) &#123; event.preventDefault(); if (sentMessages.length &gt; 0 &amp;&amp; historyIndex &lt; sentMessages.length - 1) &#123; historyIndex++; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); &#125; &#125; else if (event.key === &#x27;ArrowDown&#x27;) &#123; event.preventDefault(); if (historyIndex &gt; 0) &#123; historyIndex--; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); &#125; else if (historyIndex &lt;= 0) &#123; historyIndex = -1; messageInput.value = &#x27;&#x27;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama流式应答接口实现","date":"2025-10-15T07:45:00.000Z","path":"2025/10/15/Ollama流式应答接口实现/","text":"本节需求 引入 Spring AI 框架组件，对接 Ollama DeepSeek 提供服务接口。包括:普通应答接口和流式接口。 普通请求（同步请求）普通请求是指客户端一次性发送请求，服务端处理完毕后一次性返回完整的结果。例如： 流式请求流式请求是指客户端发送请求后，服务端会将结果分批次，逐步推送给客户端，客户端可以边接收边处理。例如： 功能实现1. 工程结构123456789101112131415ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层│ └── IAiService.java # AI 服务接口定义├── xfg-dev-tech-app/ # 应用层│ ├── Application.java # Spring Boot 启动类│ ├── config/ # 配置类│ │ ├── OllamaConfig.java│ │ ├── RedisClientConfig.java│ │ └── RedisClientConfigProperties.java│ └── resources/ # 配置文件│ ├── application.yml│ ├── application-dev.yml│ └── logback-spring.xml└── xfg-dev-tech-trigger/ # 触发器层 └── OllamaController.java # HTTP 控制器 2. 依赖管理当前步骤需要ollama的依赖，在app模块的POM.xml文件添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama&lt;/artifactId&gt;&lt;/dependency&gt; 3. 配置管理配置信息需根据开发与部署环境灵活调整。开发过程中，我在 Windows PC 上进行 Java 开发，Ollama 和 DeepSeek 部署于云服务器的 Docker 环境中，配置文件如下所示： application.yml: 123456spring: application: name: ai-rag-knowledge profiles: active: dev application-dev.yml: 12345678910111213141516171819202122232425262728293031server: port: 8080spring: ai: ollama: # 使用云服务器的 Ollama 服务，将 IP 更换为你自己云服务器的公网 IP # 本地部署的就改为localhost:11434 base-url: http://&lt;部署了Ollama的公网IP&gt;:11434# Redis 配置redis: sdk: config: host: localhost port: 6379 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: truelogging: level: root: debug cn.bugstack.xfg.dev.tech: debug config: classpath:logback-spring.xml 其他配置文件暂且不考虑 4. 代码实现AI服务接口(IAiService.java)12345678910111213package cn.bugstack.xfg.dev.tech.api;import org.springframework.ai.chat.ChatResponse;import reactor.core.publisher.Flux;public interface IAiService &#123; ChatResponse generate(String model, String message); Flux&lt;ChatResponse&gt; generateStream(String model, String message);&#125; Ollama 配置类 (OllamaConfig.java)12345678910111213141516171819202122package cn.bugstack.xfg.dev.tech.config;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaApi;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class OllamaConfig &#123; @Bean public OllamaApi ollamaApi(@Value(&quot;$&#123;spring.ai.ollama.base-url&#125;&quot;) String baseUrl) &#123; return new OllamaApi(baseUrl); &#125; @Bean public OllamaChatClient ollamaChatClient(OllamaApi ollamaApi) &#123; return new OllamaChatClient(ollamaApi); &#125;&#125; HTTP 控制器 (OllamaController.java)123456789101112131415161718192021222324252627282930313233343536373839package cn.bugstack.xfg.dev.tech.trigger.http;import cn.bugstack.xfg.dev.tech.api.IAiService;import jakarta.annotation.Resource;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaOptions;import org.springframework.web.bind.annotation.*;import reactor.core.publisher.Flux;@RestController()@CrossOrigin(&quot;*&quot;)@RequestMapping(&quot;/api/v1/ollama/&quot;)public class OllamaController implements IAiService &#123; @Resource private OllamaChatClient chatClient; /** * 同步调用接口 * curl http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1 */ @RequestMapping(value = &quot;generate&quot;, method = RequestMethod.GET) @Override public ChatResponse generate(@RequestParam String model, @RequestParam String message) &#123; return chatClient.call(new Prompt(message, OllamaOptions.create().withModel(model))); &#125; /** * 流式调用接口 * curl http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=hi */ @RequestMapping(value = &quot;generate_stream&quot;, method = RequestMethod.GET) @Override public Flux&lt;ChatResponse&gt; generateStream(@RequestParam String model, @RequestParam String message) &#123; return chatClient.stream(new Prompt(message, OllamaOptions.create().withModel(model))); &#125;&#125; 启动类12345678910111213141516package cn.bugstack.xfg.dev.tech;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Configurablepublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 功能测试1. 普通请求测试启动项目，确保云服务器的ollama已经启动后，浏览器地址栏输入：http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1，得到结果： 2. 流式请求测试地址栏输入http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=你好啊 将流式请求的文本拼凑得到的响应结果为： 12345&lt;think&gt;&lt;/think&gt;你好！很高兴见到你，有什么我可以帮忙的吗？无论是问题、建议还是闲聊，我都在这儿呢！😊 小结本节基于 Spring AI 对接了 Ollama（以 DeepSeek 模型为例），分别实现了普通应答与流式应答两类接口： 如果不能出现最终的响应结果，请依次检查： 云服务器防火墙是否开放11434端口 云服务器中ollama是否成功运行 application-dev.yml中base-url是否更改为云服务器的公网IP application-dev.yml中port是否为8080","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"云服务器配置","date":"2025-10-12T13:04:00.000Z","path":"2025/10/12/云服务器配置/","text":"本节需求 购买并初始化云服务器，完成端口放通与 Docker&#x2F;Compose&#x2F;Portainer 安装，使用 docker compose 部署 AI Agent 运行所需的组件（Ollama、Redis、向量库），配置 JDK 17 与 Maven，并拉取 DeepSeek R1 1.5B 模型完成联通验证。 云服务要求AI Agent 至少需要 2C4G 的云服务器。阿里云学生优惠获取的2C2G服务器无法满足性能要求，因此建议购买新的实例以保证模型和服务的稳定运行。 腾讯云 4C4G 实例（79 元&#x2F;年），性价比较高。参考：腾讯云服务器4C4G 选择Ubuntu 24.04-LTS即可，不需要额外的应用镜像 环境配置1. 重置密码 这里需要给 root 用户重置密码。 2. 防火墙开放至少确保下列端口的开放： 3. Termius 安装Termius 4. Docker 安装1234567891011121314151617181920212223242526272829# 下载并运行官方安装脚本curl -fsSL https://get.docker.com | sudo shsudo apt updatesudo apt install docker-compose-plugin -y# 检查 Docker 版本docker version# 检查 Docker Compose 版本docker compose version# 创建 Docker 配置目录sudo mkdir -p /etc/docker# 配置镜像加速器（使用腾讯云内网镜像）sudo tee /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;: [ &quot;https://mirror.ccs.tencentyun.com&quot; ]&#125;EOF# 重启 Dockersudo systemctl restart docker# 测试运行一个容器docker run hello-world 如果上述过程没有问题的话，则会显示： 5. AI-Agent 环境配置创建并切换到 dev-ops 目录： 123cd /mkdir dev-opscd dev-ops 将项目中的 docs 目录下的内容移动至云服务器的 dev-ops 目录下（通过 Termius 的 SFTP）： 然后执行如下命令： 12# 使用 docker compose（注意：部分老命令为 docker-compose）docker compose -f docker-compose-environment-aliyun.yml up -d 即可完成下列组件的安装和配置： 1. Ollama - 大语言模型服务 作用：运行本地化的大语言模型（如 deepseek-r1:1.5b） 用途：提供对话 AI、文本生成、代码解释等 AI 能力 端口：11434 - 可以通过 API 调用模型服务 2. Redis - 缓存和消息队列 作用：高速内存数据库，用作缓存和会话存储 用途：存储用户会话、缓存 AI 响应、临时数据 管理界面：通过 redis-admin 在 8081 端口可视化管理 账密：admin&#x2F;admin 3. Vector DB - 向量数据库 作用：专门存储和检索向量数据的数据库 用途：存储文档嵌入向量，实现语义搜索、RAG（检索增强生成） 数据库：ai-rag-knowledge 接下来需要完成 Maven，JDK 17 的配置： 1234567891011# 1. 安装 JDK 17 和 Mavensudo apt updatesudo apt install openjdk-17-jdk maven -y# 2. 验证安装java -version # 应该显示 JDK 17mvn -version # 应该显示 Maven 版本# 3. 设置 JAVA_HOMEecho &#x27;export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 6. DeepSeek R1 1.5B 模型安装1. 安装 portainer12345678910docker volume create portainer_datadocker run -d \\ -p 9000:9000 \\ -p 9443:9443 \\ --name portainer \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce:latest 防火墙开启 9000 端口 立即访问：&lt;公网IP:9000&gt; 进入 portainer 界面 首次登录需要设置管理员账号的用户名和密码 2. 安装 Deepseek R1在 portainer 中完成如下操作： 然后 Connect，依次输入如下命令： 12345678# 拉取模型，推荐小一点，够做开发就可以ollama pull deepseek-r1:1.5b# （可选）运行模型，运行后关闭，继续安装模型。Ctrl/Command + Dollama run deepseek-r1:1.5b# 向量文本ollama pull nomic-embed-text 命令执行完毕后，即可与 AI 对话： 输入 /exit 退出对话 3. 通过其他途径访问1. 可以像小傅哥项目中提到的用 sh 脚本：1234567curl http://&lt;ipv4地址&gt;:11434/api/generate \\ -H &quot;Content-Type: application/json&quot; \\ -d &#x27;&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;1+1&quot;, &quot;stream&quot;: false &#125;&#x27; 5. 也可以用 apifox 发起请求 Body: 12345&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;你好&quot;, &quot;stream&quot;: false&#125; Headers: 成功响应！","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"Redis","slug":"Redis","permalink":"https://www.zhazhabear.site/tags/Redis/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城下单支付","date":"2025-09-15T16:00:00.000Z","path":"2025/09/16/下单支付/","text":"内容概述下单功能以及支付功能的完整实现 流程图 流程分析graph TB subgraph \"前端层\" A[用户界面] --> B[HTTP请求] end subgraph \"Web层 (s-pay-mall-web)\" B --> C[AliPayController] C --> D[参数验证] end subgraph \"业务层 (s-pay-mall-service)\" D --> E[OrderServiceImpl] E --> F[ProductRPC] E --> G[支付宝SDK] end subgraph \"数据层 (s-pay-mall-dao)\" E --> H[IOrderDao] H --> I[(MySQL数据库)] end subgraph \"外部系统\" G --> J[支付宝网关] J --> K[支付回调] K --> C end subgraph \"异步处理\" E --> L[EventBus事件总线] L --> M[OrderPaySuccessListener] N[定时任务] --> E end 第一阶段：用户下单请求输入数据： 12345POST /api/v1/alipay/create_pay_order&#123; &quot;userId&quot;: &quot;10001&quot;, &quot;productId&quot;: &quot;100001&quot;&#125; 处理流程： 前端发送 HTTP POST 请求到AliPayController.createPayOrder() Controller 接收 ShopCartReq 对象，包含用户ID和商品ID 数据流向：前端请求 -&gt; AliPayController -&gt; 参数验证 第二阶段：重复订单检查输入数据：ShopCartReq对象： 1234public class ShopCartReq &#123; private String userId; private String productId;&#125; 处理流程： OrderServiceImpl.createOrder() 被调用 构造查询条件：创建 PayOrder 对象设置 userId 和 productId 调用 IOrderDao.queryUnPayOrder() 查询数据库 1234567891011121314public class PayOrder &#123; private Long id; private String userId; private String productId; private String productName; private String orderId; private Date orderTime; private BigDecimal totalAmount; private String status; private String payUrl; private Date payTime; private Date createTime; private Date updateTime;&#125; 可能的情况： 返回状态为 PAY_WAIT 的未支付订单 直接返回现有的 PayOrderRes{orderId, payUrl} 流程结束，跳转到返回响应阶段 返回状态为 CREATE 的订单 需要重新创建支付单 调用 doPrepayOrder() 方法创建支付单 跳转到支付单创建阶段 返回 null（无相关订单） 继续执行后续流程 数据流向：OrderServiceImpl -&gt; IOrderDao -&gt; MySQL数据库 -&gt; 返回查询结果 第三阶段：商品信息查询输入数据：productId（String 类型） 处理流程： 调用 ProductRPC.queryProductByProductId() 这是一个模拟的RPC调用，实际返回固定的商品信息 输出数据： 12345678910public class ProductVO &#123; /** 商品ID */ private String productId; /** 商品名称 */ private String productName; /** 商品描述 */ private String productDesc; /** 商品价格 */ private BigDecimal price;&#125; 数据流向：OrderServiceImpl -&gt; ProductRPC -&gt; 返回ProductVO对象 第四阶段：订单数据持久化输入数据： userId：用户ID productId：商品ID productName：从ProductVO获取的商品名称 price：从ProductVO获取的商品价格 处理流程： 生成16位随机订单号：RandomStringUtils.randomNumeric(16) 构造 PayOrder 对象： 123456789PayOrder.builder() .userId(&quot;10001&quot;) .productId(&quot;100001&quot;) .productName(&quot;new product&quot;) .orderId(&quot;1234567890123456&quot;) // 16位随机数 .totalAmount(new BigDecimal(&quot;1.68&quot;)) .orderTime(new Date()) .status(&quot;CREATE&quot;) // 使用Constants.OrderStatusEnum.CREATE.getCode() .build() 调用 IOrderDao.insert() 插入数据库 执行SQL：INSERT INTO pay_order(...) VALUES(...) 输出数据： 数据库中新增一条订单记录，状态为 CREATE 数据流向：OrderServiceImpl -&gt; 构造PayOrder对象 -&gt; IOrderDao -&gt; MySQL数据库 第五阶段：支付单创建输入数据： productId：商品ID productName：商品名称 orderId：订单号 totalAmount：订单金额 处理流程： 调用 doPrepayOrder() 方法 创建支付宝请求对象： 123AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();request.setNotifyUrl(notifyUrl); // 异步回调地址request.setReturnUrl(returnUrl); // 同步跳转地址 构造业务参数： 123456&#123; &quot;out_trade_no&quot;: &quot;1234567890123456&quot;, // 商户订单号 &quot;total_amount&quot;: &quot;1.68&quot;, // 订单金额 &quot;subject&quot;: &quot;new product&quot;, // 订单标题 &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;&#125; 调用支付宝SDK：alipayClient.pageExecute(request).getBody() 输出数据： 支付宝返回HTML表单字符串，包含支付页面的完整HTML代码 数据流向：OrderServiceImpl -&gt; 构造支付宝请求 -&gt; 支付宝SDK -&gt; 支付宝服务器 -&gt; 返回支付表单 第六阶段：更新订单支付信息输入数据： orderId：订单号 payUrl：支付宝返回的HTML表单 status：新状态 PAY_WAIT 处理流程： 构造更新对象： 1234PayOrder payOrder = new PayOrder();payOrder.setOrderId(&quot;1234567890123456&quot;);payOrder.setPayUrl(&quot;&lt;html&gt;支付表单内容&lt;/html&gt;&quot;);payOrder.setStatus(&quot;PAY_WAIT&quot;); 调用 IOrderDao.updateOrderPayInfo() 执行SQL：UPDATE pay_order SET pay_url = ?, status = ?, update_time = now() WHERE order_id = ? 输出数据： 数据库订单记录更新完成，状态变为 PAY_WAIT，包含支付链接 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第七阶段：返回支付响应输入数据： orderId：订单号 payUrl：支付链接 处理流程： 构造响应对象： 1234PayOrderRes.builder() .orderId(&quot;1234567890123456&quot;) .payUrl(&quot;&lt;html&gt;支付表单&lt;/html&gt;&quot;) .build() 在Controller层包装成统一响应格式： 12345Response.&lt;String&gt;builder() .code(&quot;0000&quot;) // Constants.ResponseCode.SUCCESS.getCode() .info(&quot;调用成功&quot;) // Constants.ResponseCode.SUCCESS.getInfo() .data(payOrderRes.getPayUrl()) .build() 记录成功日志：”商品下单，根据商品ID创建支付单完成” 输出数据（返回给前端）： 12345&#123; &quot;code&quot;: &quot;0000&quot;, &quot;info&quot;: &quot;调用成功&quot;, &quot;data&quot;: &quot;&lt;html&gt;支付宝支付表单HTML代码&lt;/html&gt;&quot;&#125; 数据流向：OrderServiceImpl -&gt; PayOrderRes -&gt; AliPayController -&gt; Response对象 -&gt; 前端页面 第八阶段：用户支付操作处理流程： 前端接收到支付表单HTML 用户浏览器渲染支付页面 用户在支付宝页面完成付款操作 支付宝处理支付请求并扣款 数据流向：前端页面 -&gt; 用户操作 -&gt; 支付宝支付页面 -&gt; 支付宝服务器处理 第九阶段：支付回调处理输入数据（支付宝异步回调）： 1POST /api/v1/alipay/pay_notify 参数包括： trade_status: “TRADE_SUCCESS” out_trade_no: “1234567890123456” (商户订单号) trade_no: “2021081622001234567890123456” (支付宝交易号) total_amount: “1.68” sign: “支付宝RSA256签名” 其他支付宝回调参数… 处理流程： AliPayController.payNotify() 接收回调 交易状态验证：检查 trade_status 是否为 “TRADE_SUCCESS” 签名验证： 123String sign = params.get(&quot;sign&quot;);String content = AlipaySignature.getSignCheckContentV1(params);boolean checkSignature = AlipaySignature.rsa256CheckContent(content, sign, alipayPublicKey, &quot;UTF-8&quot;); 记录回调日志：记录交易名称、状态、支付宝交易号、金额等信息 验证失败的输出： 返回字符串 “false” 给支付宝（拒绝回调） 验证成功继续处理… 数据流向：支付宝服务器 -&gt; AliPayController.payNotify() -&gt; 参数解析和验证 第十阶段：订单状态更新输入数据： orderId：从回调参数 out_trade_no 获取 处理流程： 调用 OrderServiceImpl.changeOrderPaySuccess() 构造更新对象： 123PayOrder payOrderReq = new PayOrder();payOrderReq.setOrderId(&quot;1234567890123456&quot;);payOrderReq.setStatus(&quot;PAY_SUCCESS&quot;); // Constants.OrderStatusEnum.PAY_SUCCESS.getCode() 调用 IOrderDao.changeOrderPaySuccess() 执行SQL：UPDATE pay_order SET status = ?, pay_time = now(), update_time = now() WHERE order_id = ? 输出数据： 数据库订单状态更新为 PAY_SUCCESS 设置支付时间为当前时间 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第十一阶段：异步事件发布输入数据： 更新后的 PayOrder 对象 处理流程： 将订单对象序列化为JSON：JSON.toJSONString(payOrderReq) 通过EventBus发布事件：eventBus.post(jsonString) OrderPaySuccessListener.handleEvent() 监听并处理事件 输出数据： 123456&#123; &quot;orderId&quot;: &quot;1234567890123456&quot;, &quot;status&quot;: &quot;PAY_SUCCESS&quot;, &quot;payTime&quot;: &quot;2025-09-16 10:30:00&quot;, &quot;updateTime&quot;: &quot;2025-09-16 10:30:00&quot;&#125; 后续处理： 商品发货逻辑 积分奖励计算 用户通知推送 返利处理等 数据流向：OrderServiceImpl -&gt; EventBus -&gt; OrderPaySuccessListener -&gt; 后续业务处理 第十二阶段：回调响应返回输出数据： 向支付宝返回字符串 “success”（表示回调处理成功） 记录日志：”支付回调，支付回调，更新订单 {}” 数据流向：AliPayController -&gt; 支付宝服务器（确认回调处理完成） 异步处理机制定时任务处理超时关单： TimeoutCloseOrderJob 每10分钟执行一次 查询超过30分钟未支付的订单：queryTimeoutCloseOrderList() 将订单状态更新为 CLOSE 支付状态主动查询： NoPayNotifyOrderJob 每3秒执行一次 查询超过1分钟未支付且未收到回调的订单：queryNoPayNotifyOrder() 主动调用支付宝接口查询订单实际支付状态 若支付成功则更新订单状态为 PAY_SUCCESS 事件监听器支付成功事件监听： OrderPaySuccessListener 基于Guava EventBus实现 通过@Subscribe注解订阅支付成功事件 接收JSON格式的订单信息 负责处理支付成功后的异步业务逻辑（如商品发货、积分奖励等）","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城前期准备","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/前期准备/","text":"注意：该项目基于jdk1.8 (java8)，务必确认项目的jdk版本 内容概述小傅哥项目7-11集的内容，包含类设计与流程分析 1.1. Natapp 内网穿透内网穿透教程 注意事项：Windows端natapp文件夹内一定要有natapp.exe，下图中没有后缀的版本无法运行 1.2. 微信公众号测试平台微信公众号测试平台申请教程对接工程项目地址 1.3. 支付宝沙箱支付宝沙箱申请使用教程 直接看好像并没有找到“沙箱”选项，往下滑动，即可看到“沙箱” 2.1 MVC 工程框架搭建 + 基础配置 + Git 使用1. 新建项目使用IDEA新建Spring Boot项目，发现没有Java 8的选项。原因可以参考这篇博客解决IDEA创建SpringBoot项目没有Java版本8 省流解决方案：将最上方服务器URL改为start.aliyun.com即可解决问题 其他过程略过，如果觉得上述过程麻烦的话，也可以直接clone仓库s-pay-mall-mvc 注意：不要直接在idea中通过版本控制新建项目 应该用命令行git clone &lt;链接&gt;的方式clone，然后用idea打开文件夹 然后用git将项目还原回历史版本： 2.2 微信公众号鉴权 本节内容：在 mvc 分层框架结构下添加微信公众号鉴权所需的接口，并通过 natapp 内网穿透组件，暴漏本地接口，让微信公众号平台可以配置使用。 1. common模块部分 MessageTextEntity.java微信消息实体类 严格按照微信公众平台消息格式规范实现 主要用途 ：封装微信公众号消息的数据结构，支持XML与Java对象的相互转换 关键特性 ： 使用@XStreamAlias注解映射微信消息的XML标签 包含微信消息的标准字段：ToUserName、FromUserName、CreateTime、 MsgType、Event、EventKey等 支持文本消息和事件消息的数据结构 微信模板消息文档 在上面7个字段的基础上加上生成带参的二维码所需要的ticket字段，构成了MessageTextEntity 关于@XStreamAlias注解 SignatureUtil.java微信签名验证工具 按照微信公众平台提供的签名算法实现 主要用途 ：验证请求是否来源于微信服务器，确保通信安全 关键特性 ： 实现了微信要求的SHA-1加密算法 包含字典序排序、字节数组转十六进制字符串等辅助方法 提供 check 方法进行签名验证 什么时候微信服务器会往你的服务器发请求？ 当您在微信公众平台（公众号或小程序）的后台配置了“服务器地址”（URL）并启用后，以下几种典型场景下，微信服务器都会向您的服务器发送请求： 首次验证服务器 场景：您在后台提交您的服务器地址和Token时，微信会立即向该地址发送一个GET请求，包含signature, timestamp, nonce, echostr参数。 目的：就是为了验证“您提供的这个URL背后确实是一个有效的、理解微信协议的服务”。您服务器上的SignatureUtil.check()方法就是用来处理这个请求的。验证通过后，您需要将接收到的echostr参数原样返回给微信。这样，微信才相信您拥有这个服务器，后续才会把重要消息推送给您。 接收用户消息（消息推送） 场景：当用户在您的公众号里发送文字、图片、语音、位置等消息时，微信服务器会将这些消息打包成一个XML格式的POST请求，发送到您的服务器。 目的：让您的服务器能够处理用户消息，实现自动回复、客服等功能。在处理这些POST请求之前，同样需要先用SignatureUtil.check()验证这个POST请求确实来自微信，而不是黑客伪造的。 接收事件推送（事件推送） 场景：当发生某些事件时，微信也会通知您的服务器。例如： 关注&#x2F;取关：用户关注您的公众号或取消关注。 菜单点击：用户点击了您自定义的菜单按钮。 支付成功：用户在小程序或公众号内完成了支付。 模板消息发送结果：您发送的模板消息是否成功送达。 目的：让您的服务器能够响应这些重要事件，更新用户状态、触发积分发放、更新订单状态等。同样，这些请求也需要验证签名。 XmlUtil.javaXML数据处理工具类 根据微信公众平台对XML消息格式的要求实现 主要用途：处理与微信服务器之间的XML数据交互 关键特性 ： 提供 xmlToMap 方法解析微信请求XML 提供 mapToXML 方法构建响应XML 提供 beanToXml 和 xmlToBean 方法实现对象与XML的相互转换 使用XStream和dom4j库进行XML处理 支持CDATA标记的添加，符合微信消息规范 2. web模块部分WeixinPortalController 微信公众号后台接口控制器，主要用于与微信服务器进行对接，处理微信公众号的消息接收和事件响应。 同时需要在resources/application-dev.yml下修改配置： 12345# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token 如果遇到natapp显示离线状态的情况，也要在web包下的resources/application-dev.yml将port修改为8080","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城登录功能","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/登录功能/","text":"内容概述登录功能设计实现，以及涉及到的类设计与流程分析 流程分析 小傅哥版本流程图： 简略版本流程图： 核心流程： 用户点击登录，浏览器向服务器请求ticket 服务器检测是否缓存有有效的access token，如果没有则向微信服务器请求(请求需要appid和secret两个参数，这两个参数在微信公众平台可以查看)(生成access token：https://developers.weixin.qq.com/doc/service/guide/dev/api/#%E7%94%9F%E6%88%90-Access-Token) 服务器使用access token作为参数调用微信服务器的API 微信服务器返回ticket至服务器 服务器将ticket传回给浏览器 浏览器通过ticket拼接出图片URL(https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=xxx) ，并显示二维码 用户扫描网页的二维码 微信服务器回调配置好的回调地址，通知扫码事件，并在请求中携带ticket与扫码用户的openid 浏览器持续向服务器查询登录状态，参数为ticket 服务器收到轮询后如果发现ticket已经绑定了openid，则生成token并返回给浏览器作为登录凭证 1. 用户点击登录，浏览器向服务器请求ticket12345678fetch(&#x27;http://localhost:8091/api/v1/login/weixin_qrcode_ticket&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; const ticket = data.data; // ... &#125; &#125;) 2-5. 服务器获取access token并调用微信API获取ticket12345678910111213141516171819202122232425262728293031@Overridepublic String createQrCodeTicket() throws Exception &#123; // 1. 检查缓存中是否有access token String accessToken = weixinAccessToken.getIfPresent(appid); if (null == accessToken) &#123; // 没有缓存则向微信服务器请求，需要appid和secret参数 Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); assert weixinTokenRes != null; accessToken = weixinTokenRes.getAccess_token(); weixinAccessToken.put(appid, accessToken); &#125; // 2. 使用access token调用微信API生成二维码 WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); // 3. 获取微信返回的ticket Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); assert null != weixinQrCodeRes; // 4. 返回ticket给前端 return weixinQrCodeRes.getTicket();&#125; 6. 浏览器显示二维码1qrCodeImg.src = https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=$&#123;ticket&#125;; 7-8. 用户扫码与微信服务器回调12345678910111213141516171819202122@PostMapping(value = &quot;receive&quot;, produces = &quot;application/xml; charset=UTF-8&quot;)public String post(@RequestBody String requestBody, @RequestParam(&quot;signature&quot;) String signature, @RequestParam(&quot;timestamp&quot;) String timestamp, @RequestParam(&quot;nonce&quot;) String nonce, @RequestParam(&quot;openid&quot;) String openid, @RequestParam(name = &quot;encrypt_type&quot;, required = false) String encType, @RequestParam(name = &quot;msg_signature&quot;, required = false) String msgSignature) &#123; try &#123; // 消息转换 MessageTextEntity message = XmlUtil.xmlToBean(requestBody, MessageTextEntity.class); // 处理扫码事件 if (&quot;event&quot;.equals(message.getMsgType()) &amp;&amp; &quot;SCAN&quot;.equals(message.getEvent())) &#123; // 保存登录状态（ticket与openid的绑定） loginService.saveLoginState(message.getTicket(), openid); return buildMessageTextEntity(openid, &quot;登录成功&quot;); &#125; // ... &#125; // ...&#125; 9-10. 浏览器轮询与登录状态验证12345678910111213141516171819// 前端轮询检查登录状态const intervalId = setInterval(() =&gt; &#123; checkLoginStatus(ticket, intervalId);&#125;, 3000); // 每3秒检查一次function checkLoginStatus(ticket, intervalId) &#123; fetch(`http://localhost:8091/api/v1/login/check_login?ticket=$&#123;ticket&#125;`) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; console.info(&quot;login success&quot;); // 停止轮询 clearInterval(intervalId); // 保存登录 token 到 cookie // ... &#125; &#125;) // ...&#125; 类设计common模块 Constants类的作用 定义通用常量：如SPLIT常量用于字符串分割 统一响应码管理：通过ResponseCode枚举定义标准化的API响应码和信息 订单状态管理：通过OrderStatusEnum枚举定义标准化的订单状态流转 注解解析@AllArgsConstructor作用：自动生成包含所有字段的构造方法 @NoArgsConstructor作用：自动生成无参构造方法 @Getter作用：自动生成所有字段的getter方法 AppException类的作用：AppException是项目中定义的自定义运行时异常类，主要用于统一管理和处理业务逻辑中的异常情况。定义了两个核心字段 code ：异常码，用于标识不同类型的异常 info ：异常描述信息，提供详细的错误说明 @EqualsAndHashCode(callSuper = true)作用：主要用于自动生成Java对象的equals()和hashCode()方法，其参数callSuper的作用是：是否调用父类的equals和hashCode方法。默认情况下为 false，即不会调用父类的方法参考文章 Reponse类的作用：Response是项目中定义的标准API响应封装类，主要用于统一规范前后端交互的数据格式。包含三个核心字段： code ：响应状态码 info ：响应描述信息 data ：泛型数据字段 @Data 自动生成所有字段的getter和setter方法 自动生成toString()方法，格式化输出对象信息 自动生成equals()和hashCode()方法，支持对象比较 自动生成canEqual()方法，用于判断对象是否为同一类型 @Builder 提供建造者模式的实现，支持链式调用设置属性 生成静态的builder()方法，用于创建Builder实例 生成Builder内部类，包含各个字段的setter方法 特别适合创建属性较多的对象，使代码更简洁、可读性更高 domain模块 domain包包含了以下四类： po/WeixinTemplateMessageVO.java - 微信模板消息值对象 req/WeixinQrCodeReq.java - 微信二维码请求数据封装类 res/WeixinQrCodeRes.java - 微信二维码响应数据封装类 res/WeixinTokenRes.java - 微信AccessToken响应数据封装类 发送模板消息获取AccessToken生成带参的二维码 web模块 关于 **@configuration**：用该注解修饰的类本身也是一个Bean，但它的主要职责是生产其他Bean，里面包含了用于定义和组装Spring容器中Bean的配置信息。@Configuration和@Component的区别：关键在于@Configuration使用了CGLIB代理，保证了所有带有@Bean注解的方法都是单例的。 其中Guava在本项目的主要作用是作为本地缓存缓存AccessToken和OpenIdToken，这里也可以用Redis替代。Retrofit2用于与微信API进行通信。 LoginController类的作用：LoginController是项目中定义的登录控制器类，主要负责处理用户登录相关的请求。内有两个方法weixinQrCodeTicket()生成微信二维码，以及checkLogin()用于检查登录状态。 service模块 注意事项在web包下的application-dev.yml中，增加teplate_id字段： 12345678# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token app-id: #填写你的app-id app-secret: #填写你的app-secret template_id: #填写你的template_id 扩展 将本地缓存Guava修改为Redis 1. 在pom.xml中添加Redis的依赖这里我们可以选择引入Redis或者直接引入Redisson，这里我们选择Redisson 在web模块下的pom.xml中添加redisson的依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 注意：这里不需要引入版本号，因为根pom已经定义了版本号 2. 在application-dev.yml中添加Redis的配置注意：如果没有密码务必删除password这行，不然有可能出现连接问题 123456spring: redis: host: 127.0.0.1 port: 6379 password: #这里用你自己的密码，如果没有密码请删除此行 database: 0 3. 定义RedissonConfig配置类因为我们引入了redisson-spring-boot-starter，Spring Boot会自动帮助我们配置redisson，可以选择不定义RedissonConfig 但是，如果发现在Redis中存的数据出现乱码的情况，可以选择定义RedissonConfig来避免这个问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.bugstack.config;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.codec.JsonJacksonCodec;import org.redisson.config.Config;import org.redisson.config.SingleServerConfig;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.StringUtils;/** * @author 渣渣熊 * @description Redisson配置类 * @create 2025-09-10 17:39 */@Configurationpublic class RedissonConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private String port; @Value(&quot;$&#123;spring.redis.password:&#125;&quot;) private String password; @Bean public RedissonClient redissonClient() &#123; Config config = new Config(); SingleServerConfig serverConfig = config.useSingleServer() .setAddress(&quot;redis://&quot; + host + &quot;:&quot; + port); // 1. 创建自定义 ObjectMapper ObjectMapper mapper = new ObjectMapper(); // 2. 注册Java 8时间模块 mapper.registerModule(new JavaTimeModule()); // 3. 禁用时间戳格式 mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 4. 使用自定义ObjectMapper创建编解码器 config.setCodec(new JsonJacksonCodec(mapper)); if (StringUtils.hasText(password)) &#123; serverConfig.setPassword(password); &#125; return Redisson.create(config); &#125;&#125; 4. 测试Redisson连接如果前面部分都没有问题，这里的测试类应该也都能顺利通过，测试类应该位于web模块下的test文件夹中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.bugstack.test;import org.junit.jupiter.api.Test;import org.redisson.api.RBucket;import org.redisson.api.RMap;import org.redisson.api.RSet;import org.redisson.api.RedissonClient;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;import static org.junit.jupiter.api.Assertions.*;/** * @author 渣渣熊 * @description 测试 Redisson是否配置成功 * @create 2025-09-09 21：10 */@SpringBootTest@ActiveProfiles(&quot;dev&quot;)public class RedissonTest &#123; @Resource private RedissonClient redissonClient; /** * 测试Redisson连接是否正常 */ @Test public void testConnection() &#123; assertNotNull(redissonClient, &quot;RedissonClient should not be null&quot;); System.out.println(&quot;Redisson连接测试成功！&quot;); &#125; /** * 测试字符串操作 */ @Test public void testStringOperations() &#123; String key = &quot;test:string:key&quot;; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(&quot;Hello Redisson!&quot;); System.out.println(bucket.get()); bucket.delete(); assertNull(redissonClient.getBucket(key).get()); System.out.println(&quot;字符串操作测试成功，并已清理测试数据&quot;); &#125;&#125; 如果两个方法都通过，则可以认为Redisson配置没有问题 5. Redisson代替Guava后的完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package cn.bugstack.service.impl;import cn.bugstack.domain.po.WeixinTemplateMessageVO;import cn.bugstack.domain.req.WeixinQrCodeReq;import cn.bugstack.domain.res.WeixinQrCodeRes;import cn.bugstack.domain.res.WeixinTokenRes;import cn.bugstack.service.ILoginService;import cn.bugstack.service.weixin.IWeixinApiService;import org.redisson.api.RBucket;import org.redisson.api.RedissonClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import retrofit2.Call;import javax.annotation.Resource;import java.io.IOException;import java.time.Duration;import java.util.HashMap;import java.util.Map;import static cn.bugstack.common.constants.RedisConstants.*;@Servicepublic class WeixinLoginServiceImpl implements ILoginService &#123; private static final Logger logger = LoggerFactory.getLogger(WeixinLoginServiceImpl.class); @Value(&quot;$&#123;weixin.config.app-id&#125;&quot;) private String appid; @Value(&quot;$&#123;weixin.config.app-secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;weixin.config.template_id&#125;&quot;) private String template_id; @Resource private IWeixinApiService weixinApiService; @Resource private RedissonClient redissonClient; @Override public String createQrCodeTicket() &#123; try &#123; logger.info(&quot;开始创建微信二维码ticket, appid: &#123;&#125;&quot;, appid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 生成 ticket WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); if (weixinQrCodeRes == null || weixinQrCodeRes.getTicket() == null) &#123; throw new RuntimeException(&quot;微信API返回空响应或缺少ticket&quot;); &#125; logger.info(&quot;成功创建微信二维码ticket: &#123;&#125;&quot;, weixinQrCodeRes.getTicket()); return weixinQrCodeRes.getTicket(); &#125; catch (Exception e) &#123; logger.error(&quot;创建微信二维码ticket失败&quot;, e); throw new RuntimeException(&quot;Failed to create QR code ticket&quot;, e); &#125; &#125; @Override public String checkLogin(String ticket) &#123; String key = OPENID_KEY_PREFIX + ticket; String result = redissonClient.&lt;String&gt;getBucket(key).get(); return result != null ? result : &quot;&quot;; &#125; @Override public void saveLoginState(String ticket, String openid) throws IOException &#123; try &#123; String key = OPENID_KEY_PREFIX + ticket; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(openid, Duration.ofHours(OPENID_TTL)); logger.info(&quot;已保存登录状态, ticket: &#123;&#125;, openid: &#123;&#125;&quot;, ticket, openid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 发送模板消息 Map&lt;String, Map&lt;String, String&gt;&gt; data = new HashMap&lt;&gt;(); WeixinTemplateMessageVO.put(data, WeixinTemplateMessageVO.TemplateKey.USER, openid); WeixinTemplateMessageVO templateMessageDTO = new WeixinTemplateMessageVO(openid, template_id); templateMessageDTO.setUrl(&quot;http://www.zhazhabear.site&quot;); templateMessageDTO.setData(data); Call&lt;Void&gt; call = weixinApiService.sendMessage(accessToken, templateMessageDTO); call.execute(); logger.info(&quot;已发送微信模板消息, openid: &#123;&#125;&quot;, openid); &#125; catch (Exception e) &#123; logger.error(&quot;保存登录状态或发送模板消息失败&quot;, e); throw e; // 重新抛出异常 &#125; &#125; private String getAccessToken() throws IOException &#123; String key = ACCESS_TOKEN_KEY_PREFIX + appid; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); String accessToken = bucket.get(); if (null == accessToken) &#123; logger.info(&quot;缓存中未找到accessToken，从微信API获取&quot;); Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); if (weixinTokenRes != null &amp;&amp; weixinTokenRes.getAccess_token() != null) &#123; accessToken = weixinTokenRes.getAccess_token(); bucket.set(accessToken, Duration.ofHours(ACCESS_TOKEN_TTL)); logger.info(&quot;成功获取并缓存accessToken&quot;); &#125; else &#123; throw new IOException(&quot;从微信API获取accessToken失败&quot;); &#125; &#125; else &#123; logger.debug(&quot;从缓存中获取accessToken&quot;); &#125; return accessToken; &#125;&#125;","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"},{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"Redis","slug":"Redis","permalink":"https://www.zhazhabear.site/tags/Redis/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}]}