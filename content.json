{"pages":[{"title":"分类","date":"2025-10-16T16:00:00.000Z","path":"categories/index.html","text":""},{"title":"关于","date":"2025-10-16T16:00:00.000Z","path":"about/index.html","text":"渣渣熊窝"},{"title":"友链","date":"2025-10-16T16:00:00.000Z","path":"links/index.html","text":""},{"title":"标签","date":"2025-10-16T16:00:00.000Z","path":"tags/index.html","text":""},{"title":"项目","date":"2025-10-16T16:00:00.000Z","path":"repository/index.html","text":"仓库列表暂未公开。"}],"posts":[{"title":"Ollama RAG 知识库接口服务实现","date":"2025-10-18T06:33:00.000Z","path":"2025/10/18/OllamaRAG知识库接口服务实现/","text":"本节需求 将 RAG 知识库上传、选择和使用以接口方式提供 功能实现 1. 工程结构 123456789101112131415ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层（服务契约）│ ├── IRAGService.java # RAG 服务接口定义│ └── IAiService.java # AI 服务接口定义├── xfg-dev-tech-app/ # 应用层（启动 + 基础设施装配）│ ├── Application.java # Spring Boot 启动类│ ├── config/│ │ ├── OllamaConfig.java│ │ ├── RedisClientConfig.java│ │ └── RedisClientConfigProperties.java│ └── test/│ └── RagPipelineTest.java # 单元测试└── xfg-dev-tech-trigger/ # 触发器层（对外接口） ├── OllamaController.java # Ollama HTTP控制器 └── RAGController.java # RAG HTTP控制器 2. 依赖管理 trigger模块下引入： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-tika-document-reader&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-pgvector-store&lt;/artifactId&gt;&lt;/dependency&gt; 从这里开始就需要使用Redisson了，需要检查根pom，trigger以及app模块都引入了redisson： 12345&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.44.0&lt;/version&gt;&lt;/dependency&gt; 3. 配置管理 这里需要配置redis的链接地址，IP、端口等信息： 本地： 123456789101112131415# Redis 配置redis: sdk: config: host: localhost port: 6379 password: &lt;你的密码&gt; # 没有就删除这一行 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: true 云服务器： 1234567891011121314# Redis 配置redis: sdk: config: host: &lt;部署了redis的公网IP&gt; port: 16379 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: true 4. 代码实现 Redisson配置(RedisClientConfig.java,RedisClientConfigProperties.java) 如果设置了密码，就把.setPassword(properties.getPassword())的注释取消 12345678910111213141516171819202122232425262728293031323334353637383940package cn.bugstack.xfg.dev.tech.config;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.codec.JsonJacksonCodec;import org.redisson.config.Config;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * Redis 客户端，使用 Redisson &lt;a href=&quot;https://github.com/redisson/redisson&quot;&gt;Redisson&lt;/a&gt; */@Configuration@EnableConfigurationProperties(RedisClientConfigProperties.class)public class RedisClientConfig &#123; @Bean(&quot;redissonClient&quot;) public RedissonClient redissonClient(ConfigurableApplicationContext applicationContext, RedisClientConfigProperties properties) &#123; Config config = new Config(); config.setCodec(JsonJacksonCodec.INSTANCE); config.useSingleServer() .setAddress(&quot;redis://&quot; + properties.getHost() + &quot;:&quot; + properties.getPort())// .setPassword(properties.getPassword()) .setConnectionPoolSize(properties.getPoolSize()) .setConnectionMinimumIdleSize(properties.getMinIdleSize()) .setIdleConnectionTimeout(properties.getIdleTimeout()) .setConnectTimeout(properties.getConnectTimeout()) .setRetryAttempts(properties.getRetryAttempts()) .setRetryInterval(properties.getRetryInterval()) .setPingConnectionInterval(properties.getPingInterval()) .setKeepAlive(properties.isKeepAlive()) ; return Redisson.create(config); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package cn.bugstack.xfg.dev.tech.config;import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;/** * Redis 连接配置 &lt;a href=&quot;https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter&quot;&gt;redisson-spring-boot-starter&lt;/a&gt; */@Data@ConfigurationProperties(prefix = &quot;redis.sdk.config&quot;, ignoreInvalidFields = true)public class RedisClientConfigProperties &#123; /** host:ip */ private String host; /** 端口 */ private int port; /** 账密 */ private String password; /** 设置连接池的大小，默认为64 */ private int poolSize = 64; /** 设置连接池的最小空闲连接数，默认为10 */ private int minIdleSize = 10; /** 设置连接的最大空闲时间（单位：毫秒），超过该时间的空闲连接将被关闭，默认为10000 */ private int idleTimeout = 10000; /** 设置连接超时时间（单位：毫秒），默认为10000 */ private int connectTimeout = 10000; /** 设置连接重试次数，默认为3 */ private int retryAttempts = 3; /** 设置连接重试的间隔时间（单位：毫秒），默认为1000 */ private int retryInterval = 1000; /** 设置定期检查连接是否可用的时间间隔（单位：毫秒），默认为0，表示不进行定期检查 */ private int pingInterval = 0; /** 设置是否保持长连接，默认为true */ private boolean keepAlive = true;&#125; 统一响应类实现(Response.java) 1234567891011121314151617181920212223242526package cn.bugstack.xfg.dev.tech.api.response;import lombok.AllArgsConstructor;import lombok.Builder;import lombok.Data;import lombok.NoArgsConstructor;import java.io.Serializable;/** * @author 渣渣熊 * @description 统一响应类 * @create 2025-10-18 15:25 */@Data@Builder@NoArgsConstructor@AllArgsConstructorpublic class Response&lt;T&gt; implements Serializable &#123; private String code; private String info; private T data;&#125; RAG服务接口定义(IRAGService.java) 123456789101112131415161718package cn.bugstack.xfg.dev.tech.api;import cn.bugstack.xfg.dev.tech.api.response.Response;import org.springframework.web.multipart.MultipartFile;import java.util.List;/** * @author 渣渣熊 * @description RAG服务接口定义 * @create 2025-10-18 15:24 */public interface IRAGService &#123; Response&lt;List&lt;String&gt;&gt; queryRagTagList(); Response&lt;String&gt; uploadFile(String ragTag, List&lt;MultipartFile&gt; files);&#125; RAG HTTP控制器(RAGController) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package cn.bugstack.xfg.dev.tech.trigger.http;import cn.bugstack.xfg.dev.tech.api.IRAGService;import cn.bugstack.xfg.dev.tech.api.response.Response;import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.redisson.api.RList;import org.redisson.api.RedissonClient;import org.springframework.ai.document.Document;import org.springframework.ai.reader.tika.TikaDocumentReader;import org.springframework.ai.transformer.splitter.TokenTextSplitter;import org.springframework.ai.vectorstore.PgVectorStore;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import java.util.List;/** * @author 渣渣熊 * @description RAG HTTP控制器 * @create 2025-10-18 15:23 */@Slf4j@RestController()@CrossOrigin(&quot;*&quot;)@RequestMapping(&quot;/api/v1/rag/&quot;)public class RAGController implements IRAGService &#123; @Resource private TokenTextSplitter tokenTextSplitter; @Resource private PgVectorStore pgVectorStore; @Resource private RedissonClient redissonClient; @RequestMapping(value = &quot;query_rag_tag_list&quot;, method = RequestMethod.GET) @Override // 从Redis获取所有知识库标签 public Response&lt;List&lt;String&gt;&gt; queryRagTagList() &#123; RList&lt;String&gt; elements = redissonClient.getList(&quot;ragTag&quot;); return Response.&lt;List&lt;String&gt;&gt;builder() .code(&quot;0000&quot;) .info(&quot;调用成功&quot;) .data(elements) .build(); &#125; @RequestMapping(value = &quot;file/upload&quot;, method = RequestMethod.POST, headers = &quot;content-type=multipart/form-data&quot;) @Override public Response&lt;String&gt; uploadFile(@RequestParam String ragTag, @RequestParam(&quot;file&quot;) List&lt;MultipartFile&gt; files) &#123; log.info(&quot;上传知识库开始 &#123;&#125;&quot;, ragTag); for (MultipartFile file : files) &#123; // 1. 文档读取 TikaDocumentReader documentReader = new TikaDocumentReader(file.getResource()); List&lt;Document&gt; documents = documentReader.get(); // 2. 文本分割 List&lt;Document&gt; documentSplitterList = tokenTextSplitter.apply(documents); // 3. 添加知识库标签元数据 documents.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, ragTag)); documentSplitterList.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, ragTag)); // 4. 向量化存储到PostgreSQL pgVectorStore.accept(documentSplitterList); // 5. 更新标签列表 RList&lt;String&gt; elements = redissonClient.getList(&quot;ragTag&quot;); if (!elements.contains(ragTag))&#123; elements.add(ragTag); &#125; &#125; log.info(&quot;上传知识库完成 &#123;&#125;&quot;, ragTag); return Response.&lt;String&gt;builder().code(&quot;0000&quot;).info(&quot;调用成功&quot;).build(); &#125;&#125; 功能测试 1. 文件上传测试 请求路径：http://localhost:8080/api/v1/rag/file/upload Headers Content-Type:multipart/form-data Body: ragTag:&lt;标签名&gt; file:&lt;文件&gt;（这里要将参数类型也改成file，然后上传文件），这里我写了个test.txt： 显示调用成功！ 2. 获取知识库标签测试 请求路径：http://localhost:8080/api/v1/rag/query_rag_tag_list 可以看到我们刚刚上传的&quot;测试&quot;标签！ redis中也可以查看到标签！","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"redis","slug":"redis","permalink":"https://www.zhazhabear.site/tags/redis/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama RAG 知识库上传、解析和验证","date":"2025-10-18T06:16:00.000Z","path":"2025/10/18/OllamaRAG知识库上传、解析和验证/","text":"本节需求 以大模型向量存储的方式，提交本地文件到知识库。并在 AI 对话中增强检索知识库符合 AI 对话内容的资料，合并提交问题。 RAG端到端流程 文件上传与解析：前端/接口上传文件 → 用 TikaDocumentReader 解析为文档 Document。 文本拆分：TokenTextSplitter 拆分文本为片段（按 token/句子/段落等策略）。 文本标记：为每个 Document 片段写入 metadata，如 knowledge: &quot;知识库名称&quot;，用于多库隔离。 向量化存储： 使用 Ollama 的嵌入模型（nomic-embed-text）生成向量。 将片段内容 + metadata + 向量写入 PgVectorStore（PostgreSQL）。 检索增强对话： 问题来临时，基于向量相似度检索最相关的文档片段（TopK、Filter）。 把检索到的片段拼入 System Prompt，再交给聊天模型生成更准确的回答。 功能实现 1. 工程结构 12345678910111213141516171819ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层│ └── IAiService.java # 定义 AI 服务接口，供应用层调用├── xfg-dev-tech-app/ # 应用层│ ├── Application.java # Spring Boot 启动类，应用入口│ ├── config/ # 配置类目录│ │ ├── OllamaConfig.java # 配置 Ollama 嵌入模型与向量存储│ │ ├── RedisClientConfig.java # 配置 Redis 客户端连接│ │ └── RedisClientConfigProperties.java # Redis 客户端属性配置│ └── resources/ # 配置文件目录│ ├── application.yml # 通用配置文件│ ├── application-dev.yml # 开发环境配置文件│ └── logback-spring.xml # 日志配置文件├── xfg-dev-tech-trigger/ # 触发器层│ └── OllamaController.java # HTTP 控制器，处理 Ollama 相关请求└── docs/ # 文档目录 └── dev-ops/ # 运维相关 └── pgvector/sql/ # PostgreSQL 向量扩展脚本 └── init.sql # 初始化 pgvector 扩展 2. 依赖管理 给app模块加入: 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-tika-document-reader&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-pgvector-store-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 分别是用于解析用户上传的文件，提取纯文本内容，以及存储向量化后的文编片段及其元数据。 3. 配置管理 在application.yml种，添加了新的数据库相关配置，以及AI嵌入（Embedding）相关的参数: model: nomic-embed-text 指定使用的嵌入模型为 nomic-embed-text 这个模型专门用于将文本转换为向量表示（嵌入向量） 嵌入向量可以用于语义搜索、文本相似度计算、聚类等任务 options: num-batch: 512 设置批处理大小为 512 表示每次处理文本时，会将文本分成批次，每批包含 512 个token或文本片段 1234567891011121314151617181920212223242526272829303132spring: datasource: driver-class-name: org.postgresql.Driver username: postgres password: postgres url: jdbc:postgresql://&lt;部署了postgresql的公网IP&gt;:15432/ai-rag-knowledge type: com.zaxxer.hikari.HikariDataSource # hikari连接池配置 hikari: #连接池名 pool-name: HikariCP #最小空闲连接数 minimum-idle: 5 # 空闲连接存活最大时间，默认10分钟 idle-timeout: 600000 # 连接池最大连接数，默认是10 maximum-pool-size: 10 # 此属性控制从池返回的连接的默认自动提交行为,默认值：true auto-commit: true # 此属性控制池中连接的最长生命周期，值0表示无限生命周期，默认30分钟 max-lifetime: 1800000 # 数据库连接超时时间,默认30秒 connection-timeout: 30000 # 连接测试query connection-test-query: SELECT 1 ai: ollama: base-url: http://&lt;部署了ollama的公网IP&gt;:11434 embedding: options: num-batch: 512 model: nomic-embed-text 4. pgvector配置 以下操作均在云服务器实现： 12345678# 进入 vector_db 容器docker exec -it vector_db bash# 连接到 ai-rag-knowledge 数据库psql -U postgres -d ai-rag-knowledge# 在 PostgreSQL 提示符下创建 vector 扩展CREATE EXTENSION IF NOT EXISTS vector; 退出容器： 12ai-rag-knowledge=# \\qroot@6a239908062e:/# exit 5. 代码实现 Ollama 配置类OllamaConfig.java 新增三项配置： TokenTextSplitter：文本分割器 SimpleVectorStore：基于内存的向量数据库 PgVectorStore：基于 PostgreSQL 的向量数据库 123456789101112131415161718@Beanpublic TokenTextSplitter tokenTextSplitter() &#123; return new TokenTextSplitter();&#125;@Beanpublic SimpleVectorStore simpleVectorStore(OllamaApi ollamaApi) &#123; OllamaEmbeddingClient embeddingClient = new OllamaEmbeddingClient(ollamaApi); embeddingClient.withDefaultOptions(OllamaOptions.create().withModel(&quot;nomic-embed-text&quot;)); return new SimpleVectorStore(embeddingClient);&#125;@Beanpublic PgVectorStore pgVectorStore(OllamaApi ollamaApi, JdbcTemplate jdbcTemplate) &#123; OllamaEmbeddingClient embeddingClient = new OllamaEmbeddingClient(ollamaApi); embeddingClient.withDefaultOptions(OllamaOptions.create().withModel(&quot;nomic-embed-text&quot;)); return new PgVectorStore(jdbcTemplate, embeddingClient);&#125; 6. 功能测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package cn.bugstack.xfg.dev.tech.test;import com.alibaba.fastjson.JSON;import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.messages.Message;import org.springframework.ai.chat.messages.UserMessage;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.chat.prompt.SystemPromptTemplate;import org.springframework.ai.document.Document;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaOptions;import org.springframework.ai.reader.tika.TikaDocumentReader;import org.springframework.ai.transformer.splitter.TokenTextSplitter;import org.springframework.ai.vectorstore.PgVectorStore;import org.springframework.ai.vectorstore.SearchRequest;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.stream.Collectors;/** * @author 渣渣熊 * @description RAG功能测试 * @create 2025-10-18 13:32 */@Slf4j@ActiveProfiles(&quot;dev&quot;)@SpringBootTestpublic class RAGTest &#123; @Resource private OllamaChatClient ollamaChatClient; @Resource private TokenTextSplitter tokenTextSplitter; @Resource private PgVectorStore pgVectorStore; @Test public void upload() &#123; // 1. 文本上传并解析 TikaDocumentReader reader = new TikaDocumentReader(&quot;./data/file.text&quot;); List&lt;Document&gt; documents = reader.get(); // 2. 文本拆分 List&lt;Document&gt; documentSplitterList = tokenTextSplitter.apply(documents); // 3. 文本标记 documents.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, &quot;知识库名称&quot;)); documentSplitterList.forEach(doc -&gt; doc.getMetadata().put(&quot;knowledge&quot;, &quot;知识库名称&quot;)); // 4. 向量化存储 pgVectorStore.accept(documentSplitterList); log.info(&quot;上传完成&quot;); &#125; @Test public void chat() &#123; String message = &quot;王大瓜，哪年出生&quot;; String SYSTEM_PROMPT = &quot;&quot;&quot; Use the information from the DOCUMENTS section to provide accurate answers but act as if you knew this information innately. If unsure, simply state that you don&#x27;t know. Another thing you need to note is that your reply must be in Chinese! DOCUMENTS: &#123;documents&#125; &quot;&quot;&quot;; SearchRequest request = SearchRequest.query(message).withTopK(5).withFilterExpression(&quot;knowledge == &#x27;知识库名称&#x27;&quot;); List&lt;Document&gt; documents = pgVectorStore.similaritySearch(request); String documentsCollectors = documents.stream().map(Document::getContent).collect(Collectors.joining()); Message ragMessage = new SystemPromptTemplate(SYSTEM_PROMPT).createMessage(Map.of(&quot;documents&quot;, documentsCollectors)); ArrayList&lt;Message&gt; messages = new ArrayList&lt;&gt;(); messages.add(new UserMessage(message)); messages.add(ragMessage); ChatResponse chatResponse = ollamaChatClient.call(new Prompt(messages, OllamaOptions.create().withModel(&quot;deepseek-r1:1.5b&quot;))); log.info(&quot;测试结果:&#123;&#125;&quot;, JSON.toJSONString(chatResponse)); &#125;&#125; 需要在resource目录下创建data/file.text将相关的资料存入：王大瓜 1990年出生 这时候运行测试，运行结果摘要： 123&quot;output&quot;: &#123; &quot;content&quot;: &quot;你好！根据你提供的信息，王大瓜是1990年出生的。如果你有其他问题或需要帮助，请随时告诉我！&quot;&#125; 可以看到，rag知识库按照预期运行了！","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://www.zhazhabear.site/tags/PostgreSQL/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama流式应答接口页面对接","date":"2025-10-15T11:31:00.000Z","path":"2025/10/15/Ollama流式应答接口页面对接/","text":"本节需求 实现一款简单的UI界面，与服务端 Ollama DeepSeek AI 进行对接 前端代码 这里直接贴一份我自己和AI多次对话得到的一个效果还不错的HTML 效果展示 支持的功能 普通请求/流式请求切换 用户可通过界面按钮在普通请求（一次性返回完整消息）与流式请求（逐段返回消息）之间切换。 当前模式会在界面顶部显示，并附带简要说明。 聊天记录快捷导航 支持通过键盘的 ↑/↓ 箭头快速切换上一条或下一条用户发言，方便重复发送或修改。 Markdown 格式渲染 服务端返回的消息支持 Markdown 格式，前端会自动解析并渲染，包括代码块、列表、表格等。 深度思考与普通输出区分 模型的“深度思考”状态会以特殊样式（如灰色背景提示框）显示，普通输出则以常规气泡样式展示。 日志功能 提供日志面板，记录用户请求与服务端响应的详细信息，便于调试与问题排查。 日志支持查看、清空等操作，提升开发与测试效率。 具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;AI Chatbot&lt;/title&gt; &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/marked/marked.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css&quot; integrity=&quot;sha512-SnF4j8kH9Yp5VX1nA2nayJ9uj9Y6p9cHfGppRy5JyE2tdI9lbEKeosFVJeFt3PcTJS3BM4tiTqcK3wwD5cqvug==&quot; crossorigin=&quot;anonymous&quot; referrerpolicy=&quot;no-referrer&quot; /&gt; &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;family=Poppins:wght@400;500;600&amp;display=swap&quot; rel=&quot;stylesheet&quot; /&gt; &lt;style&gt; :root &#123; color-scheme: light; &#125; body.web-page &#123; font-family: &#x27;Inter&#x27;, &#x27;Poppins&#x27;, -apple-system, BlinkMacSystemFont, &#x27;Segoe UI&#x27;, &#x27;PingFang SC&#x27;, &#x27;Microsoft YaHei&#x27;, sans-serif; background: radial-gradient(circle at 15% 20%, rgba(151, 190, 255, 0.22), transparent 55%), radial-gradient(circle at 85% 10%, rgba(120, 180, 255, 0.18), transparent 50%), linear-gradient(180deg, #F4F7FB 0%, #E3F0FF 100%); min-height: 100vh; color: #1F2430; &#125; .glass-card &#123; backdrop-filter: blur(10px); background: rgba(243, 248, 255, 0.9); border: 1px solid rgba(138, 163, 210, 0.2); box-shadow: 0 16px 36px -24px rgba(34, 61, 120, 0.28); &#125; .signal-gradient &#123; background: linear-gradient(90deg, #5A8DEE 0%, #7AD1F8 100%); &#125; #conversation &#123; max-height: 60vh; &#125; /* Markdown 样式 */ .ai-message pre &#123; background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; font-size: 13px; line-height: 1.4; &#125; .ai-message code &#123; background: #f1f3f4; color: #d73a49; padding: 2px 6px; border-radius: 3px; font-size: 12px; font-family: &#x27;SFMono-Regular&#x27;, Consolas, &#x27;Liberation Mono&#x27;, Menlo, monospace; &#125; .ai-message pre code &#123; background: transparent; color: inherit; padding: 0; border-radius: 0; &#125; .ai-message h1, .ai-message h2, .ai-message h3 &#123; color: #1f2937; margin: 16px 0 8px 0; font-weight: 600; &#125; .ai-message h1 &#123; font-size: 1.5em; &#125; .ai-message h2 &#123; font-size: 1.25em; &#125; .ai-message h3 &#123; font-size: 1.125em; &#125; .ai-message p &#123; margin: 8px 0; line-height: 1.6; &#125; .ai-message ul, .ai-message ol &#123; margin: 8px 0; padding-left: 24px; &#125; .ai-message li &#123; margin: 4px 0; &#125; .ai-message blockquote &#123; border-left: 4px solid #e5e7eb; padding-left: 16px; margin: 12px 0; color: #6b7280; font-style: italic; &#125; .ai-message table &#123; border-collapse: collapse; margin: 12px 0; width: 100%; &#125; .ai-message th, .ai-message td &#123; border: 1px solid #e5e7eb; padding: 8px 12px; text-align: left; &#125; .ai-message th &#123; background: #f9fafb; font-weight: 600; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body class=&quot;web-page&quot;&gt; &lt;div class=&quot;max-w-screen-xl mx-auto h-screen px-6 md:px-10 pt-10 pb-16 flex flex-col&quot;&gt; &lt;header class=&quot;mb-10 flex flex-col md:flex-row md:items-center md:justify-between gap-5&quot;&gt; &lt;div class=&quot;flex items-center gap-3&quot;&gt; &lt;span class=&quot;w-12 h-12 rounded-2xl signal-gradient flex items-center justify-center text-white text-2xl font-semibold shadow-lg shadow-blue-100/60&quot;&gt;&lt;/span&gt; &lt;div&gt; &lt;h1 class=&quot;text-2xl font-semibold tracking-tight text-slate-800&quot;&gt;AI Chatbot&lt;/h1&gt; &lt;p class=&quot;text-sm text-slate-500&quot;&gt;Deepseek R1:1.5B&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;glass-card rounded-2xl px-6 py-4 flex items-center gap-4 max-w-2xl&quot;&gt; &lt;div class=&quot;min-w-[140px]&quot;&gt; &lt;p class=&quot;text-xs uppercase tracking-[0.18em] text-slate-500&quot;&gt;当前模式&lt;/p&gt; &lt;p id=&quot;modeLabel&quot; class=&quot;text-lg font-semibold text-slate-700&quot;&gt;普通请求&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 text-xs text-slate-500 leading-relaxed&quot;&gt; &lt;p id=&quot;modeDescription&quot;&gt;一次性返回完整消息。&lt;/p&gt; &lt;p id=&quot;modeHint&quot; class=&quot;mt-1&quot;&gt;点击底部按钮可切换至流式模式。&lt;/p&gt; &lt;/div&gt; &lt;button id=&quot;logToggle&quot; type=&quot;button&quot; class=&quot;shrink-0 h-11 px-4 rounded-xl border border-slate-200/80 text-sm font-medium text-slate-600 flex items-center gap-2 transition hover:border-sky-300 hover:text-sky-600&quot;&gt; &lt;i class=&quot;fa-regular fa-file-lines&quot;&gt;&lt;/i&gt; 查看日志 &lt;/button&gt; &lt;/div&gt; &lt;/header&gt; &lt;main class=&quot;flex-1 flex flex-col overflow-hidden&quot;&gt; &lt;section class=&quot;glass-card rounded-3xl flex-1 overflow-hidden flex flex-col&quot;&gt; &lt;div class=&quot;px-8 pt-8 pb-4 border-b border-slate-200/60&quot;&gt; &lt;h2 class=&quot;text-sm font-semibold text-slate-600 uppercase tracking-wide&quot;&gt;对话区&lt;/h2&gt; &lt;p class=&quot;text-xs text-slate-500 mt-1&quot;&gt;用于展示实时的模型回复与用户消息。&lt;/p&gt; &lt;/div&gt; &lt;div id=&quot;conversation&quot; class=&quot;flex-1 px-8 py-6 overflow-y-auto space-y-4&quot;&gt; &lt;div class=&quot;h-full flex flex-col items-center justify-center text-sm text-slate-400&quot; data-empty-state=&quot;true&quot;&gt; &lt;i class=&quot;fa-regular fa-comment-dots text-xl mb-2&quot;&gt;&lt;/i&gt; &lt;p&gt;还没有消息，输入内容开始对话吧。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=&quot;mt-8&quot;&gt; &lt;form class=&quot;glass-card rounded-3xl px-6 py-4 flex flex-col md:flex-row gap-4 md:items-center&quot; id=&quot;chatForm&quot;&gt; &lt;button type=&quot;button&quot; id=&quot;modeToggle&quot; class=&quot;w-full md:w-auto md:min-w-[160px] h-12 rounded-2xl border border-sky-200/70 text-sky-600 text-sm font-medium flex items-center justify-center gap-2 transition hover:border-sky-400 hover:text-sky-700&quot;&gt; &lt;i class=&quot;fa-solid fa-repeat&quot;&gt;&lt;/i&gt; &lt;span id=&quot;modeToggleLabel&quot;&gt;切换到流式请求&lt;/span&gt; &lt;/button&gt; &lt;div class=&quot;flex-1 flex items-center gap-3&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;messageInput&quot; class=&quot;flex-1 h-12 rounded-2xl border border-transparent bg-white/85 px-4 text-sm text-slate-700 placeholder:text-slate-400 focus:outline-none focus:ring-2 focus:ring-sky-200&quot; placeholder=&quot;直接输入内容即可，不需要命令&quot; autocomplete=&quot;off&quot; required /&gt; &lt;button type=&quot;submit&quot; class=&quot;w-12 h-12 rounded-2xl signal-gradient text-white flex items-center justify-center text-lg shadow-md shadow-blue-200/60 transition hover:shadow-lg hover:-translate-y-0.5&quot;&gt; &lt;i class=&quot;fa-solid fa-paper-plane&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/section&gt; &lt;/main&gt; &lt;/div&gt; &lt;aside id=&quot;logPanel&quot; class=&quot;hidden fixed bottom-6 right-6 w-[320px] max-h-[60vh] glass-card rounded-3xl p-5 flex flex-col shadow-2xl shadow-blue-200/50&quot;&gt; &lt;div class=&quot;flex items-center justify-between mb-3&quot;&gt; &lt;div&gt; &lt;p class=&quot;text-xs uppercase tracking-[0.2em] text-slate-500&quot;&gt;请求日志&lt;/p&gt; &lt;p class=&quot;text-sm font-semibold text-slate-700&quot;&gt;最近活动&lt;/p&gt; &lt;/div&gt; &lt;button id=&quot;logClose&quot; type=&quot;button&quot; class=&quot;w-9 h-9 rounded-lg border border-slate-200/80 text-slate-400 hover:text-slate-600 hover:border-sky-300 transition&quot;&gt; &lt;i class=&quot;fa-solid fa-xmark&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;flex-1 overflow-y-auto pr-1&quot;&gt; &lt;ul id=&quot;logList&quot; class=&quot;space-y-3 text-xs text-slate-500&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;button id=&quot;logClear&quot; type=&quot;button&quot; class=&quot;mt-4 w-full h-10 rounded-xl border border-slate-200/80 text-[13px] text-slate-500 hover:border-sky-300 hover:text-sky-600 transition&quot;&gt;清空日志&lt;/button&gt; &lt;/aside&gt; &lt;script&gt; const DEFAULT_MODEL = &#x27;deepseek-r1:1.5b&#x27;; const modeToggle = document.getElementById(&#x27;modeToggle&#x27;); const modeToggleLabel = document.getElementById(&#x27;modeToggleLabel&#x27;); const modeLabel = document.getElementById(&#x27;modeLabel&#x27;); const modeDescription = document.getElementById(&#x27;modeDescription&#x27;); const modeHint = document.getElementById(&#x27;modeHint&#x27;); const logToggle = document.getElementById(&#x27;logToggle&#x27;); const logPanel = document.getElementById(&#x27;logPanel&#x27;); const logClose = document.getElementById(&#x27;logClose&#x27;); const logClear = document.getElementById(&#x27;logClear&#x27;); const logList = document.getElementById(&#x27;logList&#x27;); const messageInput = document.getElementById(&#x27;messageInput&#x27;); const conversation = document.getElementById(&#x27;conversation&#x27;); const chatForm = document.getElementById(&#x27;chatForm&#x27;); const submitButton = chatForm.querySelector(&#x27;button[type=&quot;submit&quot;]&#x27;); const modes = &#123; standard: &#123; name: &#x27;普通请求&#x27;, description: &#x27;一次性返回完整消息。&#x27;, hint: &#x27;点击底部按钮可切换至流式模式。&#x27;, toggleText: &#x27;切换到流式请求&#x27;, next: &#x27;stream&#x27; &#125;, stream: &#123; name: &#x27;流式请求&#x27;, description: &#x27;逐段返回，适合实时展示。&#x27;, hint: &#x27;点击底部按钮可切换至普通模式。&#x27;, toggleText: &#x27;切换到普通请求&#x27;, next: &#x27;standard&#x27; &#125; &#125;; let currentMode = &#x27;standard&#x27;; let isRequestPending = false; const logs = []; const sentMessages = []; // 用于存储用户发送的消息 let historyIndex = -1; // 用于追踪历史记录的位置 function updateModeUI() &#123; const &#123; name, description, hint, toggleText &#125; = modes[currentMode]; modeLabel.textContent = name; modeDescription.textContent = description; modeHint.textContent = hint; modeToggleLabel.textContent = toggleText; modeToggle.dataset.mode = currentMode; modeToggle.setAttribute(&#x27;aria-pressed&#x27;, currentMode === &#x27;stream&#x27;); modeToggle.title = `$&#123;name&#125; · $&#123;description&#125;`; &#125; function createMessagePreview(text) &#123; const trimmed = text.replace(/\\s+/g, &#x27; &#x27;).trim(); return trimmed.length &gt; 60 ? `$&#123;trimmed.slice(0, 60)&#125;…` : trimmed; &#125; function removeEmptyState() &#123; const emptyState = conversation.querySelector(&#x27;[data-empty-state]&#x27;); if (emptyState) &#123; emptyState.remove(); &#125; &#125; function appendUserMessage(text) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex justify-end&#x27;; const bubble = document.createElement(&#x27;div&#x27;); bubble.className = &#x27;max-w-[70%] rounded-3xl bg-sky-100/80 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words&#x27;; bubble.textContent = text; wrapper.appendChild(bubble); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; &#125; function appendAssistantMessage(initialText = &#x27;模型生成中…&#x27;) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex gap-3&#x27;; const avatar = document.createElement(&#x27;div&#x27;); avatar.className = &#x27;w-9 h-9 rounded-full signal-gradient text-white flex items-center justify-center shadow-md&#x27;; avatar.innerHTML = &#x27;&lt;i class=&quot;fa-solid fa-robot&quot;&gt;&lt;/i&gt;&#x27;; const body = document.createElement(&#x27;div&#x27;); body.className = &#x27;max-w-[72%] rounded-3xl bg-white/90 border border-slate-200/60 px-4 py-3 text-sm text-slate-700 leading-relaxed shadow-sm whitespace-pre-wrap break-words ai-message&#x27;; const thinkDiv = document.createElement(&#x27;div&#x27;); thinkDiv.className = &#x27;mb-2 text-xs text-slate-400 bg-slate-50/50 px-2 py-1 rounded-lg border-l-2 border-slate-300&#x27;; thinkDiv.style.display = &#x27;none&#x27;; thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考...&lt;/strong&gt;&lt;br&gt;&#x27;; const contentDiv = document.createElement(&#x27;div&#x27;); contentDiv.textContent = initialText; body.appendChild(thinkDiv); body.appendChild(contentDiv); wrapper.append(avatar, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; return &#123; bubble: body, thinkDiv, contentDiv &#125;; &#125; function appendSystemMessage(text) &#123; const wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;flex gap-3&#x27;; const badge = document.createElement(&#x27;div&#x27;); badge.className = &#x27;w-9 h-9 rounded-full bg-rose-100 text-rose-500 flex items-center justify-center shadow-sm&#x27;; badge.innerHTML = &#x27;&lt;i class=&quot;fa-solid fa-circle-exclamation&quot;&gt;&lt;/i&gt;&#x27;; const body = document.createElement(&#x27;div&#x27;); const bubble = document.createElement(&#x27;div&#x27;); bubble.className = &#x27;max-w-[72%] rounded-3xl bg-white border border-rose-200 px-4 py-3 text-sm text-rose-600 leading-relaxed whitespace-pre-wrap break-words&#x27;; bubble.textContent = text; body.appendChild(bubble); wrapper.append(badge, body); conversation.appendChild(wrapper); conversation.scrollTop = conversation.scrollHeight; &#125; function addLog(text) &#123; logs.unshift(&#123; text, timestamp: new Date().toLocaleTimeString() &#125;); if (logs.length &gt; 120) &#123; logs.pop(); &#125; renderLogs(); &#125; function renderLogs() &#123; logList.innerHTML = &#x27;&#x27;; if (!logs.length) &#123; const emptyItem = document.createElement(&#x27;li&#x27;); emptyItem.className = &#x27;text-slate-400 text-center py-4&#x27;; emptyItem.textContent = &#x27;暂无日志&#x27;; logList.appendChild(emptyItem); return; &#125; logs.forEach((&#123; text, timestamp &#125;) =&gt; &#123; const item = document.createElement(&#x27;li&#x27;); item.className = &#x27;rounded-2xl border border-slate-200/60 bg-white/80 px-3 py-2.5 shadow-sm&#x27;; item.innerHTML = ` &lt;p class=&quot;text-[11px] text-slate-400&quot;&gt;$&#123;timestamp&#125;&lt;/p&gt; &lt;p class=&quot;mt-1 text-slate-600 leading-relaxed&quot;&gt;$&#123;text&#125;&lt;/p&gt; `; logList.appendChild(item); &#125;); &#125; function toggleFormDisabled(disabled) &#123; submitButton.disabled = disabled; messageInput.disabled = disabled; modeToggle.disabled = disabled; submitButton.classList.toggle(&#x27;opacity-60&#x27;, disabled); submitButton.classList.toggle(&#x27;cursor-not-allowed&#x27;, disabled); messageInput.classList.toggle(&#x27;opacity-70&#x27;, disabled); &#125; modeToggle.addEventListener(&#x27;click&#x27;, () =&gt; &#123; if (isRequestPending) return; currentMode = modes[currentMode].next; updateModeUI(); &#125;); logToggle.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logPanel.classList.toggle(&#x27;hidden&#x27;); if (!logPanel.classList.contains(&#x27;hidden&#x27;)) &#123; renderLogs(); &#125; &#125;); logClose.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logPanel.classList.add(&#x27;hidden&#x27;); &#125;); logClear.addEventListener(&#x27;click&#x27;, () =&gt; &#123; logs.length = 0; renderLogs(); &#125;); chatForm.addEventListener(&#x27;submit&#x27;, async (event) =&gt; &#123; event.preventDefault(); const text = messageInput.value.trim(); if (!text || isRequestPending) &#123; return; &#125; // 添加到历史记录 if (sentMessages[0] !== text) &#123; sentMessages.unshift(text); &#125; historyIndex = -1; // 重置历史记录索引 removeEmptyState(); appendUserMessage(text); messageInput.value = &#x27;&#x27;; messageInput.focus(); const preview = createMessagePreview(text); addLog(`准备发送 $&#123;modes[currentMode].name&#125;：$&#123;preview&#125;`); const aiBubble = appendAssistantMessage(); isRequestPending = true; toggleFormDisabled(true); try &#123; await dispatchRequest(text, aiBubble); &#125; catch (error) &#123; console.error(error); addLog(`$&#123;modes[currentMode].name&#125; 请求失败：$&#123;error.message&#125;`); appendSystemMessage(`请求失败：$&#123;error.message&#125;`); &#125; finally &#123; isRequestPending = false; toggleFormDisabled(false); &#125; &#125;); async function dispatchRequest(message, aiBubble) &#123; const endpoint = currentMode === &#x27;standard&#x27; ? &#x27;generate&#x27; : &#x27;generate_stream&#x27;; const url = `/api/v1/ollama/$&#123;endpoint&#125;?model=$&#123;encodeURIComponent(DEFAULT_MODEL)&#125;&amp;message=$&#123;encodeURIComponent(message)&#125;`; addLog(`请求 URL：$&#123;url&#125;`); try &#123; if (currentMode === &#x27;standard&#x27;) &#123; const &#123; status &#125; = await handleStandardRequest(url, aiBubble); addLog(`普通请求成功 · HTTP $&#123;status&#125;`); &#125; else &#123; const &#123; status &#125; = await handleStreamRequest(url, aiBubble); addLog(`流式请求成功 · HTTP $&#123;status&#125;`); &#125; &#125; catch (error) &#123; aiBubble.contentDiv.innerHTML = marked.parse(`请求失败：$&#123;error.message&#125;`); throw error; &#125; &#125; async function handleStandardRequest(url, aiBubble) &#123; const response = await fetch(url); const status = response.status; if (!response.ok) &#123; const errorText = await response.text().catch(() =&gt; &#x27;&#x27;); throw new Error(`HTTP $&#123;status&#125;$&#123;errorText ? ` · $&#123;errorText&#125;` : &#x27;&#x27;&#125;`); &#125; const contentType = response.headers.get(&#x27;content-type&#x27;) || &#x27;&#x27;; let fullText; if (contentType.includes(&#x27;application/json&#x27;)) &#123; const data = await response.json(); fullText = extractContent(data); &#125; else &#123; fullText = await response.text(); &#125; // 解析 think 和正文 const thinkMatch = fullText.match(/&lt;think&gt;([\\s\\S]*?)&lt;\\/think&gt;/); const thinkContent = thinkMatch ? thinkMatch[1].trim() : &#x27;正在思考中...&#x27;; const mainContent = fullText.replace(/&lt;think&gt;[\\s\\S]*?&lt;\\/think&gt;\\s*/, &#x27;&#x27;).trim(); aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考完毕&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); aiBubble.contentDiv.innerHTML = marked.parse(mainContent || &#x27;（模型没有返回内容）&#x27;); conversation.scrollTop = conversation.scrollHeight; return &#123; status &#125;; &#125; async function handleStreamRequest(url, aiBubble) &#123; const response = await fetch(url); const status = response.status; if (!response.ok) &#123; const errorText = await response.text().catch(() =&gt; &#x27;&#x27;); throw new Error(`HTTP $&#123;status&#125;$&#123;errorText ? ` · $&#123;errorText&#125;` : &#x27;&#x27;&#125;`); &#125; // 重置内容 aiBubble.contentDiv.textContent = &#x27;&#x27;; aiBubble.thinkDiv.style.display = &#x27;none&#x27;; const data = await response.json(); if (Array.isArray(data)) &#123; // 后端返回的是一个完整的JSON数组 let fullText = &#x27;&#x27;; for (const item of data) &#123; const content = extractContent(item); if (content) &#123; fullText += content; // 直接更新文本内容，不再调用会重新渲染的函数 updateStreamDisplay(fullText, aiBubble, true); &#125; // 添加延迟，模拟流式效果 await new Promise(resolve =&gt; setTimeout(resolve, 100)); &#125; &#125; else &#123; // 处理其他可能的JSON结构或错误 const content = extractContent(data); if (content) &#123; updateStreamDisplay(content, aiBubble, false); &#125; else &#123; aiBubble.contentDiv.innerHTML = marked.parse(&#x27;（模型没有返回有效内容）&#x27;); &#125; &#125; return &#123; status &#125;; &#125; // 从单行数据中提取内容 // function extractContentFromLine(line) &#123; ... &#125; // 此函数已不再需要 // 更新流式显示 function updateStreamDisplay(fullText, aiBubble, isStreaming) &#123; // 处理 think 标签 const thinkMatch = fullText.match(/&lt;think&gt;([\\s\\S]*?)(&lt;\\/think&gt;|$)/); if (thinkMatch) &#123; if (!thinkMatch[2]) &#123; // 思考中 const thinkContent = thinkMatch[1]; aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考中...&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); aiBubble.contentDiv.textContent = &#x27;&#x27;; &#125; else &#123; // 思考完成 const thinkContent = thinkMatch[1].trim(); aiBubble.thinkDiv.style.display = &#x27;block&#x27;; aiBubble.thinkDiv.innerHTML = &#x27;&lt;strong&gt;深度思考完毕&lt;/strong&gt;&lt;br&gt;&#x27; + thinkContent.replace(/\\n/g, &#x27;&lt;br&gt;&#x27;); // 提取并显示主要内容 const mainContent = fullText.replace(/&lt;think&gt;[\\s\\S]*?&lt;\\/think&gt;\\s*/, &#x27;&#x27;).trim(); aiBubble.contentDiv.innerHTML = marked.parse(mainContent); &#125; &#125; else &#123; // 直接显示主要内容 aiBubble.contentDiv.innerHTML = marked.parse(fullText); &#125; conversation.scrollTop = conversation.scrollHeight; &#125; // 逐字显示内容 // displayContentGradually 函数已完全删除，不再需要 // 处理非流式响应 // async function processCompleteResponse(text, aiBubble) &#123; ... &#125; // 此函数已不再需要 function extractContent(data) &#123; if (!data) return &#x27;&#x27;; if (typeof data === &#x27;string&#x27;) return data; const maybeContent = data?.result?.output?.content ?? data?.result?.output?.text ?? data?.output?.content ?? data?.message ?? data?.choices?.[0]?.message?.content ?? data?.results?.[0]?.output?.content; if (Array.isArray(maybeContent)) &#123; return maybeContent.map((item) =&gt; &#123; if (typeof item === &#x27;string&#x27;) return item; if (item?.text) return item.text; return &#x27;&#x27;; &#125;).join(&#x27;\\n&#x27;); &#125; if (typeof maybeContent === &#x27;object&#x27; &amp;&amp; maybeContent !== null) &#123; if (maybeContent.text) return maybeContent.text; return &#x27;&#x27;; &#125; if (maybeContent) &#123; return String(maybeContent); &#125; return &#x27;&#x27;; &#125; // 初始化界面 updateModeUI(); renderLogs(); messageInput.addEventListener(&#x27;keydown&#x27;, (event) =&gt; &#123; if (event.key === &#x27;ArrowUp&#x27;) &#123; event.preventDefault(); if (sentMessages.length &gt; 0 &amp;&amp; historyIndex &lt; sentMessages.length - 1) &#123; historyIndex++; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); &#125; &#125; else if (event.key === &#x27;ArrowDown&#x27;) &#123; event.preventDefault(); if (historyIndex &gt; 0) &#123; historyIndex--; messageInput.value = sentMessages[historyIndex]; messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length); &#125; else if (historyIndex &lt;= 0) &#123; historyIndex = -1; messageInput.value = &#x27;&#x27;; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"Ollama流式应答接口实现","date":"2025-10-15T07:45:00.000Z","path":"2025/10/15/Ollama流式应答接口实现/","text":"本节需求 引入 Spring AI 框架组件，对接 Ollama DeepSeek 提供服务接口。包括:普通应答接口和流式接口。 普通请求（同步请求） 普通请求是指客户端一次性发送请求，服务端处理完毕后一次性返回完整的结果。 例如： 流式请求 流式请求是指客户端发送请求后，服务端会将结果分批次，逐步推送给客户端，客户端可以边接收边处理。 例如： 功能实现 1. 工程结构 123456789101112131415ai-rag-knowledge/├── xfg-dev-tech-api/ # API 接口层│ └── IAiService.java # AI 服务接口定义├── xfg-dev-tech-app/ # 应用层│ ├── Application.java # Spring Boot 启动类│ ├── config/ # 配置类│ │ ├── OllamaConfig.java│ │ ├── RedisClientConfig.java│ │ └── RedisClientConfigProperties.java│ └── resources/ # 配置文件│ ├── application.yml│ ├── application-dev.yml│ └── logback-spring.xml└── xfg-dev-tech-trigger/ # 触发器层 └── OllamaController.java # HTTP 控制器 2. 依赖管理 当前步骤需要ollama的依赖，在app模块的POM.xml文件添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt; &lt;artifactId&gt;spring-ai-ollama&lt;/artifactId&gt;&lt;/dependency&gt; 3. 配置管理 配置信息需根据开发与部署环境灵活调整。开发过程中，我在 Windows PC 上进行 Java 开发，Ollama 和 DeepSeek 部署于云服务器的 Docker 环境中，配置文件如下所示： application.yml: 123456spring: application: name: ai-rag-knowledge profiles: active: dev application-dev.yml: 12345678910111213141516171819202122232425262728293031server: port: 8080spring: ai: ollama: # 使用云服务器的 Ollama 服务，将 IP 更换为你自己云服务器的公网 IP # 本地部署的就改为localhost:11434 base-url: http://&lt;部署了Ollama的公网IP&gt;:11434# Redis 配置redis: sdk: config: host: localhost port: 6379 pool-size: 5 min-idle-size: 2 idle-timeout: 30000 connect-timeout: 5000 retry-attempts: 3 retry-interval: 1000 ping-interval: 60000 keep-alive: truelogging: level: root: debug cn.bugstack.xfg.dev.tech: debug config: classpath:logback-spring.xml 其他配置文件暂且不考虑 4. 代码实现 AI服务接口(IAiService.java) 12345678910111213package cn.bugstack.xfg.dev.tech.api;import org.springframework.ai.chat.ChatResponse;import reactor.core.publisher.Flux;public interface IAiService &#123; ChatResponse generate(String model, String message); Flux&lt;ChatResponse&gt; generateStream(String model, String message);&#125; Ollama 配置类 (OllamaConfig.java) 12345678910111213141516171819202122package cn.bugstack.xfg.dev.tech.config;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaApi;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class OllamaConfig &#123; @Bean public OllamaApi ollamaApi(@Value(&quot;$&#123;spring.ai.ollama.base-url&#125;&quot;) String baseUrl) &#123; return new OllamaApi(baseUrl); &#125; @Bean public OllamaChatClient ollamaChatClient(OllamaApi ollamaApi) &#123; return new OllamaChatClient(ollamaApi); &#125;&#125; HTTP 控制器 (OllamaController.java) 123456789101112131415161718192021222324252627282930313233343536373839package cn.bugstack.xfg.dev.tech.trigger.http;import cn.bugstack.xfg.dev.tech.api.IAiService;import jakarta.annotation.Resource;import org.springframework.ai.chat.ChatResponse;import org.springframework.ai.chat.prompt.Prompt;import org.springframework.ai.ollama.OllamaChatClient;import org.springframework.ai.ollama.api.OllamaOptions;import org.springframework.web.bind.annotation.*;import reactor.core.publisher.Flux;@RestController()@CrossOrigin(&quot;*&quot;)@RequestMapping(&quot;/api/v1/ollama/&quot;)public class OllamaController implements IAiService &#123; @Resource private OllamaChatClient chatClient; /** * 同步调用接口 * curl http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1 */ @RequestMapping(value = &quot;generate&quot;, method = RequestMethod.GET) @Override public ChatResponse generate(@RequestParam String model, @RequestParam String message) &#123; return chatClient.call(new Prompt(message, OllamaOptions.create().withModel(model))); &#125; /** * 流式调用接口 * curl http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=hi */ @RequestMapping(value = &quot;generate_stream&quot;, method = RequestMethod.GET) @Override public Flux&lt;ChatResponse&gt; generateStream(@RequestParam String model, @RequestParam String message) &#123; return chatClient.stream(new Prompt(message, OllamaOptions.create().withModel(model))); &#125;&#125; 启动类 12345678910111213141516package cn.bugstack.xfg.dev.tech;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@Configurablepublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class); &#125;&#125; 功能测试 1. 普通请求测试 启动项目，确保云服务器的ollama已经启动后，浏览器地址栏输入：http://localhost:8080/api/v1/ollama/generate?model=deepseek-r1:1.5b&amp;message=1+1，得到结果： 2. 流式请求测试 地址栏输入http://localhost:8080/api/v1/ollama/generate_stream?model=deepseek-r1:1.5b&amp;message=你好啊 将流式请求的文本拼凑得到的响应结果为： 12345&lt;think&gt;&lt;/think&gt;你好！很高兴见到你，有什么我可以帮忙的吗？无论是问题、建议还是闲聊，我都在这儿呢！😊 小结 本节基于 Spring AI 对接了 Ollama（以 DeepSeek 模型为例），分别实现了普通应答与流式应答两类接口： 如果不能出现最终的响应结果，请依次检查： 云服务器防火墙是否开放11434端口 云服务器中ollama是否成功运行 application-dev.yml中base-url是否更改为云服务器的公网IP application-dev.yml中port是否为8080","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"云服务器配置","date":"2025-10-12T13:04:00.000Z","path":"2025/10/12/云服务器配置/","text":"本节需求 购买并初始化云服务器，完成端口放通与 Docker/Compose/Portainer 安装，使用 docker compose 部署 AI Agent 运行所需的组件（Ollama、Redis、向量库），配置 JDK 17 与 Maven，并拉取 DeepSeek R1 1.5B 模型完成联通验证。 云服务要求 AI Agent 至少需要 2C4G 的云服务器。阿里云学生优惠获取的2C2G服务器无法满足性能要求，因此建议购买新的实例以保证模型和服务的稳定运行。 腾讯云 4C4G 实例（79 元/年），性价比较高。参考：腾讯云服务器4C4G 选择Ubuntu 24.04-LTS即可，不需要额外的应用镜像 环境配置 1. 重置密码 这里需要给 root 用户重置密码。 2. 防火墙开放 至少确保下列端口的开放： 3. Termius 安装 Termius 4. Docker 安装 1234567891011121314151617181920212223242526272829# 下载并运行官方安装脚本curl -fsSL https://get.docker.com | sudo shsudo apt updatesudo apt install docker-compose-plugin -y# 检查 Docker 版本docker version# 检查 Docker Compose 版本docker compose version# 创建 Docker 配置目录sudo mkdir -p /etc/docker# 配置镜像加速器（使用腾讯云内网镜像）sudo tee /etc/docker/daemon.json &lt;&lt;EOF&#123; &quot;registry-mirrors&quot;: [ &quot;https://mirror.ccs.tencentyun.com&quot; ]&#125;EOF# 重启 Dockersudo systemctl restart docker# 测试运行一个容器docker run hello-world 如果上述过程没有问题的话，则会显示： 5. AI-Agent 环境配置 创建并切换到 dev-ops 目录： 123cd /mkdir dev-opscd dev-ops 将项目中的 docs 目录下的内容移动至云服务器的 dev-ops 目录下（通过 Termius 的 SFTP）： 然后执行如下命令： 12# 使用 docker compose（注意：部分老命令为 docker-compose）docker compose -f docker-compose-environment-aliyun.yml up -d 即可完成下列组件的安装和配置： 1. Ollama - 大语言模型服务 作用：运行本地化的大语言模型（如 deepseek-r1:1.5b） 用途：提供对话 AI、文本生成、代码解释等 AI 能力 端口：11434 - 可以通过 API 调用模型服务 2. Redis - 缓存和消息队列 作用：高速内存数据库，用作缓存和会话存储 用途：存储用户会话、缓存 AI 响应、临时数据 管理界面：通过 redis-admin 在 8081 端口可视化管理 账密：admin/admin 3. Vector DB - 向量数据库 作用：专门存储和检索向量数据的数据库 用途：存储文档嵌入向量，实现语义搜索、RAG（检索增强生成） 数据库：ai-rag-knowledge 接下来需要完成 Maven，JDK 17 的配置： 1234567891011# 1. 安装 JDK 17 和 Mavensudo apt updatesudo apt install openjdk-17-jdk maven -y# 2. 验证安装java -version # 应该显示 JDK 17mvn -version # 应该显示 Maven 版本# 3. 设置 JAVA_HOMEecho &#x27;export JAVA_HOME=/usr/lib/jvm/java-17-openjdk-amd64&#x27; &gt;&gt; ~/.bashrcsource ~/.bashrc 6. DeepSeek R1 1.5B 模型安装 1. 安装 portainer 12345678910docker volume create portainer_datadocker run -d \\ -p 9000:9000 \\ -p 9443:9443 \\ --name portainer \\ --restart always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce:latest 防火墙开启 9000 端口 立即访问：&lt;公网IP:9000&gt; 进入 portainer 界面 首次登录需要设置管理员账号的用户名和密码 2. 安装 Deepseek R1 在 portainer 中完成如下操作： 然后 Connect，依次输入如下命令： 12345678# 拉取模型，推荐小一点，够做开发就可以ollama pull deepseek-r1:1.5b# （可选）运行模型，运行后关闭，继续安装模型。Ctrl/Command + Dollama run deepseek-r1:1.5b# 向量文本ollama pull nomic-embed-text 命令执行完毕后，即可与 AI 对话： 输入 /exit 退出对话 3. 通过其他途径访问 1. 可以像小傅哥项目中提到的用 sh 脚本： 1234567curl http://&lt;ipv4地址&gt;:11434/api/generate \\ -H &quot;Content-Type: application/json&quot; \\ -d &#x27;&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;1+1&quot;, &quot;stream&quot;: false &#125;&#x27; 5. 也可以用 apifox 发起请求 Body: 12345&#123; &quot;model&quot;: &quot;deepseek-r1:1.5b&quot;, &quot;prompt&quot;: &quot;你好&quot;, &quot;stream&quot;: false&#125; Headers: 成功响应！","tags":[{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城下单支付","date":"2025-09-15T16:00:00.000Z","path":"2025/09/16/下单支付/","text":"内容概述 下单功能以及支付功能的完整实现 流程图 流程分析 graph TB subgraph \"前端层\" A[用户界面] --> B[HTTP请求] end subgraph \"Web层 (s-pay-mall-web)\" B --> C[AliPayController] C --> D[参数验证] end subgraph \"业务层 (s-pay-mall-service)\" D --> E[OrderServiceImpl] E --> F[ProductRPC] E --> G[支付宝SDK] end subgraph \"数据层 (s-pay-mall-dao)\" E --> H[IOrderDao] H --> I[(MySQL数据库)] end subgraph \"外部系统\" G --> J[支付宝网关] J --> K[支付回调] K --> C end subgraph \"异步处理\" E --> L[EventBus事件总线] L --> M[OrderPaySuccessListener] N[定时任务] --> E end 第一阶段：用户下单请求 输入数据： 12345POST /api/v1/alipay/create_pay_order&#123; &quot;userId&quot;: &quot;10001&quot;, &quot;productId&quot;: &quot;100001&quot;&#125; 处理流程： 前端发送 HTTP POST 请求到AliPayController.createPayOrder() Controller 接收 ShopCartReq 对象，包含用户ID和商品ID 数据流向：前端请求 -&gt; AliPayController -&gt; 参数验证 第二阶段：重复订单检查 输入数据：ShopCartReq对象： 1234public class ShopCartReq &#123; private String userId; private String productId;&#125; 处理流程： OrderServiceImpl.createOrder() 被调用 构造查询条件：创建 PayOrder 对象设置 userId 和 productId 调用 IOrderDao.queryUnPayOrder() 查询数据库 1234567891011121314public class PayOrder &#123; private Long id; private String userId; private String productId; private String productName; private String orderId; private Date orderTime; private BigDecimal totalAmount; private String status; private String payUrl; private Date payTime; private Date createTime; private Date updateTime;&#125; 可能的情况： 返回状态为 PAY_WAIT 的未支付订单 直接返回现有的 PayOrderRes{orderId, payUrl} 流程结束，跳转到返回响应阶段 返回状态为 CREATE 的订单 需要重新创建支付单 调用 doPrepayOrder() 方法创建支付单 跳转到支付单创建阶段 返回 null（无相关订单） 继续执行后续流程 数据流向：OrderServiceImpl -&gt; IOrderDao -&gt; MySQL数据库 -&gt; 返回查询结果 第三阶段：商品信息查询 输入数据：productId（String 类型） 处理流程： 调用 ProductRPC.queryProductByProductId() 这是一个模拟的RPC调用，实际返回固定的商品信息 输出数据： 12345678910public class ProductVO &#123; /** 商品ID */ private String productId; /** 商品名称 */ private String productName; /** 商品描述 */ private String productDesc; /** 商品价格 */ private BigDecimal price;&#125; 数据流向：OrderServiceImpl -&gt; ProductRPC -&gt; 返回ProductVO对象 第四阶段：订单数据持久化 输入数据： userId：用户ID productId：商品ID productName：从ProductVO获取的商品名称 price：从ProductVO获取的商品价格 处理流程： 生成16位随机订单号：RandomStringUtils.randomNumeric(16) 构造 PayOrder 对象： 123456789PayOrder.builder() .userId(&quot;10001&quot;) .productId(&quot;100001&quot;) .productName(&quot;new product&quot;) .orderId(&quot;1234567890123456&quot;) // 16位随机数 .totalAmount(new BigDecimal(&quot;1.68&quot;)) .orderTime(new Date()) .status(&quot;CREATE&quot;) // 使用Constants.OrderStatusEnum.CREATE.getCode() .build() 调用 IOrderDao.insert() 插入数据库 执行SQL：INSERT INTO pay_order(...) VALUES(...) 输出数据： 数据库中新增一条订单记录，状态为 CREATE 数据流向：OrderServiceImpl -&gt; 构造PayOrder对象 -&gt; IOrderDao -&gt; MySQL数据库 第五阶段：支付单创建 输入数据： productId：商品ID productName：商品名称 orderId：订单号 totalAmount：订单金额 处理流程： 调用 doPrepayOrder() 方法 创建支付宝请求对象： 123AlipayTradePagePayRequest request = new AlipayTradePagePayRequest();request.setNotifyUrl(notifyUrl); // 异步回调地址request.setReturnUrl(returnUrl); // 同步跳转地址 构造业务参数： 123456&#123; &quot;out_trade_no&quot;: &quot;1234567890123456&quot;, // 商户订单号 &quot;total_amount&quot;: &quot;1.68&quot;, // 订单金额 &quot;subject&quot;: &quot;new product&quot;, // 订单标题 &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;&#125; 调用支付宝SDK：alipayClient.pageExecute(request).getBody() 输出数据： 支付宝返回HTML表单字符串，包含支付页面的完整HTML代码 数据流向：OrderServiceImpl -&gt; 构造支付宝请求 -&gt; 支付宝SDK -&gt; 支付宝服务器 -&gt; 返回支付表单 第六阶段：更新订单支付信息 输入数据： orderId：订单号 payUrl：支付宝返回的HTML表单 status：新状态 PAY_WAIT 处理流程： 构造更新对象： 1234PayOrder payOrder = new PayOrder();payOrder.setOrderId(&quot;1234567890123456&quot;);payOrder.setPayUrl(&quot;&lt;html&gt;支付表单内容&lt;/html&gt;&quot;);payOrder.setStatus(&quot;PAY_WAIT&quot;); 调用 IOrderDao.updateOrderPayInfo() 执行SQL：UPDATE pay_order SET pay_url = ?, status = ?, update_time = now() WHERE order_id = ? 输出数据： 数据库订单记录更新完成，状态变为 PAY_WAIT，包含支付链接 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第七阶段：返回支付响应 输入数据： orderId：订单号 payUrl：支付链接 处理流程： 构造响应对象： 1234PayOrderRes.builder() .orderId(&quot;1234567890123456&quot;) .payUrl(&quot;&lt;html&gt;支付表单&lt;/html&gt;&quot;) .build() 在Controller层包装成统一响应格式： 12345Response.&lt;String&gt;builder() .code(&quot;0000&quot;) // Constants.ResponseCode.SUCCESS.getCode() .info(&quot;调用成功&quot;) // Constants.ResponseCode.SUCCESS.getInfo() .data(payOrderRes.getPayUrl()) .build() 记录成功日志：“商品下单，根据商品ID创建支付单完成” 输出数据（返回给前端）： 12345&#123; &quot;code&quot;: &quot;0000&quot;, &quot;info&quot;: &quot;调用成功&quot;, &quot;data&quot;: &quot;&lt;html&gt;支付宝支付表单HTML代码&lt;/html&gt;&quot;&#125; 数据流向：OrderServiceImpl -&gt; PayOrderRes -&gt; AliPayController -&gt; Response对象 -&gt; 前端页面 第八阶段：用户支付操作 处理流程： 前端接收到支付表单HTML 用户浏览器渲染支付页面 用户在支付宝页面完成付款操作 支付宝处理支付请求并扣款 数据流向：前端页面 -&gt; 用户操作 -&gt; 支付宝支付页面 -&gt; 支付宝服务器处理 第九阶段：支付回调处理 输入数据（支付宝异步回调）： 1POST /api/v1/alipay/pay_notify 参数包括： trade_status: “TRADE_SUCCESS” out_trade_no: “1234567890123456” (商户订单号) trade_no: “2021081622001234567890123456” (支付宝交易号) total_amount: “1.68” sign: “支付宝RSA256签名” 其他支付宝回调参数… 处理流程： AliPayController.payNotify() 接收回调 交易状态验证：检查 trade_status 是否为 “TRADE_SUCCESS” 签名验证： 123String sign = params.get(&quot;sign&quot;);String content = AlipaySignature.getSignCheckContentV1(params);boolean checkSignature = AlipaySignature.rsa256CheckContent(content, sign, alipayPublicKey, &quot;UTF-8&quot;); 记录回调日志：记录交易名称、状态、支付宝交易号、金额等信息 验证失败的输出： 返回字符串 “false” 给支付宝（拒绝回调） 验证成功继续处理… 数据流向：支付宝服务器 -&gt; AliPayController.payNotify() -&gt; 参数解析和验证 第十阶段：订单状态更新 输入数据： orderId：从回调参数 out_trade_no 获取 处理流程： 调用 OrderServiceImpl.changeOrderPaySuccess() 构造更新对象： 123PayOrder payOrderReq = new PayOrder();payOrderReq.setOrderId(&quot;1234567890123456&quot;);payOrderReq.setStatus(&quot;PAY_SUCCESS&quot;); // Constants.OrderStatusEnum.PAY_SUCCESS.getCode() 调用 IOrderDao.changeOrderPaySuccess() 执行SQL：UPDATE pay_order SET status = ?, pay_time = now(), update_time = now() WHERE order_id = ? 输出数据： 数据库订单状态更新为 PAY_SUCCESS 设置支付时间为当前时间 数据流向：OrderServiceImpl -&gt; 构造更新对象 -&gt; IOrderDao -&gt; MySQL数据库 第十一阶段：异步事件发布 输入数据： 更新后的 PayOrder 对象 处理流程： 将订单对象序列化为JSON：JSON.toJSONString(payOrderReq) 通过EventBus发布事件：eventBus.post(jsonString) OrderPaySuccessListener.handleEvent() 监听并处理事件 输出数据： 123456&#123; &quot;orderId&quot;: &quot;1234567890123456&quot;, &quot;status&quot;: &quot;PAY_SUCCESS&quot;, &quot;payTime&quot;: &quot;2025-09-16 10:30:00&quot;, &quot;updateTime&quot;: &quot;2025-09-16 10:30:00&quot;&#125; 后续处理： 商品发货逻辑 积分奖励计算 用户通知推送 返利处理等 数据流向：OrderServiceImpl -&gt; EventBus -&gt; OrderPaySuccessListener -&gt; 后续业务处理 第十二阶段：回调响应返回 输出数据： 向支付宝返回字符串 “success”（表示回调处理成功） 记录日志：“支付回调，支付回调，更新订单 {}” 数据流向：AliPayController -&gt; 支付宝服务器（确认回调处理完成） 异步处理机制 定时任务处理 超时关单： TimeoutCloseOrderJob 每10分钟执行一次 查询超过30分钟未支付的订单：queryTimeoutCloseOrderList() 将订单状态更新为 CLOSE 支付状态主动查询： NoPayNotifyOrderJob 每3秒执行一次 查询超过1分钟未支付且未收到回调的订单：queryNoPayNotifyOrder() 主动调用支付宝接口查询订单实际支付状态 若支付成功则更新订单状态为 PAY_SUCCESS 事件监听器 支付成功事件监听： OrderPaySuccessListener 基于Guava EventBus实现 通过@Subscribe注解订阅支付成功事件 接收JSON格式的订单信息 负责处理支付成功后的异步业务逻辑（如商品发货、积分奖励等）","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城前期准备","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/前期准备/","text":"注意：该项目基于jdk1.8 (java8)，务必确认项目的jdk版本 内容概述 小傅哥项目7-11集的内容，包含类设计与流程分析 1.1. Natapp 内网穿透 内网穿透教程 注意事项：Windows端natapp文件夹内一定要有natapp.exe，下图中没有后缀的版本无法运行 1.2. 微信公众号测试平台 微信公众号测试平台申请教程 对接工程项目地址 1.3. 支付宝沙箱 支付宝沙箱申请使用教程 直接看好像并没有找到“沙箱”选项，往下滑动，即可看到“沙箱” 2.1 MVC 工程框架搭建 + 基础配置 + Git 使用 1. 新建项目 使用IDEA新建Spring Boot项目，发现没有Java 8的选项。 原因可以参考这篇博客解决IDEA创建SpringBoot项目没有Java版本8 省流解决方案：将最上方服务器URL改为start.aliyun.com即可解决问题 其他过程略过，如果觉得上述过程麻烦的话，也可以直接clone仓库 s-pay-mall-mvc 注意：不要直接在idea中通过版本控制新建项目 应该用命令行git clone &lt;链接&gt;的方式clone，然后用idea打开文件夹 然后用git将项目还原回历史版本： 2.2 微信公众号鉴权 本节内容：在 mvc 分层框架结构下添加微信公众号鉴权所需的接口，并通过 natapp 内网穿透组件，暴漏本地接口，让微信公众号平台可以配置使用。 1. common模块部分 MessageTextEntity.java 微信消息实体类 严格按照微信公众平台消息格式规范实现 主要用途 ：封装微信公众号消息的数据结构，支持XML与Java对象的相互转换 关键特性 ： 使用@XStreamAlias注解映射微信消息的XML标签 包含微信消息的标准字段：ToUserName、FromUserName、CreateTime、 MsgType、Event、EventKey等 支持文本消息和事件消息的数据结构 微信模板消息文档 在上面7个字段的基础上加上生成带参的二维码所需要的ticket字段，构成了MessageTextEntity 关于@XStreamAlias注解 SignatureUtil.java 微信签名验证工具 按照微信公众平台提供的签名算法实现 主要用途 ：验证请求是否来源于微信服务器，确保通信安全 关键特性 ： 实现了微信要求的SHA-1加密算法 包含字典序排序、字节数组转十六进制字符串等辅助方法 提供 check 方法进行签名验证 什么时候微信服务器会往你的服务器发请求？ 当您在微信公众平台（公众号或小程序）的后台配置了“服务器地址”（URL）并启用后，以下几种典型场景下，微信服务器都会向您的服务器发送请求： 首次验证服务器 场景：您在后台提交您的服务器地址和Token时，微信会立即向该地址发送一个GET请求，包含signature, timestamp, nonce, echostr参数。 目的：就是为了验证“您提供的这个URL背后确实是一个有效的、理解微信协议的服务”。您服务器上的SignatureUtil.check()方法就是用来处理这个请求的。验证通过后，您需要将接收到的echostr参数原样返回给微信。这样，微信才相信您拥有这个服务器，后续才会把重要消息推送给您。 接收用户消息（消息推送） 场景：当用户在您的公众号里发送文字、图片、语音、位置等消息时，微信服务器会将这些消息打包成一个XML格式的POST请求，发送到您的服务器。 目的：让您的服务器能够处理用户消息，实现自动回复、客服等功能。在处理这些POST请求之前，同样需要先用SignatureUtil.check()验证这个POST请求确实来自微信，而不是黑客伪造的。 接收事件推送（事件推送） 场景：当发生某些事件时，微信也会通知您的服务器。例如： 关注/取关：用户关注您的公众号或取消关注。 菜单点击：用户点击了您自定义的菜单按钮。 支付成功：用户在小程序或公众号内完成了支付。 模板消息发送结果：您发送的模板消息是否成功送达。 目的：让您的服务器能够响应这些重要事件，更新用户状态、触发积分发放、更新订单状态等。同样，这些请求也需要验证签名。 XmlUtil.java XML数据处理工具类 根据微信公众平台对XML消息格式的要求实现 主要用途：处理与微信服务器之间的XML数据交互 关键特性 ： 提供 xmlToMap 方法解析微信请求XML 提供 mapToXML 方法构建响应XML 提供 beanToXml 和 xmlToBean 方法实现对象与XML的相互转换 使用XStream和dom4j库进行XML处理 支持CDATA标记的添加，符合微信消息规范 2. web模块部分 WeixinPortalController 微信公众号后台接口控制器，主要用于与微信服务器进行对接，处理微信公众号的消息接收和事件响应。 同时需要在resources/application-dev.yml下修改配置： 12345# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token 如果遇到natapp显示离线状态的情况，也要在web包下的resources/application-dev.yml将port修改为8080","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]},{"title":"小型支付商城登录功能","date":"2025-09-06T16:00:00.000Z","path":"2025/09/07/登录功能/","text":"内容概述 登录功能设计实现，以及涉及到的类设计与流程分析 流程分析 小傅哥版本流程图： 简略版本流程图： 核心流程： 用户点击登录，浏览器向服务器请求ticket 服务器检测是否缓存有有效的access token，如果没有则向微信服务器请求(请求需要appid和secret两个参数，这两个参数在微信公众平台可以查看)(生成access token：https://developers.weixin.qq.com/doc/service/guide/dev/api/#生成-Access-Token) 服务器使用access token作为参数调用微信服务器的API 微信服务器返回ticket至服务器 服务器将ticket传回给浏览器 浏览器通过ticket拼接出图片URL(https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=xxx) ，并显示二维码 用户扫描网页的二维码 微信服务器回调配置好的回调地址，通知扫码事件，并在请求中携带ticket与扫码用户的openid 浏览器持续向服务器查询登录状态，参数为ticket 服务器收到轮询后如果发现ticket已经绑定了openid，则生成token并返回给浏览器作为登录凭证 1. 用户点击登录，浏览器向服务器请求ticket 12345678fetch(&#x27;http://localhost:8091/api/v1/login/weixin_qrcode_ticket&#x27;) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; const ticket = data.data; // ... &#125; &#125;) 2-5. 服务器获取access token并调用微信API获取ticket 12345678910111213141516171819202122232425262728293031@Overridepublic String createQrCodeTicket() throws Exception &#123; // 1. 检查缓存中是否有access token String accessToken = weixinAccessToken.getIfPresent(appid); if (null == accessToken) &#123; // 没有缓存则向微信服务器请求，需要appid和secret参数 Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); assert weixinTokenRes != null; accessToken = weixinTokenRes.getAccess_token(); weixinAccessToken.put(appid, accessToken); &#125; // 2. 使用access token调用微信API生成二维码 WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); // 3. 获取微信返回的ticket Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); assert null != weixinQrCodeRes; // 4. 返回ticket给前端 return weixinQrCodeRes.getTicket();&#125; 6. 浏览器显示二维码 1qrCodeImg.src = https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=$&#123;ticket&#125;; 7-8. 用户扫码与微信服务器回调 12345678910111213141516171819202122@PostMapping(value = &quot;receive&quot;, produces = &quot;application/xml; charset=UTF-8&quot;)public String post(@RequestBody String requestBody, @RequestParam(&quot;signature&quot;) String signature, @RequestParam(&quot;timestamp&quot;) String timestamp, @RequestParam(&quot;nonce&quot;) String nonce, @RequestParam(&quot;openid&quot;) String openid, @RequestParam(name = &quot;encrypt_type&quot;, required = false) String encType, @RequestParam(name = &quot;msg_signature&quot;, required = false) String msgSignature) &#123; try &#123; // 消息转换 MessageTextEntity message = XmlUtil.xmlToBean(requestBody, MessageTextEntity.class); // 处理扫码事件 if (&quot;event&quot;.equals(message.getMsgType()) &amp;&amp; &quot;SCAN&quot;.equals(message.getEvent())) &#123; // 保存登录状态（ticket与openid的绑定） loginService.saveLoginState(message.getTicket(), openid); return buildMessageTextEntity(openid, &quot;登录成功&quot;); &#125; // ... &#125; // ...&#125; 9-10. 浏览器轮询与登录状态验证 12345678910111213141516171819// 前端轮询检查登录状态const intervalId = setInterval(() =&gt; &#123; checkLoginStatus(ticket, intervalId);&#125;, 3000); // 每3秒检查一次function checkLoginStatus(ticket, intervalId) &#123; fetch(`http://localhost:8091/api/v1/login/check_login?ticket=$&#123;ticket&#125;`) .then(response =&gt; response.json()) .then(data =&gt; &#123; if (data.code === &quot;0000&quot;) &#123; console.info(&quot;login success&quot;); // 停止轮询 clearInterval(intervalId); // 保存登录 token 到 cookie // ... &#125; &#125;) // ...&#125; 类设计 common模块 Constants 类的作用 定义通用常量：如SPLIT常量用于字符串分割 统一响应码管理：通过ResponseCode枚举定义标准化的API响应码和信息 订单状态管理：通过OrderStatusEnum枚举定义标准化的订单状态流转 注解解析 @AllArgsConstructor 作用：自动生成包含所有字段的构造方法 @NoArgsConstructor 作用：自动生成无参构造方法 @Getter 作用：自动生成所有字段的getter方法 AppException 类的作用：AppException是项目中定义的自定义运行时异常类，主要用于统一管理和处理业务逻辑中的异常情况。定义了两个核心字段 code ：异常码，用于标识不同类型的异常 info ：异常描述信息，提供详细的错误说明 @EqualsAndHashCode(callSuper = true) 作用：主要用于自动生成Java对象的equals()和hashCode()方法，其参数callSuper的作用是：是否调用父类的equals和hashCode方法。默认情况下为 false，即不会调用父类的方法 参考文章 Reponse 类的作用：Response是项目中定义的标准API响应封装类，主要用于统一规范前后端交互的数据格式。包含三个核心字段： code ：响应状态码 info ：响应描述信息 data ：泛型数据字段 @Data 自动生成所有字段的getter和setter方法 自动生成toString()方法，格式化输出对象信息 自动生成equals()和hashCode()方法，支持对象比较 自动生成canEqual()方法，用于判断对象是否为同一类型 @Builder 提供建造者模式的实现，支持链式调用设置属性 生成静态的builder()方法，用于创建Builder实例 生成Builder内部类，包含各个字段的setter方法 特别适合创建属性较多的对象，使代码更简洁、可读性更高 domain模块 domain包包含了以下四类： po/WeixinTemplateMessageVO.java - 微信模板消息值对象 req/WeixinQrCodeReq.java - 微信二维码请求数据封装类 res/WeixinQrCodeRes.java - 微信二维码响应数据封装类 res/WeixinTokenRes.java - 微信AccessToken响应数据封装类 发送模板消息 获取AccessToken 生成带参的二维码 web模块 关于 @configuration：用该注解修饰的类本身也是一个Bean，但它的主要职责是生产其他Bean，里面包含了用于定义和组装Spring容器中Bean的配置信息。 @Configuration和@Component的区别： 关键在于@Configuration使用了CGLIB代理，保证了所有带有@Bean注解的方法都是单例的。 其中Guava在本项目的主要作用是作为本地缓存缓存AccessToken和OpenIdToken，这里也可以用Redis替代。 Retrofit2用于与微信API进行通信。 LoginController 类的作用：LoginController是项目中定义的登录控制器类，主要负责处理用户登录相关的请求。 内有两个方法weixinQrCodeTicket()生成微信二维码，以及checkLogin()用于检查登录状态。 service模块 注意事项 在web包下的application-dev.yml中，增加teplate_id字段： 12345678# 微信公众号对接weixin: config: originalid: #填写你的originalid token: #填写你的token app-id: #填写你的app-id app-secret: #填写你的app-secret template_id: #填写你的template_id 扩展 将本地缓存Guava修改为Redis 1. 在pom.xml中添加Redis的依赖 这里我们可以选择引入Redis或者直接引入Redisson，这里我们选择Redisson 在web模块下的pom.xml中添加redisson的依赖： 1234 &lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; 注意：这里不需要引入版本号，因为根pom已经定义了版本号 2. 在application-dev.yml中添加Redis的配置 注意：如果没有密码务必删除password这行，不然有可能出现连接问题 123456spring: redis: host: 127.0.0.1 port: 6379 password: #这里用你自己的密码，如果没有密码请删除此行 database: 0 3. 定义RedissonConfig配置类 因为我们引入了redisson-spring-boot-starter，Spring Boot会自动帮助我们配置redisson，可以选择不定义RedissonConfig 但是，如果发现在Redis中存的数据出现乱码的情况，可以选择定义RedissonConfig来避免这个问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.bugstack.config;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;import org.redisson.Redisson;import org.redisson.api.RedissonClient;import org.redisson.codec.JsonJacksonCodec;import org.redisson.config.Config;import org.redisson.config.SingleServerConfig;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.StringUtils;/** * @author 渣渣熊 * @description Redisson配置类 * @create 2025-09-10 17:39 */@Configurationpublic class RedissonConfig &#123; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private String port; @Value(&quot;$&#123;spring.redis.password:&#125;&quot;) private String password; @Bean public RedissonClient redissonClient() &#123; Config config = new Config(); SingleServerConfig serverConfig = config.useSingleServer() .setAddress(&quot;redis://&quot; + host + &quot;:&quot; + port); // 1. 创建自定义 ObjectMapper ObjectMapper mapper = new ObjectMapper(); // 2. 注册Java 8时间模块 mapper.registerModule(new JavaTimeModule()); // 3. 禁用时间戳格式 mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS); // 4. 使用自定义ObjectMapper创建编解码器 config.setCodec(new JsonJacksonCodec(mapper)); if (StringUtils.hasText(password)) &#123; serverConfig.setPassword(password); &#125; return Redisson.create(config); &#125;&#125; 4. 测试Redisson连接 如果前面部分都没有问题，这里的测试类应该也都能顺利通过，测试类应该位于web模块下的test文件夹中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.bugstack.test;import org.junit.jupiter.api.Test;import org.redisson.api.RBucket;import org.redisson.api.RMap;import org.redisson.api.RSet;import org.redisson.api.RedissonClient;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.ActiveProfiles;import javax.annotation.Resource;import java.util.concurrent.TimeUnit;import static org.junit.jupiter.api.Assertions.*;/** * @author 渣渣熊 * @description 测试 Redisson是否配置成功 * @create 2025-09-09 21：10 */@SpringBootTest@ActiveProfiles(&quot;dev&quot;)public class RedissonTest &#123; @Resource private RedissonClient redissonClient; /** * 测试Redisson连接是否正常 */ @Test public void testConnection() &#123; assertNotNull(redissonClient, &quot;RedissonClient should not be null&quot;); System.out.println(&quot;Redisson连接测试成功！&quot;); &#125; /** * 测试字符串操作 */ @Test public void testStringOperations() &#123; String key = &quot;test:string:key&quot;; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(&quot;Hello Redisson!&quot;); System.out.println(bucket.get()); bucket.delete(); assertNull(redissonClient.getBucket(key).get()); System.out.println(&quot;字符串操作测试成功，并已清理测试数据&quot;); &#125;&#125; 如果两个方法都通过，则可以认为Redisson配置没有问题 5. Redisson代替Guava后的完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package cn.bugstack.service.impl;import cn.bugstack.domain.po.WeixinTemplateMessageVO;import cn.bugstack.domain.req.WeixinQrCodeReq;import cn.bugstack.domain.res.WeixinQrCodeRes;import cn.bugstack.domain.res.WeixinTokenRes;import cn.bugstack.service.ILoginService;import cn.bugstack.service.weixin.IWeixinApiService;import org.redisson.api.RBucket;import org.redisson.api.RedissonClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import retrofit2.Call;import javax.annotation.Resource;import java.io.IOException;import java.time.Duration;import java.util.HashMap;import java.util.Map;import static cn.bugstack.common.constants.RedisConstants.*;@Servicepublic class WeixinLoginServiceImpl implements ILoginService &#123; private static final Logger logger = LoggerFactory.getLogger(WeixinLoginServiceImpl.class); @Value(&quot;$&#123;weixin.config.app-id&#125;&quot;) private String appid; @Value(&quot;$&#123;weixin.config.app-secret&#125;&quot;) private String appSecret; @Value(&quot;$&#123;weixin.config.template_id&#125;&quot;) private String template_id; @Resource private IWeixinApiService weixinApiService; @Resource private RedissonClient redissonClient; @Override public String createQrCodeTicket() &#123; try &#123; logger.info(&quot;开始创建微信二维码ticket, appid: &#123;&#125;&quot;, appid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 生成 ticket WeixinQrCodeReq weixinQrCodeReq = WeixinQrCodeReq.builder() .expire_seconds(2592000) .action_name(WeixinQrCodeReq.ActionNameTypeVO.QR_SCENE.getCode()) .action_info(WeixinQrCodeReq.ActionInfo.builder() .scene(WeixinQrCodeReq.ActionInfo.Scene.builder() .scene_id(100601) .build()) .build()) .build(); Call&lt;WeixinQrCodeRes&gt; call = weixinApiService.createQrCode(accessToken, weixinQrCodeReq); WeixinQrCodeRes weixinQrCodeRes = call.execute().body(); if (weixinQrCodeRes == null || weixinQrCodeRes.getTicket() == null) &#123; throw new RuntimeException(&quot;微信API返回空响应或缺少ticket&quot;); &#125; logger.info(&quot;成功创建微信二维码ticket: &#123;&#125;&quot;, weixinQrCodeRes.getTicket()); return weixinQrCodeRes.getTicket(); &#125; catch (Exception e) &#123; logger.error(&quot;创建微信二维码ticket失败&quot;, e); throw new RuntimeException(&quot;Failed to create QR code ticket&quot;, e); &#125; &#125; @Override public String checkLogin(String ticket) &#123; String key = OPENID_KEY_PREFIX + ticket; String result = redissonClient.&lt;String&gt;getBucket(key).get(); return result != null ? result : &quot;&quot;; &#125; @Override public void saveLoginState(String ticket, String openid) throws IOException &#123; try &#123; String key = OPENID_KEY_PREFIX + ticket; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); bucket.set(openid, Duration.ofHours(OPENID_TTL)); logger.info(&quot;已保存登录状态, ticket: &#123;&#125;, openid: &#123;&#125;&quot;, ticket, openid); // 1. 获取 accessToken String accessToken = getAccessToken(); // 2. 发送模板消息 Map&lt;String, Map&lt;String, String&gt;&gt; data = new HashMap&lt;&gt;(); WeixinTemplateMessageVO.put(data, WeixinTemplateMessageVO.TemplateKey.USER, openid); WeixinTemplateMessageVO templateMessageDTO = new WeixinTemplateMessageVO(openid, template_id); templateMessageDTO.setUrl(&quot;http://www.zhazhabear.site&quot;); templateMessageDTO.setData(data); Call&lt;Void&gt; call = weixinApiService.sendMessage(accessToken, templateMessageDTO); call.execute(); logger.info(&quot;已发送微信模板消息, openid: &#123;&#125;&quot;, openid); &#125; catch (Exception e) &#123; logger.error(&quot;保存登录状态或发送模板消息失败&quot;, e); throw e; // 重新抛出异常 &#125; &#125; private String getAccessToken() throws IOException &#123; String key = ACCESS_TOKEN_KEY_PREFIX + appid; RBucket&lt;String&gt; bucket = redissonClient.getBucket(key); String accessToken = bucket.get(); if (null == accessToken) &#123; logger.info(&quot;缓存中未找到accessToken，从微信API获取&quot;); Call&lt;WeixinTokenRes&gt; call = weixinApiService.getToken(&quot;client_credential&quot;, appid, appSecret); WeixinTokenRes weixinTokenRes = call.execute().body(); if (weixinTokenRes != null &amp;&amp; weixinTokenRes.getAccess_token() != null) &#123; accessToken = weixinTokenRes.getAccess_token(); bucket.set(accessToken, Duration.ofHours(ACCESS_TOKEN_TTL)); logger.info(&quot;成功获取并缓存accessToken&quot;); &#125; else &#123; throw new IOException(&quot;从微信API获取accessToken失败&quot;); &#125; &#125; else &#123; logger.debug(&quot;从缓存中获取accessToken&quot;); &#125; return accessToken; &#125;&#125;","tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}],"categories":[{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}]}],"categories":[{"name":"AI Agent学习","slug":"AI-Agent学习","permalink":"https://www.zhazhabear.site/categories/AI-Agent%E5%AD%A6%E4%B9%A0/"},{"name":"小型支付商城学习","slug":"小型支付商城学习","permalink":"https://www.zhazhabear.site/categories/%E5%B0%8F%E5%9E%8B%E6%94%AF%E4%BB%98%E5%95%86%E5%9F%8E%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"后端开发","slug":"后端开发","permalink":"https://www.zhazhabear.site/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"项目学习","slug":"项目学习","permalink":"https://www.zhazhabear.site/tags/%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"},{"name":"RAG","slug":"RAG","permalink":"https://www.zhazhabear.site/tags/RAG/"},{"name":"redis","slug":"redis","permalink":"https://www.zhazhabear.site/tags/redis/"},{"name":"Docker","slug":"Docker","permalink":"https://www.zhazhabear.site/tags/Docker/"},{"name":"Ollama","slug":"Ollama","permalink":"https://www.zhazhabear.site/tags/Ollama/"},{"name":"PostgreSQL","slug":"PostgreSQL","permalink":"https://www.zhazhabear.site/tags/PostgreSQL/"},{"name":"前端页面","slug":"前端页面","permalink":"https://www.zhazhabear.site/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2/"},{"name":"Portainer","slug":"Portainer","permalink":"https://www.zhazhabear.site/tags/Portainer/"},{"name":"运维","slug":"运维","permalink":"https://www.zhazhabear.site/tags/%E8%BF%90%E7%BB%B4/"},{"name":"支付宝沙箱","slug":"支付宝沙箱","permalink":"https://www.zhazhabear.site/tags/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1/"},{"name":"Natapp","slug":"Natapp","permalink":"https://www.zhazhabear.site/tags/Natapp/"},{"name":"微信登录","slug":"微信登录","permalink":"https://www.zhazhabear.site/tags/%E5%BE%AE%E4%BF%A1%E7%99%BB%E5%BD%95/"}]}